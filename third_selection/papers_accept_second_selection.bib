@Article{MATTSON20151,
  author          = {Mattson, Donald C},
  title           = {{Usability assessment of a mobile app for art therapy}},
  journal         = {The Arts in Psychotherapy},
  year            = {2015},
  volume          = {43},
  pages           = {1--6},
  issn            = {0197-4556},
  abstract        = {Art therapists recently assembled a list of desirable features for an art therapy app. The Art Therapy Draw! app includes two of them in its design: a portfolio option, and stronger security. Five art therapists evaluated the app through a System Usability Scale (SUS). The evaluation revealed both positive qualities of the program and areas requiring improvement. Overall, the layout of the app proved easy to navigate and required little knowledge to operate. It offered more security measures than other apps. In addition, the expert users commented that the app would likely be suitable for use with disabled persons or those allergic to conventional art materials. This study marks a step toward instituting design considerations for emerging mobile art therapy.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0197455615000088},
  bdsk-url-2      = {https://doi.org/10.1016/j.aip.2015.02.005},
  doi             = {https://doi.org/10.1016/j.aip.2015.02.005},
  keywords        = {Computer, Digital, Drawing, Mobile,App},
  url             = {http://www.sciencedirect.com/science/article/pii/S0197455615000088},
}

@Article{OPASIAK201980,
  author          = {Opasiak, Krzysztof and Mazurczyk, Wojciech},
  title           = {{(In)Secure Android Debugging: Security analysis and lessons learned}},
  journal         = {Computers {\&} Security},
  year            = {2019},
  volume          = {82},
  pages           = {80--98},
  issn            = {0167-4048},
  abstract        = {Universal Serial Bus (USB) is currently one of the most popular standards that controls communication between personal computers (PCs) and their peripheral devices. Thus, it is important to establish whether such connections are properly secured especially when USB is used to connect devices like smartphones, tablets, etc. where sensitive user data can be potentially stored. For this reason, this paper evaluates security of the recent Android versions with respect to the USB-related attacks. In particular, we present a novel approach to compromise Android-based devices by exploiting Android Debug Bridge (ADB) protocol using Man in the Middle (MitM) attacks. Comprehensive analysis of those types of attacks have revealed five novel security vulnerabilities in the Android OS. Security gaps found in this paper cannot only be used to bypass the lock screen security and to gain unauthorized access to the user's private data but also to enable future ADB attacks by incorporating a backdoor to bypass phone security at any time. We also developed a tool which exploits all discovered vulnerabilities and can serve as a security mean to assess current ADB implementations as well as future protocol improvements. By disclosing new security weaknesses we want to raise security awareness of the users, researches, security professionals, and developers related to the USB-related attacks and to the threat they pose not only to PCs but also to the USB devices.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S016740481831023X},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2018.12.010},
  doi             = {https://doi.org/10.1016/j.cose.2018.12.010},
  keywords        = {ADB, Android, MITM, USB,Mobile security},
  url             = {http://www.sciencedirect.com/science/article/pii/S016740481831023X},
}

@Article{Betarte2018271,
  author          = {Betarte, G and Campo, J and Gorostiaga, F and Luna, C},
  title           = {{A certified reference validation mechanism for the permission model of android}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2018},
  volume          = {10855 LNCS},
  pages           = {271--288},
  abstract        = {Android embodies security mechanisms at both OS and application level. In this platform application security is built primarily upon a system of permissions which specify restrictions on the operations a particular process can perform. The critical role of these security mechanisms makes them a prime target for (formal) verification. We present an idealized model of a reference monitor of the novel mechanisms of Android 6 (and further), where it is possible to grant permissions at run time. Using the programming language of the proof-assistant Coq we have developed a functional implementation of the reference validation mechanism and certified its correctness with respect to the specified reference monitor. Several properties concerning the permission model of Android 6 and its security mechanisms have been formally formulated and proved. Applying the program extraction mechanism provided by Coq we have also derived a certified Haskell prototype of the reference validation mechanism. {\textcopyright} 2018, Springer International Publishing AG, part of Springer Nature.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-94460-9_16},
  doi             = {10.1007/978-3-319-94460-9_16},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050340811{\&}doi=10.1007{\%}2F978-3-319-94460-9{\_}16{\&}partnerID=40{\&}md5=b58fbefc110aeea698222f3711f45797},
}

@Conference{Amalfitano201650,
  author          = {Amalfitano, D and Amatucci, N and Fasolino, A R and Tramontana, P},
  title           = {{A conceptual framework for the comparison of fully automated GUI testing techniques}},
  booktitle       = {Proceedings - 2015 30th IEEE/ACM International Conference on Automated Software Engineering Workshops, ASEW 2015},
  year            = {2016},
  pages           = {50--57},
  abstract        = {Fully automated GUI testing techniques play an important role in the modern software development life cycles. These techniques are implemented by algorithms that automatically traverse the GUI by interacting with it, like robots discovering unexplored spaces. These algorithms are able to define and run test cases on the fly, while the application is in execution. Testing adequacy, performance or costs of such techniques may differ on the basis of different factors. In this paper we will propose an approach for comparing fully automated GUI testing techniques in a systematic manner. The approach is based on a generalized parametric algorithm that abstracts the key aspects of these techniques and provides a conceptual framework that can be used to define and compare different testing approaches. To validate the framework, we exploit it to compare the testing adequacy and the GUI models inferred by 9 fully automated testing techniques obtained by varying the configuration of the algorithm. The experiment is performed on a real Android application. {\textcopyright} 2015 IEEE.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ASEW.2015.19},
  doi             = {10.1109/ASEW.2015.19},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84964452685{\&}doi=10.1109{\%}2FASEW.2015.19{\&}partnerID=40{\&}md5=dd7d20ce2194c68e563657642d07384e},
}

@Article{JUNIOR2019503,
  author          = {Junior, Warley and Oliveira, Eduardo and Santos, Albertinin and Dias, Kelvin},
  title           = {{A context-sensitive offloading system using machine-learning classification algorithms for mobile cloud environment}},
  journal         = {Future Generation Computer Systems},
  year            = {2019},
  volume          = {90},
  pages           = {503--520},
  issn            = {0167-739X},
  abstract        = {Computational offloading in Mobile Cloud Computing (MCC) has attracted attention due to benefits in energy saving and improved mobile application performance. Nevertheless, this technique underperforms if the offloading decision ignores contextual information. While recent studies have highlighted the use of contextual information to improve the computational offloading decision, there still remain challenges regarding the dynamic nature of the MCC environment. Most solutions design a single reasoner for the offloading decision and do not know how accurate and precise this technique is, so that when applied in real-world environments it can contribute to inaccurate decisions and consequently the low performance of the overall system. Thus, this paper proposes a Context-Sensitive Offloading System (CSOS) that takes advantage of the main machine-learning reasoning techniques and robust profiling system to provide offloading decisions with high levels of accuracy. We first evaluate the main classification algorithms under our database and the results show that JRIP and J48 classifiers achieves 95{\%} accuracy. Secondly, we develop and evaluate our system under controlled and real scenarios, where context information changes from one experiment to another. Under these conditions, CSOS makes correct decisions as well as ensuring performance gains and energy efficiency.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X17326729},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2018.08.026},
  doi             = {https://doi.org/10.1016/j.future.2018.08.026},
  keywords        = {Classification algorithms, Context-sensitive, Machine-learning,Mobile cloud},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X17326729},
}

@Article{ISI:000441910000003,
  author          = {Bagheri, Hamid and Kang, Eunsuk and Malek, Sam and Jackson, Daniel},
  title           = {{A formal approach for detection of security flaws in the android permission system}},
  journal         = {FORMAL ASPECTS OF COMPUTING},
  year            = {2018},
  volume          = {30},
  number          = {5},
  pages           = {525--544},
  issn            = {0934-5043},
  abstract        = {The ever increasing expansion of mobile applications into nearly every
aspect of modern life, from banking to healthcare systems, is making
their security more important than ever. Modern smartphone operating
systems (OS) rely substantially on the permission-based security model
to enforce restrictions on the operations that each application can
perform. In this paper, we perform an analysis of the permission
protocol implemented in Android, a popular OS for smartphones. We
propose a formal model of the Android permission protocol in Alloy, and
describe a fully automatic analysis that identifies potential flaws in
the protocol. A study of real-world Android applications corroborates
our finding that the flaws in the Android permission protocol can have
severe security implications, in some cases allowing the attacker to
bypass the permission checks entirely.},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s00165-017-0445-z},
  doi             = {10.1007/s00165-017-0445-z},
}

@Conference{Milosevic201673,
  author          = {Milosevic, J and Malek, M and Ferrante, A},
  title           = {{A friend or a foe? Detecting malware using memory and CPU features}},
  booktitle       = {ICETE 2016 - Proceedings of the 13th International Joint Conference on e-Business and Telecommunications},
  year            = {2016},
  volume          = {4},
  pages           = {73--84},
  abstract        = {With an ever-increasing and ever more aggressive proliferation of malware, its detection is of utmost importance. However, due to the fact that IoT devices are resource-constrained, it is difficult to provide effective solutions. The main goal of this paper is the development of lightweight techniques for dynamic malware detection. For this purpose, we identify an optimized set of features to be monitored at runtime on mobile devices as well as detection algorithms that are suitable for battery-operated environments. We propose to use a minimal set of most indicative memory and CPU features reflecting malicious behavior. The performance analysis and validation of features usefulness in detecting malware have been carried out by considering the Android operating system. The results show that memory and CPU related features contain enough information to discriminate between execution traces belonging to malicious and benign applications with significant detection precision and recall. Since the proposed approach requires only a limited number of features and algorithms of low complexity, we believe that it can be used for effective malware detection, not only on mobile devices, but also on other smart elements of IoT. Copyright {\textcopyright} 2016 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.},
  annote          = {cited By 3},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85004107371%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=9553cf6129a5e48aec99b1f9e2ea9e66},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85004107371{\&}partnerID=40{\&}md5=9553cf6129a5e48aec99b1f9e2ea9e66},
}

@Article{GUPTA201674,
  author          = {Gupta, Ujjwal and Korrapati, Spurthi and Matturu, Navyasree and Ogras, Umit Y},
  title           = {{A generic energy optimization framework for heterogeneous platforms using scaling models}},
  journal         = {Microprocessors and Microsystems},
  year            = {2016},
  volume          = {40},
  pages           = {74--87},
  issn            = {0141-9331},
  abstract        = {Mobile platforms are becoming highly heterogeneous by combining a powerful multiprocessor system-on-a-chip (MpSoC) with numerous other resources, including display, memory, power management IC, battery and wireless modems into a compact package. Furthermore, the MpSoC itself is a heterogeneous resource that integrates many processing elements such as CPU cores, GPU, video, image, and audio processors. Platform energy consumption and responsiveness are two major considerations for mobile systems, since they determine the battery life and user satisfaction, respectively. As a result, energy minimization approaches targeting mobile computing need to consider the platform at various levels of granularity. In this paper, we first present power consumption, response time, and energy consumption models for mobile platforms. Using these models, we optimize the energy consumption of baseline platforms under power, response time, and thermal constraints with and without introducing new resources. Finally, we validate the proposed framework through experiments on Qualcomm's Snapdragon 800 Mobile Development Platforms.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0141933115000885},
  bdsk-url-2      = {https://doi.org/10.1016/j.micpro.2015.06.009},
  doi             = {https://doi.org/10.1016/j.micpro.2015.06.009},
  keywords        = {Heterogeneous architectures, Mobile platforms, MpSoC, Performance,Energy optimization},
  url             = {http://www.sciencedirect.com/science/article/pii/S0141933115000885},
}

@InProceedings{Amalfitano2011,
  author          = {Amalfitano, Domenico and Fasolino, Anna Rita and Tramontana, Porfirio},
  title           = {{A GUI Crawling-Based Technique for Android Mobile Application Testing}},
  booktitle       = {2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops},
  year            = {2011},
  pages           = {252--261},
  month           = {mar},
  publisher       = {IEEE},
  abstract        = {As mobile applications become more complex, specific development tools and frameworks as well as cost effective testing techniques and tools will be essential to assure the development of secure, high-quality mobile applications. This paper addresses the problem of automatic testing of mobile applications developed for the Google Android platform, and presents a technique for rapid crash testing and regression testing of Android applications. The technique is based on a crawler that automatically builds a model of the application GUI and obtains test cases that can be automatically executed. The technique is supported by a tool for both crawling the application and generating the test cases. In the paper we present an example of using the technique and the tool for testing a real small size Android application that preliminary shows the effectiveness and usability of the proposed testing approach.},
  bdsk-url-1      = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5954416},
  keywords        = {Android Testing Automation,Android mobile application testing,Androids,Crash Testing,Crawlers,GUI Crawling,GUI crawling-based technique,Google Android platform,Graphical user interfaces,Humanoid robots,Mobile communication,Regression Testing,Smart phones,Testing,automatic testing,cost effective testing techniques,development tools,mobile computing,program testing,rapid crash testing},
  shorttitle      = {Software Testing, Verification and Validation Work},
  url             = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5954416},
}

@Article{TONG201722,
  author          = {Tong, Fei and Yan, Zheng},
  title           = {{A hybrid approach of mobile malware detection in Android}},
  journal         = {Journal of Parallel and Distributed Computing},
  year            = {2017},
  volume          = {103},
  pages           = {22--31},
  issn            = {0743-7315},
  abstract        = {Android security incidents occurred frequently in recent years. This motivates us to study mobile app security, especially in Android open mobile operating system. In this paper, we propose a novel hybrid approach for mobile malware detection by adopting both dynamic analysis and static analysis. We collect execution data of sample malware and benign apps using a net{\_}link technology to generate patterns of system calls related to file and network access. Furthermore, we build up a malicious pattern set and a normal pattern set by comparing the patterns of malware and benign apps with each other. For detecting an unknown app, we use a dynamic method to collect its system calling data. We then compare them with both the malicious and normal pattern sets offline in order to judge the unknown app. Based on the test on a set of mobile malware and benign apps, we found that our approach achieves better detection success rate than some methods using either static analysis or dynamic analysis. What is more, the proposed approach is generic, which can detect different types of malware effectively. Its detection accuracy can be further improved since the pattern sets can be automatically optimized through self-learning.},
  annote          = {Special Issue on Scalable Cyber-Physical Systems},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S074373151630140X},
  bdsk-url-2      = {https://doi.org/10.1016/j.jpdc.2016.10.012},
  doi             = {https://doi.org/10.1016/j.jpdc.2016.10.012},
  keywords        = {Malware detection, Pattern match, System call,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S074373151630140X},
}

@Article{P2019333,
  author          = {P., Vinod and Zemmari, Akka and Conti, Mauro},
  title           = {{A machine learning based approach to detect malicious android apps using discriminant system calls}},
  journal         = {Future Generation Computer Systems},
  year            = {2019},
  volume          = {94},
  pages           = {333--350},
  issn            = {0167-739X},
  abstract        = {The openness of Android framework and the enhancement of users trust have gained the attention of malware writers. The momentum of downloaded applications (app for short) from numerous app stores has stimulated the proliferation of mobile malware. Now the threat is due to the sophistication in malware being written to bypass signature-based detectors. In this paper, we investigate system calls to tackle mobile malware on Android operating system. To do so, we first employed machine learning to extract system calls. We then performed the empirical estimation of system calls derived from diverse datasets employing human interaction and random inputs. After accomplishing intensive experiments on synthesized system calls with two feature selection approach, namely Absolute Difference of Weighted System Calls (ADWSC) and Ranked System Calls using Large Population Test (RSLPT), we validated the results on five datasets. All classifiers generated in Area Under Curve of 1.0 with an accuracy exceeding 99.9{\%} suggest the appropriateness and efficacy of the proposed approach. Finally, we evaluated the effectiveness of classifier against adversarial attacks and found that the classifiers are vulnerable to data poisoning and label flipping attacks. Adversarial examples created by poisoning malware samples resulted in the significant drop of classifier performance on perturbing 12--18 prominent attributes. Moreover, we implemented class label poisoning attacks which brought down the classification accuracy by 50{\%} on altering labels of 50 malicious training instances.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X18306216},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2018.11.021},
  doi             = {https://doi.org/10.1016/j.future.2018.11.021},
  keywords        = {Adversarial attacks, Adversarial machine learning, Classifier, Data poisoning, Feature selection, Machine learning,Malware detection},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X18306216},
}

@InProceedings{ISI:000425267700012,
  author          = {Bangash, Abdul A and Sahar, Hareem and Beg, Mirza O},
  title           = {{A Methodology for Relating Software Structure with Energy Consumption}},
  booktitle       = {2017 IEEE 17TH INTERNATIONAL WORKING CONFERENCE ON SOURCE CODE ANALYSIS AND MANIPULATION (SCAM)},
  year            = {2017},
  series          = {IEEE International Working Conference on Source Code Analysis and Manipulation},
  pages           = {111--120},
  organization    = {IEEE; IEEE Comp Soc; IEEE Tech Council Software Engn},
  abstract        = {With the widespread use of mobile devices relying on limited battery
power, the burden of optimizing applications for energy has shifted
towards the application developers. In their quest to develop energy
efficient applications, developers face the hurdle of measuring the
effect of software change on energy consumption. A naive solution to
this problem would be to have an exhaustive suite of test cases that are
executed upon every change to measure their effect on energy
consumption. This method is inefficient and also suffers from
environment dependent inconsistencies. A more generalized method would
be to relate software structural metrics with its energy consumption
behavior. Previous attempts to relate change in objectoriented metrics
to their effects on energy consumption have been inconclusive. We
observe that structural information is global and executed tests are
rarely comprehensive in their coverage, this approach is prone to
errors. In this paper, we present a methodology to relate software
energy consumption with software structural metrics considering the test
case execution traces. Furthermore, we demonstrate that software
structural metrics can be reliably related to energy consumption
behavior of programs using several versions of three open-source
iteratively developed android applications. We discover that by using
our approach we are able to identify strong correlations between several
software metrics and energy consumption behavior.},
  annote          = {IEEE 17th International Working Conference on Source Code Analysis and Manipulation (SCAM), Shanghai, PEOPLES R CHINA, SEP 17-18, 2017},
  bdsk-url-1      = {http://dx.doi.org/10.1109/SCAM.2017.18},
  doi             = {10.1109/SCAM.2017.18},
  isbn            = {978-1-5386-3238-3},
  issn            = {1942-5430},
}

@Article{WANG2019,
  author          = {Wang, Shanshan and Chen, Zhenxiang and Yan, Qiben and Yang, Bo and Peng, Lizhi and Jia, Zhongtian},
  title           = {{A mobile malware detection method using behavior features in network traffic}},
  journal         = {Journal of Network and Computer Applications},
  year            = {2019},
  issn            = {1084-8045},
  abstract        = {Android has become the most popular mobile platform due to its openness and flexibility. Meanwhile, it has also become the main target of massive mobile malware. This phenomenon drives a pressing need for malware detection. In this paper, we propose a lightweight framework for Android malware identification. Network traffic generated by mobile app is mirrored from the wireless access point to the server for data analysis. All data analysis and malware detection are performed on the server side, which consumes minimum resources on mobile devices without affecting the user experience. Due to the difficulty in identifying disparate malicious behaviors of malware from the network traffic, our method performs a multi-level network traffic analysis, gathering as many features of network traffic as necessary. The proposed method combines network traffic analysis with machine learning algorithm (C4.5) that is capable of identifying Android malware with high accuracy. In an evaluation with 8312 benign apps and 5560 malware samples, our method performs better than other state-of-the-art approaches, and especially when combining two detection mechanisms, it achieves a detection rate of 97.89{\%}. In addition, for the benefit of user, this framework not only displays the final detection results, but also analyzes the behind-the-curtain reason of malicious results. The result explanation also reveals insightful behavioral characteristics of mobile malware.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1084804518304028},
  bdsk-url-2      = {https://doi.org/10.1016/j.jnca.2018.12.014},
  doi             = {https://doi.org/10.1016/j.jnca.2018.12.014},
  keywords        = {Machine learning, Network traffic,Android malware detection},
  url             = {http://www.sciencedirect.com/science/article/pii/S1084804518304028},
}

@Article{CHO201879,
  author          = {Cho, Hwayoung and Yen, Po-Yin and Dowding, Dawn and Merrill, Jacqueline A and Schnall, Rebecca},
  title           = {{A multi-level usability evaluation of mobile health applications: A case study}},
  journal         = {Journal of Biomedical Informatics},
  year            = {2018},
  volume          = {86},
  pages           = {79--89},
  issn            = {1532-0464},
  abstract        = {Objective
To report a methodological approach for the development of a usable mHealth application (app).
Materials and methods
This work was guided by a 3-level stratified view of health information technology (IT) usability evaluation framework. We first describe a number of methodologies for operationalizing each level of the framework. Following the description of each methodology, we present a case study which illustrates the use of our preferred methodologies for the development of a mHealth app. At level 1 (user-task), we applied a card sorting technique to guide the information architecture of a mobile HIV symptom self-management app, entitled mVIP. At level 2 (user-task-system), we conducted a usability evaluation of mVIP in a laboratory setting through end-user usability testing and heuristic evaluation with informatics experts. At level 3 (user-task-system-environment), usability of mVIP was evaluated in a real-world setting following the use of the app during a 3-month trial.
Results
The 3-level usability evaluation guided our work exploring in-depth interactions between the user, task, system, and environment. Integral to the findings from the 3-level usability evaluation, we iteratively refined the app's content, functionality, and interface to meet the needs of our intended end-users.
Discussion and conclusion
The stratified view of the health IT usability evaluation framework is a useful methodological approach for the design, development, and evaluation of mHealth apps. The methodological recommendations for using the theoretical framework can inform future usability studies of mHealth apps.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1532046418301679},
  bdsk-url-2      = {https://doi.org/10.1016/j.jbi.2018.08.012},
  doi             = {https://doi.org/10.1016/j.jbi.2018.08.012},
  keywords        = {Case study, Health information technology, Information systems, Mobile Health, Usability evaluation,Mobile applications},
  url             = {http://www.sciencedirect.com/science/article/pii/S1532046418301679},
}

@Article{ALMIN2015407,
  author          = {Almin, Shaikh Bushra and Chatterjee, Madhumita},
  title           = {{A Novel Approach to Detect Android Malware}},
  journal         = {Procedia Computer Science},
  year            = {2015},
  volume          = {45},
  pages           = {407--417},
  issn            = {1877-0509},
  abstract        = {Android is the world's most popular and the largest installed base of any mobile platform. It has gained huge popularity among Smartphones and is growing very fast because it gives its users a world class platform for creating apps and games and allows them to be distributed instantly. Secondly, it also offers ample free third party applications to be downloaded and installed from Google Play, the premier marketplace for selling and distributing Android apps. Android openness has made it a favourite for users and developers alike. Many apps are getting downloaded by the user from play store every month. However due to this, the number of harmful apps in the form of malwares getting downloaded are also increasing. These malwares performs the various activities behind the scene, such as stealing various sensitive information of the users and signing up victims to subscription services. As a result of this, users are getting affected and their privacy gets compromised. As developers are also free to develop and publish their own creation in a play store without undergoing any scrutiny of their apps, they tend to take the advantage of user's inability to analyze the risk of such apps. This paper proposes a system which would help the users in analysing and removing such harmful apps and thereby protecting their security and privacy. This is achieved by analysing the various permissions used by an application that it has requested during installation. The overall process of analysing apps is done using clustering and classification techniques. The major objective of the proposed system is to detect and remove the malwares that are present in the user's Android device.},
  annote          = {International Conference on Advanced Computing Technologies and Applications (ICACTA)},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1877050915004135},
  bdsk-url-2      = {https://doi.org/10.1016/j.procs.2015.03.170},
  doi             = {https://doi.org/10.1016/j.procs.2015.03.170},
  keywords        = {App/s, Benign., Cluster, Malicious, Malware, Permissions,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S1877050915004135},
}

@Article{VIDAL2018198,
  author          = {Vidal, Jorge Maestre and Monge, Marco Antonio Sotelo and Villalba, Luis Javier Garc{\'{i}}a},
  title           = {{A novel pattern recognition system for detecting Android malware by analyzing suspicious boot sequences}},
  journal         = {Knowledge-Based Systems},
  year            = {2018},
  volume          = {150},
  pages           = {198--217},
  issn            = {0950-7051},
  abstract        = {This paper introduces a malware detection system for smartphones based on studying the dynamic behavior of suspicious applications. The main goal is to prevent the installation of the malicious software on the victim systems. The approach focuses on identifying malware addressed against the Android platform. For that purpose, only the system calls performed during the boot process of the recently installed applications are studied. Thereby the amount of information to be considered is reduced, since only activities related with their initialization are taken into account. The proposal defines a pattern recognition system with three processing layers: monitoring, analysis and decision-making. First, in order to extract the sequences of system calls, the potentially compromised applications are executed on a safe and isolated environment. Then the analysis step generates the metrics required for decision-making. This level combines sequence alignment algorithms with bagging, which allow scoring the similarity between the extracted sequences considering their regions of greatest resemblance. At the decision-making stage, the Wilcoxon signed-rank test is implemented, which determines if the new software is labeled as legitimate or malicious. The proposal has been tested in different experiments that include an in-depth study of a particular use case, and the evaluation of its effectiveness when analyzing samples of well-known public datasets. Promising experimental results have been shown, hence demonstrating that the approach is a good complement to the strategies of the bibliography.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0950705118301424},
  bdsk-url-2      = {https://doi.org/10.1016/j.knosys.2018.03.018},
  doi             = {https://doi.org/10.1016/j.knosys.2018.03.018},
  keywords        = {Intrusion detection, Malware, Mobile devices, Pattern recognition, Sequence alignment,Anomalies},
  url             = {http://www.sciencedirect.com/science/article/pii/S0950705118301424},
}

@Article{ISI:000429229200003,
  author          = {Ouaguid, Abdellah and Abghour, Noreddine and Ouzzif, Mohammed},
  title           = {{A Novel Security Framework for Managing Android Permissions Using Blockchain Technology}},
  journal         = {INTERNATIONAL JOURNAL OF CLOUD APPLICATIONS AND COMPUTING},
  year            = {2018},
  volume          = {8},
  number          = {1},
  pages           = {55--79},
  issn            = {2156-1834},
  abstract        = {This article presents a new framework named ANDROSCANREG (Android
Permissions Scan Registry) that allows to extract and analyze the
requested permissions in an Android application via a decentralized and
distributed system. This framework is based on the emerging technology
Blockchain whose potential is approved in the matter of transparency,
reliability, security and availability without resorting to a central
processing unit judged of trust. ANDROSCANREG consists of two
Blockchains, the first one (PERMBC) will handle analysis, validation and
preparation of the raw results so that they will persist in the second
Blockchain of Bitcoin already existing (BTCBC), which will assume the
role of a Registry of recovered permissions and will save the
permissions history of each version of the applications being scanned
via financial transactions, whose wallet source, recipient wallet and
transaction value have a precise meaning. An example of a simulation
will be presented to describe the different steps, actors, interactions
and messages generated by the different entity of ANDROSCANREG.},
  bdsk-url-1      = {http://dx.doi.org/10.4018/IJCAC.2018010103},
  doi             = {10.4018/IJCAC.2018010103},
}

@Article{Geneiatakis2015192,
  author          = {Geneiatakis, D and Fovino, I N and Kounelis, I and Stirparo, P},
  title           = {{A Permission verification approach for android mobile applications}},
  journal         = {Computers and Security},
  year            = {2015},
  volume          = {49},
  pages           = {192--205},
  abstract        = {Mobile applications build part of their security and privacy on a declarative permission model. In this approach mobile applications, to get access to sensitive resources, have to define the corresponding permissions in a manifest. However, mobile applications may request access to permissions that they do not require for their execution (over-privileges) and offer opportunities to malicious software to gain access to otherwise inaccessible resources. In this paper, we investigate on the declarative permissions model on which security and privacy services of Android rely upon. We propose a practical and efficient permission certification technique, in the direction of risk management assessment. We combine both runtime information and static analysis to profile mobile applications and identify if they are over-privileged or follow the least privilege principle. We demonstrate a transparent solution that neither requires modification to the underlying framework, nor access to the applications' original source code. We assess the effectiveness of our approach, using a randomly selected varied set of mobile applications. Results show that our approach can accurately identify whether an application is over-privileged or not, whilst at the same time guaranteeing the need of declaring specific permissions in the manifest. {\textcopyright}2014 Elsevier Ltd. All rights reserved.},
  annote          = {cited By 26},
  bdsk-url-1      = {http://dx.doi.org/10.1016/j.cose.2014.10.005},
  doi             = {10.1016/j.cose.2014.10.005},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84923259697{\&}doi=10.1016{\%}2Fj.cose.2014.10.005{\&}partnerID=40{\&}md5=ffc4e7d1bc2bf3ca54824c06f4b79719},
}

@Article{PALUMBO2017689,
  author          = {Palumbo, Paolo and Sayfullina, Luiza and Komashinskiy, Dmitriy and Eirola, Emil and Karhunen, Juha},
  title           = {{A pragmatic android malware detection procedure}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {70},
  pages           = {689--701},
  issn            = {0167-4048},
  abstract        = {The academic security research community has studied the Android malware detection problem extensively. Machine learning methods proposed in previous work typically achieve high reported detection performance on fixed datasets. Some of them also report reasonably fast prediction times. However, most of them are not suitable for real-world deployment because requirements for malware detection go beyond these figures of merit. In this paper, we introduce several important requirements for deploying Android malware detection systems in the real world. One such requirement is that candidate approaches should be tested against a stream of continuously evolving data. Such streams of evolving data represent the continuous flow of unknown file objects received for categorization, and provide more reliable and realistic estimate of detection performance once deployed in a production environment. As a case study we designed and implemented an ensemble approach for automatic Android malware detection that meets the real-world requirements we identified. Atomic Naive Bayes classifiers used as inputs for the Support Vector Machine ensemble are based on different APK feature categories, providing fast speed and additional reliability against the attackers due to diversification. Our case study with several malware families showed that different families are detected by different atomic classifiers. To the best of our knowledge, our work contains the first publicly available results generated against evolving data streams of nearly 1 million samples with a model trained over a massive sample set of 120,000 samples.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404817301542},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2017.07.013},
  doi             = {https://doi.org/10.1016/j.cose.2017.07.013},
  keywords        = {Classification, Ensemble learning, Feature selection, Machine learning, Malware detection, Static analysis,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404817301542},
}

@Article{CHOI2018,
  author          = {Choi, Wontae and Kannan, Jayanthkumar and Babic, Domagoj},
  title           = {{A Scalable, Flow-and-Context-Sensitive Taint Analysis of Android Applications.}},
  journal         = {Journal of Visual Languages {\&} Computing},
  year            = {2018},
  issn            = {1045-926X},
  abstract        = {This paper focuses on scalable static analysis techniques for finding information leaks in Android apps. Finding such leaks scalably is challenging because Android apps have on average over 100 invocations of sensitive APIs, yielding a massive multi-source taint analysis problem. We present the design of STAR, a context-sensitive and flow-sensitive multi-source taint analysis aimed at tackling this problem. STAR incorporates two main ideas to achieve high performance and scalability. The first is a novel summarization technique we refer to as symbolic summarization, which is crucial for the analysis to scale well with the number of source APIs. The second is a combination of techniques aimed at efficient propagation of abstract states both within and across method boundaries. Our experiments over a dataset composed of 400,000 apps show that the proposed techniques improve performance over an IFDS-style analysis by a factor of 30 on average, and by up to four orders of magnitude on large apps.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1045926X18302064},
  bdsk-url-2      = {https://doi.org/10.1016/j.jvlc.2018.10.005},
  doi             = {https://doi.org/10.1016/j.jvlc.2018.10.005},
  keywords        = {scalability, summarization, taint analysis,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S1045926X18302064},
}

@Article{Fang2017,
  author          = {Fang, Z and Liu, Q and Zhang, Y and Wang, K and Wang, Z and Wu, Q},
  title           = {{A static technique for detecting input validation vulnerabilities in Android apps}},
  journal         = {Science China Information Sciences},
  year            = {2017},
  volume          = {60},
  number          = {5},
  abstract        = {Input validation vulnerabilities are common in Android apps, especially in inter-component communications. Malicious attacks can exploit this kind of vulnerability to bypass Android security mechanism and compromise the integrity, confidentiality and availability of Android devices. However, so far there is not a sound approach at the source code level for app developers aiming to detect input validation vulnerabilities in Android apps. In this paper, we propose a novel approach for detecting input validation flaws in Android apps and we implement a prototype named EasyIVD, which provides practical static analysis of Java source code. EasyIVD leverages backward program slicing to extract transaction and constraint slices from Java source code. Then EasyIVD validates these slices with predefined security rules to detect vulnerabilities in a known pattern. To detect vulnerabilities in an unknown pattern, EasyIVD extracts implicit security specifications as frequent patterns from the duplicated slices and verifies them. Then EasyIVD semi-automatically confirms the suspicious rule violations and reports the confirmed ones as vulnerabilities. We evaluate EasyIVD on four versions of original Android apps spanning from version 2.2 to 5.0. It detects 58 vulnerabilities including confused deputy attacks and denial of service attacks. Our results prove that EasyIVD can provide a practical defensive solution for app developers. {\textcopyright} 2016, Science China Press and Springer-Verlag Berlin Heidelberg.},
  annote          = {cited By 3},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s11432-015-5422-7},
  doi             = {10.1007/s11432-015-5422-7},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84988354940{\&}doi=10.1007{\%}2Fs11432-015-5422-7{\&}partnerID=40{\&}md5=3b8106736e989fe498bcc524ee89564f},
}

@Conference{Lai2015,
  author          = {Lai, G.-H. and Lee, Y.-H. and Chu, T.-H. and Cheng, T.-H.},
  title           = {{A structure similarity-based approach to malicious android app detection}},
  booktitle       = {Pacific Asia Conference on Information Systems, PACIS 2015 - Proceedings},
  year            = {2015},
  abstract        = {The advance of computational power and storage device equipped the mobile devices to involve more and more peoples' daily works, and store voluminous organization's confidential documents as well as general user's personal data. The extensibility feature of mobile device has attracted many app developers' contributions; while it in turns becomes the attacking target of the computer hackers. The F-Secure has reported that the profit-motivated threats on mobile device have been increasing; that is, an infected mobile device might send out personal or organizations' confidential data or send SMS messages to premium rate numbers without user's consent. Generally, the Android app developer can publish their apps on either official stores (i.e., Google Play) or third-party stores or both. In the Android market, the accumulated number of applications and games has been over one million. However, due to the lack of checking and validating mechanism, attackers can also distribute their malicious apps via the online store platform quickly and easily. As a result, the needs for real-time malware detection and classification become critical for Android users and official market as the number of Android apps increases sharply. In this study, we proposed the structure similarity-based malicious app detection approach to address the need of malicious Android app detection. On the basis of source code analysis, we intend to identify the sensitive features in malicious apps; that is, the API calls and system commands that related to some malicious behaviors, to build their Class- Method-API hierarchies. A new-coming app can be detected as malicious or not by assessing the structure similarity between its hierarchy and that of each malicious app. We have collected 1, 259 malwares from Android Malware Genome Project and 1, 259 benign apps from Google Play market for the evaluation purpose. We intend to implement a k-fold cross-validation and adopt VirusTotal as our performance benchmark. Overall, the proposed approach is expected to effectively and efficiently detect Android malwares and is appropriate for mobile devices because the maintenance and similarity assessment of partial hierarchies cost less space and computation resources.},
  annote          = {cited By 0},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85011017695%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=3cebdce775fa7accc83a9ddfd8b88590},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85011017695{\&}partnerID=40{\&}md5=3cebdce775fa7accc83a9ddfd8b88590},
}

@Article{MENG201871,
  author          = {Meng, Huasong and Thing, Vrizlynn L L and Cheng, Yao and Dai, Zhongmin and Zhang, Li},
  title           = {{A survey of Android exploits in the wild}},
  journal         = {Computers {\&} Security},
  year            = {2018},
  volume          = {76},
  pages           = {71--91},
  issn            = {0167-4048},
  abstract        = {The Android operating system has been dominating the mobile device market in recent years. Although Android has actively strengthened its security mechanisms and fixed a great number of vulnerabilities as its version evolves, new vulnerabilities still keep emerging. Vulnerability exploitation is a common way to achieve privilege escalation on Android systems. In order to provide a holistic and comprehensive understanding of the exploits, we conduct a survey of publicly available 63 exploits for Android devices in this paper. Based on the analysis of the collected real-world exploits, we construct a taxonomy on Android exploitation and present the similarities/differences and strength/weakness of different types of exploits. On the other hand, we conduct an evaluation on a group of selected exploits on our test devices. Based on both the theoretical analysis and the experimental results of the evaluation, we present our insight into the Android exploitation. The growth of exploit categories along the timeline reflects three trends: (1) the individual exploits are more device specific and operating system version specific; (2) exploits targeting vendors' customization grow steadily where the increase of other types of exploits slows down; and (3) memory corruption gradually becomes the primary approach to initiate exploitation.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404818301664},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2018.02.019},
  doi             = {https://doi.org/10.1016/j.cose.2018.02.019},
  keywords        = {Exploit, Mobile security, Privilege escalation, Survey,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404818301664},
}

@InProceedings{ISI:000375991300004,
  author          = {Mendez-Porras, Abel and {Nieto Hidalgo}, Mario and {Manuel Garcia-Chamizo}, Juan and Jenkins, Marcelo and {Martinez Porras}, Alexandra},
  title           = {{A Top-Down Design Approach for an Automated Testing Framework}},
  booktitle       = {UBIQUITOUS COMPUTING AND AMBIENT INTELLIGENCE: SENSING, PROCESSING, AND USING ENVIRONMENTAL INFORMATION},
  year            = {2015},
  editor          = {{GarciaChamizo, JM and Fortino, G and Ochoa, SF}},
  volume          = {9454},
  series          = {Lecture Notes in Computer Science},
  pages           = {37--49},
  abstract        = {Mobile applications have become popular work tools. Portability and ease
of Internet connectivity are characteristics that favor this adoption.
However, mobile applications sometimes incorrectly process events
associated with the user-interaction features. These features include
content presentation or navigation. Rotating the devices, and gestures
such as scroll or zoom into screens are some examples. There is a need
to assess the quality with which mobile applications are processing
these user-interaction features in order to improve their performance.
In this paper, we present a top-down design approach for an automated
testing framework for mobile applications. Our framework integrates
digital image processing, GUI information, and historical bug
information to identify new bugs based on user-interaction features. Our
framework captures images before and after applying the user-interaction
features and uses the SURF algorithm to identify interest points in each
image. We compared interest points to note differences on the screens
before and after applying the user-interaction features. This
differences helps to find bugs in mobile applications. The first results
show that it is feasible to identify bugs with user-interaction features
using the proposed technique.},
  annote          = {9th International Conference on Ubiquitous Computing and Ambient Intelligence (UCAmI), Puerto Varas, CHILE, DEC 01-04, 2015},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-26401-1_4},
  doi             = {10.1007/978-3-319-26401-1_4},
  isbn            = {978-3-319-26401-1; 978-3-319-26400-4},
  issn            = {0302-9743},
}

@Article{MANSAR2012839,
  author          = {Mansar, Selma Limam and Jariwala, Shashank and Shahzad, Maahd and Anggraini, Aysha and Behih, Nawal and AlZeyara, Amna},
  title           = {{A Usability Testing Experiment For A Localized Weight Loss Mobile Application}},
  journal         = {Procedia Technology},
  year            = {2012},
  volume          = {5},
  pages           = {839--848},
  issn            = {2212-0173},
  abstract        = {This paper introduces a context-appropriate mobile application for sustainable weight loss. Overweight and obesity are acknowledged to have become a worldwide health matter. Addressing weight loss and sustaining efforts remains in many ways a fragile undertaking. Strategies will vary by age group, gender, and social context. Moreover, the cultural, traditional ecosystem will impact weight loss strategies. In this paper, we discuss contributions in the literature for technology-based weight loss support. We design a mobile application that leverages three strategies from proven behaviour change theories (increasing awareness of the aims of dieting, fostering motivation and self-efficacy, and impacting dieters' attitudes). We adapt the application to the local context of a middle easterner's society by conducting a usability testing experiment with potential users of the application. We also apply principles of localization to derive an appropriate application. Beyond the applied usage of the application, the paper contributes to the currently scarce body of literature on Arabic based mobile development.},
  annote          = {4th Conference of ENTERprise Information Systems -- aligning technology, organizations and people (CENTERIS 2012)},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S2212017312005245},
  bdsk-url-2      = {https://doi.org/10.1016/j.protcy.2012.09.093},
  doi             = {https://doi.org/10.1016/j.protcy.2012.09.093},
  keywords        = {Middle East, behavior change theories, healthy life style, mobile application, mobile phones localization, mobile phones usability testing,Weight management},
  url             = {http://www.sciencedirect.com/science/article/pii/S2212017312005245},
}

@InProceedings{6895417,
  author          = {Li, A and Qin, Z and Chen, M and Liu, J},
  title           = {{ADAutomation: An Activity Diagram Based Automated GUI Testing Framework for Smartphone Applications}},
  booktitle       = {2014 Eighth International Conference on Software Security and Reliability (SERE)},
  year            = {2014},
  pages           = {68--77},
  abstract        = {Under the increasing complexity and time-to-market pressures, functional validation is becoming a major bottleneck of smartphone applications running on mobile platforms (e.g., Android, iOS). Due to the GUI (Graphical User Interface) intensive nature, the execution of smartphone applications heavily relies on the interactions with users. Manual GUI testing is extremely slow and unacceptably expensive in practice. However, the lack of formal models of user behaviors in the design phase hinders the automation of GUI testing (i.e., test case generation and test evaluation). While thorough test efforts are required to ensure the consistency between user behavior specifications and GUI implementations, few of existing testing approaches can automatically utilize the design phase information to test complex smartphone applications. Based on UML activity diagrams, this paper proposes an automated GUI testing framework called AD Automation, which supports user behavior modeling, GUI test case generation, and post-test analysis and debugging. The experiments using two industrial smartphone applications demonstrate that our approach can not only drastically reduce overall testing time, but also improve the quality of designs.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/SERE.2014.20},
  doi             = {10.1109/SERE.2014.20},
  keywords        = {formal specification;graphical user interfaces;program debugging;program testing;smart phones;Unified Modeling Language;ADAutomation;activity diagram based automated GUI testing framework;smartphone applications;functional validation;mobile platforms;graphical user interface;user behavior specifications;design phase information;UML activity diagrams;user behavior modeling;GUI test case generation;post-test analysis;debugging;Graphical user interfaces;Unified modeling language;Testing;Libraries;Analytical models;Semantics;Androids;GUI Testing;Activity Diagram;Smartphone Applications},
}

@Article{deLimaSalgado2017379,
  author          = {{de Lima Salgado}, A and do Amaral, L and Fortes, R P M and Chagas, M H N and Joyce, G},
  title           = {{Addressing mobile usability and elderly users: Validating contextualized heuristics}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2017},
  volume          = {10288 LNCS},
  pages           = {379--394},
  abstract        = {Diverse heuristic sets were proposed in order to evolve Heuristic Evaluation for new contexts, as contexts related to the elderly and mobile devices. However, heuristics for evaluation of mobile usability regarding elderly users still need aditional validations. For this reason, our study aimed to enhance the validation of a heuristic set proposed by Al-Razgan et al. for evaluation of mobile usability regarding elderly users. Results showed that the major part of heuristics proposed by Al-Razgan et al. matches with traditional heuristics of Nielsen, while a few remain valuable for evaluations in this context. Also, after validations, we found evidences that the heuristics of Al-Razgan et al. have a great coverage of usability problems of mobile applications used by the elderly, as detected from test with users. {\textcopyright} Springer International Publishing AG 2017.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-58634-2_28},
  doi             = {10.1007/978-3-319-58634-2_28},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025114978{\&}doi=10.1007{\%}2F978-3-319-58634-2{\_}28{\&}partnerID=40{\&}md5=45e4899b3c1540196feca6569c118fea},
}

@Conference{Filho2016638,
  author          = {Filho, J F and Prata, W and Oliveira, J},
  title           = {{Affective-ready, contextual and automated usability test for mobile software}},
  booktitle       = {Proceedings of the 18th International Conference on Human-Computer Interaction with Mobile Devices and Services Adjunct, MobileHCI 2016},
  year            = {2016},
  pages           = {638--644},
  abstract        = {This work proposes the use of system to perform affective-ready, contextual and automated usability tests for mobile software. Our proposal augments the traditional methods of software usability evaluation by monitoring users' location, weather conditions, moving/stationary status, data connection availability and spontaneous facial expressions automatically. This aims to identify the moment of negative and positive events. Identifying those situations and systematically associating them to the context of interaction, assisted software creators to overcome design flaws and enhancing interfaces' strengths. The validation of our approach include post-test questionnaires with test subjects. The results indicate that the automated user-context logging can be a substantial supplement to mobile software usability tests.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2957265.2961834},
  doi             = {10.1145/2957265.2961834},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84991101848{\&}doi=10.1145{\%}2F2957265.2961834{\&}partnerID=40{\&}md5=5e9a87881742e7320ee9ff737f6830e9},
}

@InProceedings{Amalfitano:2015:ANS:2804345.2804348,
  author          = {Amalfitano, Domenico and Amatucci, Nicola and Fasolino, Anna Rita and Tramontana, Porfirio},
  title           = {{AGRippin: A Novel Search Based Testing Technique for Android Applications}},
  booktitle       = {Proceedings of the 3rd International Workshop on Software Development Lifecycle for Mobile},
  year            = {2015},
  series          = {DeMobile 2015},
  pages           = {5--12},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Recent studies have shown a remarkable need for testing automation techniques in the context of mobile applications. The main contributions in literature in the field of testing automation regard techniques such as Capture/Replay, Model Based, Model Learning and Random techniques. Unfortunately, only the last two typologies of techniques are applicable if no previous knowledge about the application under testing is available. Random techniques are able to generate effective test suites (in terms of source code coverage) but they need a remarkable effort in terms of machine time and the tests they generate are quite inefficient due to their redundancy. Model Learning techniques generate more efficient test suites but often they do not not reach good levels of coverage. In order to generate test suites that are both effective and efficient, we propose in this paper AGRippin, a novel Search Based Testing technique founded on the combination of genetic and hill climbing techniques. We carried out a case study involving five open source Android applications that has demonstrated how the proposed technique is able to generate test suites that are more effective and efficient than the ones generated by a Model Learning technique.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2804345.2804348},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2804345.2804348},
  doi             = {10.1145/2804345.2804348},
  isbn            = {978-1-4503-3815-8},
  keywords        = {Genetic Algorithms, Search Based Testing,Android},
  url             = {http://doi.acm.org/10.1145/2804345.2804348},
}

@Article{XU2019210,
  author          = {Xu, Yang and Wang, Guojun and Ren, Ju and Zhang, Yaoxue},
  title           = {{An adaptive and configurable protection framework against android privilege escalation threats}},
  journal         = {Future Generation Computer Systems},
  year            = {2019},
  volume          = {92},
  pages           = {210--224},
  issn            = {0167-739X},
  abstract        = {Android is a successful mobile platform with a thriving application ecosystem. However, despite its security precautions like permission mechanism, it is still vulnerable to privilege escalation threats and particularly confused deputy attacks that exploit the permission leak vulnerabilities of Android applications. Worse, most existing detection and protection techniques have become costly and unresponsive in current Android dynamic permission environments. In this paper, we propose a configurable Android security framework to prevent the exploitation of permission leak vulnerabilities of third-party applications via confused deputy attacks. Our framework collects the runtime states of applications and enforces policy and capability-based access control to restrain riskful inter-application communications, so as to provide more responsive, adaptive, and flexible application protection. Besides, our framework provides users with a flexible runtime policy configuration together with a complementary security mechanism to mitigate risks induced by inappropriate policies. Additionally, we present a sophisticated access decision cache system with a proactive maintenance method that ensures the efficiency and dependability of decision services. Theoretical analysis and experimental evaluation demonstrate that our approach provides configurable and effective protections for third-party applications against permission leak vulnerabilities at small performance and usability costs.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X18307775},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2018.09.042},
  doi             = {https://doi.org/10.1016/j.future.2018.09.042},
  keywords        = {Capability-based access control, Configurability, Dynamic permission mechanism, Privilege escalation threat,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X18307775},
}

@InProceedings{7399807,
  author          = {Yang, Tianchang and Cui, Haoliang and Niu, Shaozhang and Zhang, Peng},
  title           = {{An analysis on sensitive data passive leakage in Android applications}},
  booktitle       = {2015 IEEE 16th International Conference on Communication Technology (ICCT)},
  year            = {2015},
  pages           = {125--131},
  abstract        = {Android smartphones store huge amount of sensitive data, and Android provides the Permission Management and the Sandbox Mechanism to protect data. However, it cannot avoid the passive leakage of sensitive data due to the defects introduced during the design and implementation phase. In this paper, we perform a systematic analysis on the passive sensitive data leakage vulnerability in Android applications, design and implement a testing tool Sensitive Data Passive Leakage Detector (DPLDetector). The tool can perform static taint propagation analysis on Android applications, based on the characteristics of the taint propagation paths, and cryptographic misuses analysis or component hijacking analysis is executed selectively. At last, test reports are generated according to the analysis result. Using SDPLDetector to analyze dozens of typical Android applications, the experimental results showed that more than 50{\%} applications were found potential sensitive data passive leakage problems.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICCT.2015.7399807},
  doi             = {10.1109/ICCT.2015.7399807},
  keywords        = {Android (operating system);security of data;smart phones;sensitive data passive leakage analysis;Android;smartphones;permission management;sandbox mechanism;sensitive data passive leakage detector;static taint propagation analysis;cryptographic misuses analysis;component hijacking analysis;Cryptography;Androids;Humanoid robots;Android;Sensitive data;Passive leakage;Taint propagation;Cryptographic misuse},
}

@InProceedings{7880477,
  author          = {Zhu, D and Li, Y and Pang, N and Feng, W},
  title           = {{An Android System Vulnerability Risk Evaluation Method for Heap Overflow}},
  booktitle       = {2016 4th International Conference on Enterprise Systems (ES)},
  year            = {2016},
  pages           = {89--96},
  month           = {nov},
  abstract        = {Android smart device has become a preferred target for attackers as it carries plenty of private and sensitive information. However, heap overflow vulnerability in Android system gives the opportunity to execute arbitrary malicious code and even steal personal privacy. The existence of such vulnerability makes Android system too weak to defense attacks and protect privacy. It's necessary to evaluate the security risk brought to the system. However, current vulnerability risk evaluation methods mainly focus on predicting the likelihood of exploiting, which is not enough and convictive for system security researcher. In this paper, we propose an Android system vulnerability risk evaluation method for heap overflow. We detect whether the heap overflow vulnerability is existent in current Android system, and then validate the exploitability by crafted input data. The evaluation result is classified into three kinds: inexistent, existent but not exploitable, existent and exploitable. Experiment results prove the effectiveness and indicate a good performance of the method.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ES.2016.18},
  doi             = {10.1109/ES.2016.18},
  keywords        = {data protection;mobile computing;risk management;security of data;smart phones;Android system vulnerability risk evaluation;heap overflow vulnerability;Android smart device;malicious code execution;privacy protection;Androids;Humanoid robots;Smart phones;Registers;Security;Buffer overflows;heap overflow;privacy protection;vulnerability risk evaluation;exploitability validation},
}

@Article{Liu2018127,
  author          = {Liu, Y and Zuo, C and Zhang, Z and Guo, S and Xu, X},
  title           = {{An automatically vetting mechanism for SSL error-handling vulnerability in android hybrid Web apps}},
  journal         = {World Wide Web},
  year            = {2018},
  volume          = {21},
  number          = {1},
  pages           = {127--150},
  abstract        = {A large set of diverse hybrid mobile apps, which use both native Android app UIs and Web UIs, are widely available in today's smartphones. These hybrid apps usually use SSL or TLS to secure HTTP based communication. However, researchers show that incorrect implementation of SSL or TLS may lead to serious security problems, such as Man-In-The-Middle (MITM) attacks and phishing attacks. This paper investigates a particular SSL vulnerability that results from error-handling code in the hybrid mobile Web apps. Usually such error-handling code is used to terminate an ongoing communication, but the vulnerability of interest is able to make the communication proceed regardless of SSL certificate verification failures, eventually lead to MITM attacks. To identify those vulnerable apps, we develop a hybrid approach, which combines both static analysis and dynamic analysis to (1) automatically distinguish the native Android UIs and Web UIs, and execute the Web UIs to trigger the error-handling code; (2) accurately select the correct paths from the app entry-point to the targeted code, meanwhile avoiding the crash of apps, and populate messaging objects for the communication between components. Specifically, we construct inter-component call graphs to model the connections, and design algorithms to select the paths from the established graph and determine the parameters by backtracing. To evaluate our approach, we have implemented and tested it with 13,820 real world mobile Web apps from Google Play. The experimental results demonstrate that 1,360 apps are detected as potentially vulnerable ones solely using the static analysis. The dynamic analysis process further confirms that 711 apps are truly vulnerable among the potentially vulnerable set. {\textcopyright} 2017, Springer Science+Business Media New York.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s11280-017-0458-9},
  doi             = {10.1007/s11280-017-0458-9},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85019091936{\&}doi=10.1007{\%}2Fs11280-017-0458-9{\&}partnerID=40{\&}md5=7d3683f8120027e7688e870d65f07b6d},
}

@Article{DZHAGARYAN2016103,
  author          = {Dzhagaryan, Armen and Milenkovi{\'{c}}, Aleksandar and Milosevic, Mladen and Jovanov, Emil},
  title           = {{An environment for automated measurement of energy consumed by mobile and embedded computing devices}},
  journal         = {Measurement},
  year            = {2016},
  volume          = {94},
  pages           = {103--118},
  issn            = {0263-2241},
  abstract        = {Mobile and embedded computing devices have become the dominant type of computing platforms. Energy-efficiency is a key requirement for these devices, underscored by growing reliance of consumers on services delivered through them and their growing complexity and sophistication. A detailed measurement-based characterization of energy consumed by applications running on mobile and embedded computing devices is important for both device manufacturers and application developers, as it may identify energy-demanding components and activities and guide optimizations. In this paper, we describe an environment for automated energy measurements of applications running on Android mobile and bare embedded computing devices. We discuss hardware and software aspects of the environment and several approaches to runtime capturing and timestamping of activities of interest. Finally, we demonstrate the use of the environment in several case studies conducted on two smartphones and a wearable device.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0263224116304407},
  bdsk-url-2      = {https://doi.org/10.1016/j.measurement.2016.07.073},
  doi             = {https://doi.org/10.1016/j.measurement.2016.07.073},
  keywords        = {Computerized instrumentation, Current measurement, Energy measurement, Performance evaluation,Mobile computing},
  url             = {http://www.sciencedirect.com/science/article/pii/S0263224116304407},
}

@Article{KABAKUS201825,
  author          = {Kabakus, Abdullah Talha and Dogru, Ibrahim Alper},
  title           = {{An in-depth analysis of Android malware using hybrid techniques}},
  journal         = {Digital Investigation},
  year            = {2018},
  volume          = {24},
  pages           = {25--33},
  issn            = {1742-2876},
  abstract        = {Android malware is widespread despite the effort provided by Google in order to prevent it from the official application market, Play Store. Two techniques namely static and dynamic analysis are commonly used to detect malicious applications in Android ecosystem. Both of these techniques have their own advantages and disadvantages. In this paper, we propose a novel hybrid Android malware analysis approach namely mad4a which uses the advantages of both static and dynamic analysis techniques. The aim of this study is revealing some unknown characteristics of Android malware through the used various analysis techniques. As the result of static and dynamic analysis on the widely used Android application datasets, digital investigators are informed about some underestimated characteristics of Android malware.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1742287617303183},
  bdsk-url-2      = {https://doi.org/10.1016/j.diin.2018.01.001},
  doi             = {https://doi.org/10.1016/j.diin.2018.01.001},
  keywords        = {Android, Malware analysis, Mobile security, Play store,Android malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S1742287617303183},
}

@Article{Rehn20181,
  author          = {Rehn, A and Holdsworth, J and Hamilton, J and Tee, S},
  title           = {{An input-centric performance model for computational offloading of mobile applications}},
  journal         = {Journal of Systems and Software},
  year            = {2018},
  volume          = {138},
  pages           = {1--18},
  abstract        = {Computational offloading frameworks are a widely-researched technology for optimising mobile applications through the use of cloud resources. Existing frameworks fail to fully account for the effect of input data characteristics on application behaviour. Comprehensive timing models exist in the literature, but feature information requirements and performance overheads that preclude use on mobile devices. In this paper, we propose a conceptual model for an input-centric view of application performance. Our proposed model simplifies the existing count-and-weights and pipeline timing models to significantly reduce their information and processing requirements, facilitating use on resource-constrained mobile devices. Our proposed model also utilises symbolic execution techniques to account for the effects of application input data characteristics. Validation with both synthetic and real device datasets demonstrates that our model provides an extremely accurate approximation of the count-and-weights model. Results demonstrate the predictive power of our model for linear execution paths with no loops or recursion. Further work with improved symbolic execution techniques may look to expand application of our proposed model to real-world use cases. The proposed input-centric approach provides a promising foundation for incorporating a deeper level of application-specific knowledge into computational offloading framework cost models, with the potential to contribute to higher-quality offloading decisions. {\textcopyright} 2017 Elsevier Inc.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1016/j.jss.2017.12.010},
  doi             = {10.1016/j.jss.2017.12.010},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85038911915{\&}doi=10.1016{\%}2Fj.jss.2017.12.010{\&}partnerID=40{\&}md5=0f74c6e6255785e45c0316dcc976ebbc},
}

@Article{SONG201615,
  author          = {Song, Jun and Han, Chunling and Wang, Kaixin and Zhao, Jian and Ranjan, Rajiv and Wang, Lizhe},
  title           = {{An integrated static detection and analysis framework for android}},
  journal         = {Pervasive and Mobile Computing},
  year            = {2016},
  volume          = {32},
  pages           = {15--25},
  issn            = {1574-1192},
  abstract        = {The security and privacy issues of android system have attracted a lot of attention from both industry and academia in recent years. Static detection is one typical method to analyze malicious code. However, existing single static detection method can introduce high false alarm rate and is only appropriate for a limited scope. In this paper, we propose an integrated static detection framework, which consists of four layers of filtering mechanisms, that is, the message digest (MD5) values, the combination of malicious permissions, the dangerous permissions, and the dangerous intention, respectively. An intuitive threat-degree model is proposed especially on dangerous permissions detection. Furthermore, we implement a prototype system ASE and validate its feasibility, performance and scalability. A comprehensive evaluation shows that the proposed framework has obvious advantages especially in efficiency, granularity, layers, and correctness.},
  annote          = {Mobile Security, Privacy and Forensics},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1574119216000420},
  bdsk-url-2      = {https://doi.org/10.1016/j.pmcj.2016.03.003},
  doi             = {https://doi.org/10.1016/j.pmcj.2016.03.003},
  keywords        = {Malware detection, Static detection, Threat degree,Android security},
  url             = {http://www.sciencedirect.com/science/article/pii/S1574119216000420},
}

@Article{Bhatnagar201830,
  author          = {Bhatnagar, S and Malik, Y and Butakov, S},
  title           = {{Analysing data security requirements of android mobile banking application}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2018},
  volume          = {11317 LNCS},
  pages           = {30--37},
  abstract        = {Mobile banking applications are at high risk of cyber attacks due to security vulnerabilities in their application design and underlying operating systems. The Inter-Process Communication mechanism in Android enables applications to communicate, share data and reuse functionality between them. However, if used incorrectly, it can become an attack surface, which allows malicious applications to exploit devices and compromise sensitive financial information. In this research, we focused on addressing the intent vulnerabilities by applying a hybrid fuzzing testing technique to analyze the data security requirements of native Android financial applications. The system first automatically constructs an application behavior model and later apply hybrid fuzzing to the model to analyze the data leak vulnerabilities. Testing results help to discover the unknown exploitable entry points in the applications under test. {\textcopyright} Springer Nature Switzerland AG 2018.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-030-03712-3_3},
  doi             = {10.1007/978-3-030-03712-3_3},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85057862943{\&}doi=10.1007{\%}2F978-3-030-03712-3{\_}3{\&}partnerID=40{\&}md5=3a482e9093e6fe65883e67d7f217262c},
}

@Article{Argyriou2018,
  author          = {Argyriou, M and Dragoni, N and Spognardi, A},
  title           = {{Analysis and Evaluation of SafeDroid v2.0, a Framework for Detecting Malicious Android Applications}},
  journal         = {Security and Communication Networks},
  year            = {2018},
  volume          = {2018},
  abstract        = {Android smartphones have become a vital component of the daily routine of millions of people, running a plethora of applications available in the official and alternative marketplaces. Although there are many security mechanisms to scan and filter malicious applications, malware is still able to reach the devices of many end-users. In this paper, we introduce the SafeDroid v2.0 framework, that is a flexible, robust, and versatile open-source solution for statically analysing Android applications, based on machine learning techniques. The main goal of our work, besides the automated production of fully sufficient prediction and classification models in terms of maximum accuracy scores and minimum negative errors, is to offer an out-of-the-box framework that can be employed by the Android security researchers to efficiently experiment to find effective solutions: the SafeDroid v2.0 framework makes it possible to test many different combinations of machine learning classifiers, with a high degree of freedom and flexibility in the choice of features to consider, such as dataset balance and dataset selection. The framework also provides a server, for generating experiment reports, and an Android application, for the verification of the produced models in real-life scenarios. An extensive campaign of experiments is also presented to show how it is possible to efficiently find competitive solutions: the results of our experiments confirm that SafeDroid v2.0 can reach very good performances, even with highly unbalanced dataset inputs and always with a very limited overhead. {\textcopyright} 2018 Marios Argyriou et al.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1155/2018/4672072},
  doi             = {10.1155/2018/4672072},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85053706618{\&}doi=10.1155{\%}2F2018{\%}2F4672072{\&}partnerID=40{\&}md5=f820a87f4daac718001bd9ae236c4370},
}

@Article{JANG2016125,
  author          = {Jang, Jae-wook and Kang, Hyunjae and Woo, Jiyoung and Mohaisen, Aziz and Kim, Huy Kang},
  title           = {{Andro-Dumpsys: Anti-malware system based on the similarity of malware creator and malware centric information}},
  journal         = {Computers {\&} Security},
  year            = {2016},
  volume          = {58},
  pages           = {125--138},
  issn            = {0167-4048},
  abstract        = {With the fast growth in mobile technologies and the accompanied rise of the integration of such technologies into our everyday life, mobile security is viewed as one of the most prominent areas and is being addressed accordingly. For that, and especially to address the threat associated with malware, various malware-centric analysis methods are developed in the literature to identify, classify, and defend against mobile threats and malicious actors. However, along with this development, anti-malware analysis techniques, such as packing, dynamic loading, and dex encryption, have seen wide adoption, making existing malware-centric analysis methods less effective. In this paper, we propose a feature-rich hybrid anti-malware system, called Andro-Dumpsys, which leverages volatile memory acquisition for accurate malware detection and classification. Andro-Dumpsys is based on similarity matching of malware creator-centric and malware-centric information. Using Andro-Dumpsys, we detect and classify malware samples into similar behavior groups by exploiting their footprints, which are equivalent to unique behavior characteristics. Our experimental results demonstrate that Andro-Dumpsys is scalable, and performs well in detecting malware and classifying malware families with low false positives and false negatives, and is capable of responding zero-day threats.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S016740481600002X},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2015.12.005},
  doi             = {https://doi.org/10.1016/j.cose.2015.12.005},
  keywords        = {Android, Malware creator centric information, Mobile malware, Similarity,Volatile memory acquisition},
  url             = {http://www.sciencedirect.com/science/article/pii/S016740481600002X},
}

@InProceedings{8514216,
  author          = {Kim, H M and Song, H M and Seo, J W and Kim, H K},
  title           = {{Andro-Simnet: Android Malware Family Classification using Social Network Analysis}},
  booktitle       = {2018 16th Annual Conference on Privacy, Security and Trust (PST)},
  year            = {2018},
  pages           = {1--8},
  abstract        = {While the rapid adaptation of mobile devices changes our daily life more conveniently, the threat derived from malware is also increased. There are lots of research to detect malware to protect mobile devices, but most of them adopt only signature-based malware detection method that can be easily bypassed by polymorphic and metamorphic malware. To detect malware and its variants, it is essential to adopt behavior-based detection for efficient malware classification. This paper presents a system that classifies malware by using common behavioral characteristics along with malware families. We measure the similarity between malware families with carefully chosen features commonly appeared in the same family. With the proposed similarity measure, we can classify malware by malware's attack behavior pattern and tactical characteristics. Also, we apply community detection algorithm to increase the modularity within each malware family network aggregation. To maintain high classification accuracy, we propose a process to derive the optimal weights of the selected features in the proposed similarity measure. During this process, we find out which features are significant for representing the similarity between malware samples. Finally, we provide an intuitive graph visualization of malware samples which is helpful to understand the distribution and likeness of the malware networks. In the experiment, the proposed system achieved 97{\%} accuracy for malware classification and 95{\%} accuracy for prediction by K-fold cross-validation using the real malware dataset.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/PST.2018.8514216},
  doi             = {10.1109/PST.2018.8514216},
  keywords        = {Android (operating system);invasive software;mobile computing;pattern classification;social networking (online);metamorphic malware;behavior-based detection;efficient malware classification;malware family network aggregation;malware dataset;signature-based malware detection method;polymorphic malware;Android malware family classification;Andro-Simnet;social network analysis;mobile devices;malwares attack behavior pattern;tactical characteristics;high classification accuracy;graph visualization;k-fold cross-validation;Malware;Feature extraction;Classification algorithms;Detection algorithms;Social network services;Static analysis;Generators;malware similarity;machine learning;malware classification;social network analysis},
}

@Article{FEIZOLLAH2017121,
  author          = {Feizollah, Ali and Anuar, Nor Badrul and Salleh, Rosli and Suarez-Tangil, Guillermo and Furnell, Steven},
  title           = {{AndroDialysis: Analysis of Android Intent Effectiveness in Malware Detection}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {65},
  pages           = {121--134},
  issn            = {0167-4048},
  abstract        = {The wide popularity of Android systems has been accompanied by increase in the number of malware targeting these systems. This is largely due to the open nature of the Android framework that facilitates the incorporation of third-party applications running on top of any Android device. Inter-process communication is one of the most notable features of the Android framework as it allows the reuse of components across process boundaries. This mechanism is used as gateway to access different sensitive services in the Android framework. In the Android platform, this communication system is usually driven by a late runtime binding messaging object known as Intent. In this paper, we evaluate the effectiveness of Android Intents (explicit and implicit) as a distinguishing feature for identifying malicious applications. We show that Intents are semantically rich features that are able to encode the intentions of malware when compared to other well-studied features such as permissions. We also argue that this type of feature is not the ultimate solution. It should be used in conjunction with other known features. We conducted experiments using a dataset containing 7406 applications that comprise 1846 clean and 5560 infected applications. The results show detection rate of 91{\%} using Android Intent against 83{\%} using Android permission. Additionally, experiment on combination of both features results in detection rate of 95.5{\%}.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404816301602},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2016.11.007},
  doi             = {https://doi.org/10.1016/j.cose.2016.11.007},
  keywords        = {Android, Intent, Smartphone security, Static analysis,Mobile malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404816301602},
}

@Article{SOKOLOVA201762,
  author          = {Sokolova, Karina and Perez, Charles and Lemercier, Marc},
  title           = {{Android application classification and anomaly detection with graph-based permission patterns}},
  journal         = {Decision Support Systems},
  year            = {2017},
  volume          = {93},
  pages           = {62--76},
  issn            = {0167-9236},
  abstract        = {Android is one of the mobile market leaders, offering more than a million applications on Google Play store. Google checks the application for known malware, but applications abusively collecting users' data and requiring access to sensitive services not related to functionalities are still present on the market. A permission system is a user-centric security solution against abusive applications and malware that has been unsuccessful: users are incapable of understanding and judging the permissions required by each application and often ignore on-installation warnings. State-of-the-art shows that the current permission system is inappropriate for end-users. However, Android permission lists do provide information about the application's behavior and may be suitable for automatic application analysis. Identifying key permissions for functionalities and expected permission requests can help leverage abnormal application behavior and provide a simpler risk warning for users. Applications with similar functionalities are grouped into categories on Google Play and this work therefore analyzes permission requests by category. In this study, we propose a methodology to characterize normal behavior for each category of applications, highlighting expected permission requests. The co-required permissions are modeled as a graph and the category patterns and central permissions are obtained using graph analysis metrics. The obtained patterns are evaluated by the performance of the application classification into categories that allow choosing the best graph metrics representing categories. Finally, this study proposes a privacy score and a risk warning threshold based on the best metrics. The efficiency of the proposed methodology was tested on a set of 9512 applications collected from Google Play and a set of malware.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167923616301555},
  bdsk-url-2      = {https://doi.org/10.1016/j.dss.2016.09.006},
  doi             = {https://doi.org/10.1016/j.dss.2016.09.006},
  keywords        = {Anomaly detection, Classification, Graph analysis, Permission patterns, Risk warning,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167923616301555},
}

@Article{SHEEN2015905,
  author          = {Sheen, Shina and Anitha, R and Natarajan, V},
  title           = {{Android based malware detection using a multifeature collaborative decision fusion approach}},
  journal         = {Neurocomputing},
  year            = {2015},
  volume          = {151},
  pages           = {905--912},
  issn            = {0925-2312},
  abstract        = {Smart mobile device usage has expanded at a very high rate all over the world. Since the mobile devices nowadays are used for a wide variety of application areas like personal communication, data storage and entertainment, security threats emerge, comparable to those which a conventional PC is exposed to. Mobile malware has been growing in scale and complexity as smartphone usage continues to rise. Android has surpassed other mobile platforms as the most popular whilst also witnessing a dramatic increase in malware targeting the platform. In this work, we have considered Android based malware for analysis and a scalable detection mechanism is designed using multifeature collaborative decision fusion (MCDF). The different features of a malicious file like the permission based features and the API call based features are considered in order to provide a better detection by training an ensemble of classifiers and combining their decisions using collaborative approach based on probability theory. The performance of the proposed model is evaluated on a collection of Android based malware comprising of different malware families and the results show that our approach give a better performance than state-of-the-art ensemble schemes available.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0925231214012739},
  bdsk-url-2      = {https://doi.org/10.1016/j.neucom.2014.10.004},
  doi             = {https://doi.org/10.1016/j.neucom.2014.10.004},
  keywords        = {Collaborative decision fusion, Malware, Multifeature,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0925231214012739},
}

@Article{GROVER2013S12,
  author          = {Grover, Justin},
  title           = {{Android forensics: Automated data collection and reporting from a mobile device}},
  journal         = {Digital Investigation},
  year            = {2013},
  volume          = {10},
  pages           = {S12 -- S20},
  issn            = {1742-2876},
  abstract        = {In this research, a prototype enterprise monitoring system for Android smartphones was developed to continuously collect many data sets of interest to incident responders, security auditors, proactive security monitors, and forensic investigators. Many of the data sets covered were not found in other available enterprise monitoring tools. The prototype system neither requires root privileges nor the exploiting of the Android architecture for proper operation, thereby increasing interoperability among Android devices and avoiding a spyware classification for the system. An anti-forensics analysis on the system was performed to identify and further strengthen areas vulnerable to tampering. The contributions of this research include the release of the first open-source Android enterprise monitoring solution of its kind, a comprehensive guide of data sets available for collection without elevated privileges, and the introduction of a novel design strategy implementing various Android application components useful for monitoring on the Android platform.},
  annote          = {The Proceedings of the Thirteenth Annual DFRWS Conference},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1742287613000480},
  bdsk-url-2      = {https://doi.org/10.1016/j.diin.2013.06.002},
  doi             = {https://doi.org/10.1016/j.diin.2013.06.002},
  keywords        = {Enterprise user monitoring, Insider threat, Internal investigation, Mobile device,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S1742287613000480},
}

@Article{BHANDARI2017392,
  author          = {Bhandari, Shweta and Jaballah, Wafa Ben and Jain, Vineeta and Laxmi, Vijay and Zemmari, Akka and Gaur, Manoj Singh and Mosbah, Mohamed and Conti, Mauro},
  title           = {{Android inter-app communication threats and detection techniques}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {70},
  pages           = {392--421},
  issn            = {0167-4048},
  abstract        = {With the digital breakthrough, smart phones have become very essential component for many routine tasks like shopping, paying bills, transferring money, instant messaging, emails etc. Mobile devices are very attractive attack surface for cyber thieves as they hold personal details (accounts, locations, contacts, photos) and have potential capabilities for eavesdropping (with cameras/microphone, wireless connections). Android, being the most popular, is the target of malicious hackers who are trying to use Android app as a tool to break into and control device. Android malware authors use many anti-analysis techniques to hide from analysis tools. Academic researchers and commercial anti-malware companies are putting great effort to detect such malicious apps. They are making use of the combinations of static, dynamic and behavior-based analysis techniques. Despite of all the security mechanisms provided by Android, apps can carry out malicious actions through inter-app communication. One such inter-app communication threats is collusion. In collusion, malicious functionality is divided across multiple apps. Each participating app accomplishes its part and communicate information to another app through Inter Component Communication (ICC). ICC does not require any special permissions. Also there is no compulsion to inform user about the communication. Each participating app needs to request a minimal set of privileges, which may make it appear benign to current state-of-the-art techniques that analyze one app at a time. There are many surveys on app analysis techniques in Android; however they focus on single-app analysis. This survey highlights several inter-app communication threats, in particular collusion among multiple-apps. In this paper, we present Android vulnerabilities that may be exploited for carrying privilege escalation attacks, privacy leakage and collusion attacks. We cover the existing threat analysis, scenarios, and a detailed comparison of tools for intra- and inter-app analysis. To the best of our knowledge this is the first survey on inter-app communication threats, app collusion and state-of-the-art detection tools in Android.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404817301414},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2017.07.002},
  doi             = {https://doi.org/10.1016/j.cose.2017.07.002},
  keywords        = {Inter component communication, Inter-app communication, Multi-app analysis, Privacy leakage,App collusion},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404817301414},
}

@Article{Aminordin20186853,
  author          = {Aminordin, A and Faizal, M A and Yusof, R},
  title           = {{Android malware classification base on application category using static code analysis}},
  journal         = {Journal of Theoretical and Applied Information Technology},
  year            = {2018},
  volume          = {96},
  number          = {20},
  pages           = {6853--6863},
  abstract        = {The great shipment of Android mobile devices throughout the world has surged the application development. Indirectly, this scenario had invited the malware creator to be in-line with the technology evolution. One of the threats is the leakage of privacy data and it is a serious subject. To overcome this, the Android application usually being examine through static or dynamic analysis. In static analysis approach, researcher commonly considered combination static features to identify the benign and malicious application. This paper presents a proof of concept on classifying Android benign and malicious apps by its application category. At the same time, this paper proposes a new framework for malicious detection focusing on the leakage of user privacy using minimum number of the request permissions and API calls features. Several machine learning classifiers with several training and testing percentage applied in this study to compare the accuracy. The result show that, applications in same category reported more accurate performance in identify malicious apps compared to non-category based. By applying features ranking and information gain features selection, Random forest classifier with 10 folds cross validation for both ``Book and Reference'' and ``Personalization'' category achieved higher true positive rate also lower false positive rate. {\textcopyright} 2005 -- ongoing JATIT {\&} LLS.},
  annote          = {cited By 0},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056244438%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=c1302ea991d2a746a3433ae68a939971},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056244438{\&}partnerID=40{\&}md5=c1302ea991d2a746a3433ae68a939971},
}

@Article{MARTIN2018,
  author          = {Mart{\'{i}}n, Alejandro and Lara-Cabrera, Ra{\'{u}}l and Camacho, David},
  title           = {{Android malware detection through hybrid features fusion and ensemble classifiers: the AndroPyTool framework and the OmniDroid dataset}},
  journal         = {Information Fusion},
  year            = {2018},
  issn            = {1566-2535},
  abstract        = {Cybersecurity has become a major concern for society, mainly motivated by the increasing number of cyber attacks and the wide range of targeted objectives. Due to the popularity of smartphones and tablets, Android devices are considered an entry point in many attack vectors. Malware applications are among the most used tactics and tools to perpetrate a cyber attack, so it is critical to study new ways of detecting them. In these detection mechanisms, machine learning has been used to build classifiers that are effective in discerning if an application is malware or benignware. However, training such classifiers require big amounts of labelled data which, in this context, consist of categorised malware and benignware Android applications represented by a set of features able to describe their behaviour. For that purpose, in this paper we present OmniDroid, a large and comprehensive dataset of features extracted from 22,000 real malware and goodware samples, aiming to help anti-malware tools creators and researchers when improving, or developing, new mechanisms and tools for Android malware detection. Furthermore, the characteristics of the dataset make it suitable to be used as a benchmark dataset to test classification and clustering algorithms or new representation techniques, among others. The dataset has been released under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License and was built using AndroPyTool, our automated framework for dynamic and static analysis of Android applications. Finally, we test a set of ensemble classifiers over this dataset and propose a malware detection approach based on the fusion of static and dynamic features through the combination of ensemble classifiers. The experimental results show the feasibility and potential usability (for the machine learning, soft computing and cyber security communities) of our automated framework and the publicly available dataset.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1566253518306778},
  bdsk-url-2      = {https://doi.org/10.1016/j.inffus.2018.12.006},
  doi             = {https://doi.org/10.1016/j.inffus.2018.12.006},
  keywords        = {Android, Hybrid features fusion, Malware dataset,Malware analysis},
  url             = {http://www.sciencedirect.com/science/article/pii/S1566253518306778},
}

@Article{PAPADOPOULOS20183,
  author          = {Papadopoulos, Harris and Georgiou, Nestoras and Eliades, Charalambos and Konstantinidis, Andreas},
  title           = {{Android malware detection with unbiased confidence guarantees}},
  journal         = {Neurocomputing},
  year            = {2018},
  volume          = {280},
  pages           = {3--12},
  issn            = {0925-2312},
  abstract        = {The impressive growth of smartphone devices in combination with the rising ubiquity of using mobile platforms for sensitive applications such as Internet banking, have triggered a rapid increase in mobile malware. In recent literature, many studies examine Machine Learning techniques, as the most promising approach for mobile malware detection, without however quantifying the uncertainty involved in their detections. In this paper, we address this problem by proposing a machine learning dynamic analysis approach that provides provably valid confidence guarantees in each malware detection. Moreover the particular guarantees hold for both the malicious and benign classes independently and are unaffected by any bias in the data. The proposed approach is based on a novel machine learning framework, called Conformal Prediction, combined with a random forests classifier. We examine its performance on a large-scale dataset collected by installing 1866 malicious and 4816 benign applications on a real android device. We make this collection of dynamic analysis data available to the research community. The obtained experimental results demonstrate the empirical validity, usefulness and unbiased nature of the outputs produced by the proposed approach.},
  annote          = {Applications of Neural Modeling in the new era for data and IT},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0925231217317678},
  bdsk-url-2      = {https://doi.org/10.1016/j.neucom.2017.08.072},
  doi             = {https://doi.org/10.1016/j.neucom.2017.08.072},
  keywords        = {Android, Class imbalance, Confidence guarantees, Confidence measures, Conformal Prediction, Random forests, Security, Unbiased predictions,Malware detection},
  url             = {http://www.sciencedirect.com/science/article/pii/S0925231217317678},
}

@Article{Smith2016183,
  author          = {Smith, E and Coglio, A},
  title           = {{Android platform modeling and android app verification in the ACL2 theorem prover}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2016},
  volume          = {9593},
  pages           = {183--201},
  abstract        = {We present our work in using the ACL2 theorem prover to formally model the Android platform and to formally verify Android apps. Our approach allows the verification of the full functional correctness of apps as well as security properties. It also lets us detect or prove the absence of ``functional malware'', malicious app functionality that is triggered by complex conditions on state and that causes the app to calculate the wrong results or otherwise behave incorrectly. Our formal Android model is an executable simulator of a growing subset of the Android platform, and app proofs are done by automated symbolic execution of the app's event handlers using the formal model. By induction, we prove that an app satisfies an invariant, including the correctness properties of interest, for all possible sequences of events. {\textcopyright} Springer International Publishing Switzerland 2016.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-29613-5_11},
  doi             = {10.1007/978-3-319-29613-5_11},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84959018018{\&}doi=10.1007{\%}2F978-3-319-29613-5{\_}11{\&}partnerID=40{\&}md5=208df72c78de5f0f146672d49c8e7ef2},
}

@Article{RASHIDI201790,
  author          = {Rashidi, Bahman and Fung, Carol and Bertino, Elisa},
  title           = {{Android resource usage risk assessment using hidden Markov model and online learning}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {65},
  pages           = {90--107},
  issn            = {0167-4048},
  abstract        = {With Android devices users are allowed to install third-party applications from various open markets. This raises security and privacy concerns since the third-party applications may be malicious. Unfortunately, the increasing sophistication and diversity of the malicious Android applications render the conventional defenses techniques ineffective, which results in a large number of malicious applications to remain undetected. In this paper we present XDroid, an Android application and resource risk assessment framework based on the Hidden Markov Model (HMM). In our approach, we first map the applications' behaviors into an observation set, and we attach timestamps to some observations in the set. We show that our novel use of temporal behavior tracking can significantly improve the malware detection accuracy, and that the HMM can generate security alerts when suspicious behaviors are detected. Furthermore, we introduce an online learning model to integrate the input from users and provide adaptive risk assessment. We evaluate our model through a set of experiments on the DREBIN benchmark malware dataset. Our evaluation results demonstrate that the proposed model can accurately assess the risk levels of malicious applications and provide adaptive risk assessment based on user input.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404816301596},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2016.11.006},
  doi             = {https://doi.org/10.1016/j.cose.2016.11.006},
  keywords        = {App behavior, Permission, Privacy, Risk computation,Smartphone},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404816301596},
}

@Article{LIU2018402,
  author          = {Liu, Xing and Liu, Jiqiang and Wang, Wei and Zhu, Sencun},
  title           = {{Android single sign-on security: Issues, taxonomy and directions}},
  journal         = {Future Generation Computer Systems},
  year            = {2018},
  volume          = {89},
  pages           = {402--420},
  issn            = {0167-739X},
  abstract        = {Single Sign-On (SSO) is a mechanism that allows a user to log in to other applications using his identity registered with an identity provider. One of the most popular protocols for SSO is OAuth 2.0, which is an open standard for authorization. However, due to the lack of detailed instructions on how to implement OAuth 2.0 on Android, there are many vulnerabilities in the current Android OAuth 2.0 implementations. While much research effort has been made to exploit such vulnerabilities, there is a lack of systematical collation and summary of these researches, resulting in the appearance of common vulnerabilities in new applications. Hence, it is crucial to collate and summarize related work. Meanwhile, the rapid development of the Internet of Things (IoT) also requires an understanding of the usage of OAuth 2.0 in the IoT environment. In this work, we first describe the OAuth 2.0 authorization code grant flow and the implicit grant flow in detail and summarize the differences between the Web environment and the Android environment that affect OAuth 2.0 security. Then, we summarize the security issues in the implementations of OAuth 2.0 on Android. These security issues include: storing client{\_}secret or access token locally, using embedded WebView as user-agent, incorrect usage of authentication proof, handling redirection in mobile app improperly, lacking transmission protection and third-party app authentication. Attacks on these vulnerabilities, such as WebView hijacking, linking hijacking and phishing, as well as attack results are elaborated subsequently. Against these security issues and attacks, we summarize the related research work in terms of vulnerability analysis, defense, and protocol analysis. At last, we discuss the directions for mitigating these security issues and discuss some OAuth-based protocols for the IoT environment.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X18302358},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2018.06.049},
  doi             = {https://doi.org/10.1016/j.future.2018.06.049},
  keywords        = {OAuth-based SSO, Privacy, Security,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X18302358},
}

@Article{Zhang2018239,
  author          = {Zhang, P and Cheng, K and Gao, J},
  title           = {{Android-SRV: Scenario-Based Runtime Verification of Android Applications}},
  journal         = {International Journal of Software Engineering and Knowledge Engineering},
  year            = {2018},
  volume          = {28},
  number          = {2},
  pages           = {239--257},
  abstract        = {With the wide-spread usage of Android systems, Android applications have become the target of mobile malwares. Therefore, an effective verification approach for Android applications is essential. Runtime verification based on monitors is one of the most promising techniques to check the software's behaviors. Currently, there are a number of monitoring approaches for Android applications. However, these approaches mainly have two limitations. First, there is no effective mechanism to reduce the load on Android applications caused by monitors. Second, these approaches mainly rely on logic-based specifications, which are complex and not intuitive for being used in practice. In order to address these two limitations, this paper proposes a scenario-based runtime verification approach for Android applications (called Android-SRV). The approach concentrates on providing a dynamic and usable solution for monitoring applications during execution with the help of aspect-oriented programming. It will translate the scenario-based specification (called property sequence charts (PSCs)) into multi-valued automata (MAs), and then generate AspectJ codes from the MA. Finally, these AspectJ codes are weaved into the target system as monitors. Considering the impact of the monitors on performance load in the Android system, the paper proposes local and cloud collaboration mechanisms to reduce the impact. The scenario-based specification is more intuitive than the traditional logic-based specifications. The approach is shown to be an effective means for monitoring Android applications with controlled overload. {\textcopyright} 2018 World Scientific Publishing Company.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1142/S0218194018500080},
  doi             = {10.1142/S0218194018500080},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85043288780{\&}doi=10.1142{\%}2FS0218194018500080{\&}partnerID=40{\&}md5=1dedd7a6c28a4a81f9fd5d09c506951c},
}

@Article{FARUKI201566,
  author          = {Faruki, Parvez and Laxmi, Vijay and Bharmal, Ammar and Gaur, M S and Ganmoor, Vijay},
  title           = {{AndroSimilar: Robust signature for detecting variants of Android malware}},
  journal         = {Journal of Information Security and Applications},
  year            = {2015},
  volume          = {22},
  pages           = {66--80},
  issn            = {2214-2126},
  abstract        = {Android Smartphone popularity has increased malware threats forcing security researchers and AntiVirus (AV) industry to carve out smart methods to defend Smartphone against malicious apps. Robust signature based solutions to mitigate threats become necessary to protect the Smartphone and confidential user data. Here we present AndroSimilar, an approach which generates signatures by extracting statistically robust features, to detect malicious Android apps. Proposed method is effective against code obfuscation and repackaging, widely used techniques to propagate unseen variants of known malware by evading AV signatures. AndroSimilar is a syntactic foot-printing mechanism that finds regions of statistical similarity with known malware to detect those unknown, zero day samples. We also show that syntactic similarity considering whole app, rather than just embedded DEX file is more effective, contrary to known fuzzy hashing approach. We also apply clustering algorithm to identify small set of family signatures to reduce overall signature database size. Proposed approach can be refined to deploy as Smartphone AV.},
  annote          = {Special Issue on Security of Information and Networks},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S2214212614001471},
  bdsk-url-2      = {https://doi.org/10.1016/j.jisa.2014.10.011},
  doi             = {https://doi.org/10.1016/j.jisa.2014.10.011},
  keywords        = {Code obfuscation, Similarity digest, Statistical features,Android malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S2214212614001471},
}

@InProceedings{7976989,
  author          = {Shankar, V G and Somani, G and Gaur, M S and Laxmi, V and Conti, M},
  title           = {{AndroTaint: An efficient android malware detection framework using dynamic taint analysis}},
  booktitle       = {2017 ISEA Asia Security and Privacy (ISEASP)},
  year            = {2017},
  pages           = {1--13},
  abstract        = {Android operating system is widespread in today's smart-phone market due to its open source model, its easy functionality and huge number of Apps and App-Stores (the official and others). The coverage of some 90{\%} of the market, it is also the place-holder for user's personal as well as sensitive information (IMEI, IMSI, etc.). There is a tendency of Apps user to trust on Android OS for securing his/her data but it has been proved that Android OS is more vulnerable to exploitation either for fun or for monetary purpose. Malware detection for Android OS has become an upcoming research problem of interest. Dynamic Taint Analysis is an efficient analysis in existing Android malware detection analysis. The aim of this paper is to work towards Dynamic Taint Analysis of Android malware using automatic tagging and with out modification in Android platform. In order to do this, this paper surveys exhaustively the available literature and works related to dynamic taint analysis. This paper proposes some novel ideas to improve the existing solution with more accuracy. There are two phases of our novel algorithm, the first phase is training phase for feature extraction and the second phase is the analysis phase for automatic tagging and tainting. We have developed a framework named AndroTaint, which is working on Dynamic Taint Analysis. AndroTaint follows a novel supervised and unsupervised Anomaly Detection technique with high precision, recall and harmonic mean. Our Dynamic Taint Analysis algorithm categorizes the App is risky, benign, malicious or aggressive as per their feature and behaviour. We have measured AndroTaint effectiveness on the basis of timeline for building dataset and 10-fold cross validation. AndroTaint covers 90{\%} of malware and benign in analysis phase with less false positive and false negative.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ISEASP.2017.7976989},
  doi             = {10.1109/ISEASP.2017.7976989},
  keywords        = {Android (operating system);feature extraction;invasive software;Android malware detection framework;dynamic taint analysis;automatic tagging;feature extraction;AndroTaint;Android OS;operating system;unsupervised anomaly detection technique;supervised anomaly detection technique;Androids;Humanoid robots;Malware;Operating systems;Tools;Payloads;Tagging;Android;Taint Analysis;Smart-phone security;Malware analysis;Malware detection;Android Malware;Dynamic Taint Analysis},
}

@Article{SHANKAR2016587,
  author          = {Shankar, Venkatesh Gauri and Somani, Gaurav},
  title           = {{Anti-Hijack: Runtime Detection of Malware Initiated Hijacking in Android}},
  journal         = {Procedia Computer Science},
  year            = {2016},
  volume          = {78},
  pages           = {587--594},
  issn            = {1877-0509},
  abstract        = {According to studies, Android is having the highest market share in smartphone operating systems. The number of Android apps (i.e. applications) are increasing day by day. Consequent threats and attacks on Android are also rising. There are a large number of apps which bypass users by hiding their functionalities and send users sensitive information and data across the network. Due to flexibility and openness of Android operating system, attack surfaces are being introduced every other day. In this paper, we are addressing detection of two fatal malware attacks; intent based hijacking and authenticated session hijacking. We have used the concept of honey-pot in detection of these two authentication hijacking problems. In order to achieve this, we have tested various apps and their interaction with the honey-pot maintained by real device or an emulator. We have designed benign app as a honey framed app. We argue that hijacking malware can be detected with higher accuracy using our method at run-time as compared to the traditional machine learning methods. Our approach, Anti-Hijack, which has provided the detection accuracy as high as 96{\%}. This has been highly accurate to detect the unwanted interaction between hijacking malware and designed benign app. We have tested our approach on a strong data-set of Android apps for experiment and identifying vulnerable points. Our detection method Anti-Hijack is a novel contribution in this area which provides light weight, device operated run-time detection at hijacking malware.},
  annote          = {1st International Conference on Information Security {\&} Privacy 2015},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1877050916001071},
  bdsk-url-2      = {https://doi.org/10.1016/j.procs.2016.02.105},
  doi             = {https://doi.org/10.1016/j.procs.2016.02.105},
  keywords        = {Anti-Hijack, honey-pot, intent, security, smartphone, vulnerabilities,Android malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S1877050916001071},
}

@Article{TALHA20151,
  author          = {Talha, Kabakus Abdullah and Alper, Dogru Ibrahim and Aydin, Cetin},
  title           = {{APK Auditor: Permission-based Android malware detection system}},
  journal         = {Digital Investigation},
  year            = {2015},
  volume          = {13},
  pages           = {1--14},
  issn            = {1742-2876},
  abstract        = {Android operating system has the highest market share in 2014; making it the most widely used mobile operating system in the world. This fact makes Android users the biggest target group for malware developers. Trend analyses show large increase in mobile malware targeting the Android platform. Android's security mechanism is based on an instrument that informs users about which permissions the application needs to be granted before installing them. This permission system provides an overview of the application and may help gain awareness about the risks. However, we do not have enough information to conclude that standard users read or digital investigators understand these permissions and their implications. Digital investigators need to be on the alert for the presence of malware when examining Android devices, and can benefit from supporting tools that help them understand the capabilities of such malicious code. This paper presents a permission-based Android malware detection system, APK Auditor that uses static analysis to characterize and classify Android applications as benign or malicious. APK Auditor consists of three components: (1) A signature database to store extracted information about applications and analysis results, (2) an Android client which is used by end-users to grant application analysis requests, and (3) a central server responsible for communicating with both signature database and smartphone client and managing whole analysis process. To test system performance, 8762 applications in total, 1853 benign applications from Google's Play Store and 6909 malicious applications from different sources were collected and analyzed by the system developed. The results show that APK Auditor is able to detect most well-known malwares and highlights the ones with a potential in approximately 88{\%} accuracy with a 0.925 specificity.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S174228761500002X},
  bdsk-url-2      = {https://doi.org/10.1016/j.diin.2015.01.001},
  doi             = {https://doi.org/10.1016/j.diin.2015.01.001},
  keywords        = {Malware, Mobile security, Smartphone, Static analysis,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S174228761500002X},
}

@Conference{Wu2017253,
  author          = {Wu, G and Cao, Y and Chen, W and Wei, J and Zhong, H and Huang, T},
  title           = {{AppCheck: A Crowdsourced Testing Service for Android Applications}},
  booktitle       = {Proceedings - 2017 IEEE 24th International Conference on Web Services, ICWS 2017},
  year            = {2017},
  pages           = {253--260},
  abstract        = {It is well known that the fragmentation of Android ecosystem has caused severe compatibility issues. Therefore, for Android apps, cross-platform testing (the apps must be tested on a multitude of devices and operating system versions) is particularly important to assure their quality. Although lots of cross-platform testing techniques have been proposed, there are still some limitations: 1) it is time-consuming and error-prone to encode platform-agnostic tests manually, 2) test scripts generated by existing record/replay techniques are brittle and will break when replayed on different platforms, 3) Developers, and even test vendors have not equipped some special Android devices. As a result, apps have not been tested sufficiently, leading to many compatibility issues after releasing. To address these limitations, this paper proposes AppCheck, a crowdsourced testing service for Android apps. To generate tests that will explore different behavior of the app automatically, AppCheck crowdsources event trace collection over the Internet, and various touch events will be captured when real users interact with the app. The collected event traces are then transformed into platform-agnostic test scripts, and directly replayed on the devices of real users. During the replay, various data (e.g., screenshots and layout information) will be extracted to identify compatibility issues. Our empirical evaluation shows that AppCheck is effective and improves the state of the art. {\textcopyright} 2017 IEEE.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICWS.2017.40},
  doi             = {10.1109/ICWS.2017.40},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85032348865{\&}doi=10.1109{\%}2FICWS.2017.40{\&}partnerID=40{\&}md5=c976429bb6af397e7c6c24a7facf6edc},
}

@InProceedings{5954462,
  author          = {Krishnan, P and Hafner, S and Zeiser, A},
  title           = {{Applying Security Assurance Techniques to a Mobile Phone Application: An Initial Approach}},
  booktitle       = {2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops},
  year            = {2011},
  pages           = {545--552},
  abstract        = {As users download applications to their mobile phones, security is a critical issue. In this paper we present a process for the security assurance of applications. It uses existing vulnerability databases and application development guidelines to identify potential security issues. The identified issues are then validated using a variety of techniques including black-box testing, unit testing code inspection and static analysis. This process is illustrated using an application for the Android platform.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICSTW.2011.10},
  doi             = {10.1109/ICSTW.2011.10},
  keywords        = {database management systems;mobile computing;mobile radio;operating systems (computers);program diagnostics;program testing;telecommunication security;security assurance techniques;mobile phone application;vulnerability databases;application development guidelines;security issues;black-box testing;unit testing code inspection;static analysis;Android platform;Security;Guidelines;Testing;Androids;Mobile handsets;Databases;Humanoid robots;Android;Assurance;Security;QA process},
}

@Article{Salva2015201,
  author          = {Salva, S and Zafimiharisoa, S R},
  title           = {{APSET, an Android aPplication SEcurity Testing tool for detecting intent-based vulnerabilities}},
  journal         = {International Journal on Software Tools for Technology Transfer},
  year            = {2015},
  volume          = {17},
  number          = {2},
  pages           = {201--221},
  abstract        = {The Android messaging system, called intent, is a mechanism that ties components together to build applications for smartphones. Intents are kinds of messages composed of actions and data, sent by a component to another component to perform several operations, e.g. launching a user interface. The intent mechanism offers a lot of flexibility for developing Android applications, but it might also be used as an entry point for security attacks. The latter can be easily sent with intents to components, that can indirectly forward attacks to other components and so on. In this context, this paper proposes APSET, a tool for Android aPplication SEcurity Testing, which aims at detecting intent-based vulnerabilities. It takes as inputs Android applications and intent-based vulnerabilities formally expressed with models called vulnerability patterns. Then, and this is the originality of our approach, class diagrams and partial specifications are automatically generated from applications with algorithms reflecting some knowledge of the Android documentation. These partial specifications avoid false positives and refine the test result with special verdicts notifying that a component is not compliant to its specification. Furthermore, we propose a test case execution framework which supports the receipt of any exception, the detection of application crashes, and provides a final XML test report detailing the test case verdicts. The vulnerability detection effectiveness of APSET is evaluated with experimentations on randomly chosen Android applications of the Android Market. {\textcopyright} 2014, Springer-Verlag Berlin Heidelberg.},
  annote          = {cited By 6},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s10009-014-0303-8},
  doi             = {10.1007/s10009-014-0303-8},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84924852367{\&}doi=10.1007{\%}2Fs10009-014-0303-8{\&}partnerID=40{\&}md5=0d2dd45161c18f9d4fe2c05f6f3908cb},
}

@Article{Zhang2013147,
  author          = {Zhang, Q and Li, X and Yu, X and Feng, Z},
  title           = {{ASF: Improving android security with layered structure instrumentation}},
  journal         = {Communications in Computer and Information Science},
  year            = {2013},
  volume          = {332},
  pages           = {147--157},
  abstract        = {Due to the third-party applications that provide Smartphone users with functional extensions, more and more privacy leak events occur. While the existing security mechanism informs the user of the resources the application requires, it does not involve the usage of sensitive privacies. This paper presents Android Security Framework (ASF): a security framework for Android that guarantees the security of user privacy. In the framework layer, ASF is integrated for monitoring the operations that third-party applications perform on user privacies, and in the application layer, detectors inspect the safety of these operations based on ASF. Our security framework is implemented through layered structure, with minimal change to the existing Android code. A case study is presented as a preliminary validation of the security framework that helps users protect privacies. {\textcopyright} 2012 Springer-Verlag Berlin Heidelberg.},
  annote          = {cited By 0},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84879196786%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=f847ea4d3e60ff26580e82990d748758},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84879196786{\&}partnerID=40{\&}md5=f847ea4d3e60ff26580e82990d748758},
}

@Article{GUIDO2013S96,
  author          = {Guido, Mark and Ondricek, Jared and Grover, Justin and Wilburn, David and Nguyen, Thanh and Hunt, Andrew},
  title           = {{Automated identification of installed malicious Android applications}},
  journal         = {Digital Investigation},
  year            = {2013},
  volume          = {10},
  pages           = {S96 -- S104},
  issn            = {1742-2876},
  abstract        = {Increasingly, Android smartphones are becoming more pervasive within the government and industry, despite the limited ways to detect malicious applications installed to these phones' operating systems. Although enterprise security mechanisms are being developed for use on Android devices, these methods cannot detect previously unknown malicious applications. As more sensitive enterprise information becomes available and accessible on these smartphones, the risk of data loss inherently increases. A malicious application's actions could potentially leave sensitive data exposed with little recourse. Without an effective corporate monitoring solution in place for these mobile devices, organizations will continue to lack the ability to determine when a compromise has occurred. This paper presents research that applies traditional digital forensic techniques to remotely monitor and audit Android smartphones. The smartphone sends changed file system data to a remote server, allowing for expensive forensic processing and the offline application of traditional tools and techniques rarely applied to the mobile environment. The research aims at ascertaining new ways of identifying malicious Android applications and ultimately attempts to improve the state of enterprise smartphone monitoring. An on-phone client, server, database, and analysis framework was developed and tested using real mobile malware. The results are promising that the developed detection techniques identify changes to important system partitions; recognize file system changes, including file deletions; and find persistence and triggering mechanisms in newly installed applications. It is believed that these detection techniques should be performed by enterprises to identify malicious applications affecting their phone infrastructure.},
  annote          = {The Proceedings of the Thirteenth Annual DFRWS Conference},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1742287613000571},
  bdsk-url-2      = {https://doi.org/10.1016/j.diin.2013.06.011},
  doi             = {https://doi.org/10.1016/j.diin.2013.06.011},
  keywords        = {Enterprise, Mobile forensics, Monitoring, Periodic,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S1742287613000571},
}

@InProceedings{Coppola:2016:AMU:2945404.2945406,
  author          = {Coppola, Riccardo and Raffero, Emanuele and Torchiano, Marco},
  title           = {{Automated Mobile UI Test Fragility: An Exploratory Assessment Study on Android}},
  booktitle       = {Proceedings of the 2Nd International Workshop on User Interface Test Automation},
  year            = {2016},
  series          = {INTUITEST 2016},
  pages           = {11--20},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Automated UI testing suffers from fragility due to continuous -although minor- changes in the UI of applications. Such fragility has been shown especially for the web domain, though no clear evidence is available for mobile applications. Our goal is to perform an exploratory assessment of the extent and causes of the fragiliy of UI automated tests for mobile applications. For this purpose, we analyzed a small test suite -that we developed using five different testing frameworks for an Android application (K-9 Mail) and observed the changes induced in the tests by the evolution of the UI. We found that up to 75% of code-based tests, and up to 100% of image recognition tests, had to be adapted because of the changes induced by the evolution of the application between two different versions. In addition we identified the main causes of such fragility: changes of identifiers, text or graphics, removal or relocation of elements, activity flow variation, execution time variation, and usage of physical buttons. The preliminary assessment showed that the fragility of UI tests can be a relevant issue also for mobile applications. A few common causes were found that can be used as the basis for providing guidelines for fragility avoidance and repair.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2945404.2945406},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2945404.2945406},
  doi             = {10.1145/2945404.2945406},
  isbn            = {978-1-4503-4412-8},
  keywords        = {Empirical, Fragility, Test, UI,Automated},
  url             = {http://doi.acm.org/10.1145/2945404.2945406},
}

@InProceedings{ISI:000390237000026,
  author          = {Baek, Young-Min and Bae, Doo-Hwan},
  title           = {{Automated Model-Based Android GUI Testing using Multi-level GUI Comparison Criteria}},
  booktitle       = {2016 31ST IEEE/ACM INTERNATIONAL CONFERENCE ON AUTOMATED SOFTWARE ENGINEERING (ASE)},
  year            = {2016},
  editor          = {{Lo, D and Apel, S and Khurshid, S}},
  series          = {IEEE ACM International Conference on Automated Software Engineering},
  pages           = {238--249},
  organization    = {IEEE; ACM; ACM Special Interest Grp Software Engn; ACM SIGAI; Singapore Management Univ; LEE Fdn; Singapore Management Univ, Sch Informat Syst; Living Analyt Res Ctr; Software Analyt Res Ctr; Tata Consultancy Serv; Microsoft Res; NEC; FUJITSU},
  abstract        = {Automated Graphical User Interface (GUI) testing is one of the most
widely used techniques to detect faults in mobile applications (apps)
and to test functionality and usability. GUI testing exercises behaviors
of an application under test (AUT) by executing events on GUIs and
checking whether the app behaves correctly. In particular, because
Android leads in market share of mobile OS platforms, a lot of research
on automated Android GUI testing techniques has been performed. Among
various techniques, we focus on model-based Android GUI testing that
utilizes a GUI model for systematic test generation and effective
debugging support. Since test inputs are generated based on the
underlying model, accurate GUI modeling of an AUT is the most crucial
factor in order to generate effective test inputs. However, most modern
Android apps contain a number of dynamically constructed GUIs that make
accurate behavior modeling more challenging. To address this problem, we
propose a set of multi-level GUI Comparison Criteria (GUICC) that
provides the selection of multiple abstraction levels for GUI model
generation. By using multilevel GUICC, we conducted empirical
experiments to identify the influence of GUICC on testing effectiveness.
Results show that our approach, which performs model-based testing with
multi-level GUICC, achieved higher effectiveness than activity-based GUI
model generation. We also found that multi-level GUICC can alleviate the
inherent state explosion problems of existing a single-level GUICC for
behavior modeling of real-world Android apps by flexibly manipulating
GUICC.},
  annote          = {31st IEEE/ACM International Conference on Automated Software Engineering (ASE), Singapore, SINGAPORE, SEP 03-07, 2016},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2970276.2970313},
  doi             = {10.1145/2970276.2970313},
  isbn            = {978-1-4503-3845-5},
  issn            = {1527-1366},
}

@Article{Ali2018,
  author          = {Ali, A and Maghawry, H A and Badr, N},
  title           = {{Automated parallel GUI testing as a service for mobile applications}},
  journal         = {Journal of Software: Evolution and Process},
  year            = {2018},
  volume          = {30},
  number          = {10},
  abstract        = {Recently, testing mobile applications is gaining much attention due to the widespread of smartphones and the tremendous number of mobile applications development. It is essential to test mobile applications before being released for the public use. Graphical user interface (GUI) testing is a type of mobile applications testing conducted to ensure the proper functionality of the GUI components. Typically, GUI testing requires a lot of effort and time whether manual or automatic. Cloud computing is an emerging technology that can be used in the software engineering field to overcome the defects of the traditional testing approaches by using cloud computing resources. As a result, testing-as-a-service is introduced as a service model that conducts all testing activities in a fully automated manner. In this paper, a system for mobile applications GUI testing based on testing-as-a-service architecture is proposed. The proposed system performs all testing activities including automatic test case generation and simultaneous test execution on multiple virtual nodes for testing Android-based applications. The proposed system reduces testing time and meets fast time-to market constraint of mobile applications. Moreover, the proposed system architecture addresses many issues such as maximizing resource utilization, continuous monitoring to ensure system reliability, and applying fault-tolerance approach to handle occurrence of any failure. Copyright {\textcopyright} 2018 John Wiley {\&} Sons, Ltd.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1002/smr.1963},
  doi             = {10.1002/smr.1963},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85055214444{\&}doi=10.1002{\%}2Fsmr.1963{\&}partnerID=40{\&}md5=1f3a8eb8333bd8b6169f8b78bb1c336c},
}

@Article{CHEN2018326,
  author          = {Chen, Sen and Xue, Minhui and Fan, Lingling and Hao, Shuang and Xu, Lihua and Zhu, Haojin and Li, Bo},
  title           = {{Automated poisoning attacks and defenses in malware detection systems: An adversarial machine learning approach}},
  journal         = {Computers {\&} Security},
  year            = {2018},
  volume          = {73},
  pages           = {326--344},
  issn            = {0167-4048},
  abstract        = {The evolution of mobile malware poses a serious threat to smartphone security. Today, sophisticated attackers can adapt by maximally sabotaging machine-learning classifiers via polluting training data, rendering most recent machine learning-based malware detection tools (such as Drebin, DroidAPIMiner, and MaMaDroid) ineffective. In this paper, we explore the feasibility of constructing crafted malware samples; examine how machine-learning classifiers can be misled under three different threat models; then conclude that injecting carefully crafted data into training data can significantly reduce detection accuracy. To tackle the problem, we propose KuafuDet, a two-phase learning enhancing approach that learns mobile malware by adversarial detection. KuafuDet includes an offline training phase that selects and extracts features from the training set, and an online detection phase that utilizes the classifier trained by the first phase. To further address the adversarial environment, these two phases are intertwined through a self-adaptive learning scheme, wherein an automated camouflage detector is introduced to filter the suspicious false negatives and feed them back into the training phase. We finally show that KuafuDet can significantly reduce false negatives and boost the detection accuracy by at least 15{\%}. Experiments on more than 250,000 mobile applications demonstrate that KuafuDet is scalable and can be highly effective as a standalone system.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404817302444},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2017.11.007},
  doi             = {https://doi.org/10.1016/j.cose.2017.11.007},
  keywords        = {Adversarial machine learning, KD, Manipulation, Poisoning attacks,Malware detection},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404817302444},
}

@Article{Yusop201697,
  author          = {Yusop, N and Kamalrudin, M and Sidek, S and Grundy, J},
  title           = {{Automated support to capture and validate security requirements for mobile apps}},
  journal         = {Communications in Computer and Information Science},
  year            = {2016},
  volume          = {671},
  pages           = {97--112},
  abstract        = {Mobile application usage has become widespread and significant as it allows interactions between people and services anywhere and anytime. However, issues related to security have become a major concern among mobile users as insecure applications may lead to security vulnerabilities that make them easily compromised by hackers. Thus, it is important for mobile application developers to validate security requirements of mobile apps at the earliest stage to prevent potential security problems. In this paper, we describe our automated approach and tool, called MobiMEReq that helps to capture and validate the security attributes requirements of mobile apps. We employed the concept of Test Driven Development (TDD) with a model-based testing strategy using Essential Use Cases (EUCs) and Essential User Interface (EUI) models. We also conducted an evaluation to compare the performance and correctness of our tool in various application domains. The results of the study showed that our tool is able to help requirements engineers to easily capture and validate security-related requirements of mobile applications. {\textcopyright} Springer Nature Singapore Pte Ltd. 2016.},
  annote          = {cited By 4},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-981-10-3256-1_7},
  doi             = {10.1007/978-981-10-3256-1_7},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84996644411{\&}doi=10.1007{\%}2F978-981-10-3256-1{\_}7{\&}partnerID=40{\&}md5=e681e14e3b84555448f843d41047fd9f},
}

@Conference{Kluth2014149,
  author          = {Kluth, W and Krempels, K.-H. and Samsel, C},
  title           = {{Automated usability testing for mobile applications}},
  booktitle       = {WEBIST 2014 - Proceedings of the 10th International Conference on Web Information Systems and Technologies},
  year            = {2014},
  volume          = {2},
  pages           = {149--156},
  abstract        = {In this paper we discuss the design and implementation of an automated usability evaluation method for iOS applications. In contrast to common usability testing methods, it is not explicitly necessary to involve an expert or subjects. These circumstances reduce costs, time and personnel expenditures. Professionals are replaced by the automation tool while test participants are exchanged with consumers of the launched application. Interactions of users are captured via a fully automated capturing framework which creates a record of user interactions for each session and sends them to a central server. A usability problem is defined as a sequence of interactions and pattern recognition specified by interaction design patterns is applied to find these problems. Nevertheless, it falls back to the user input for accurate results. Similar to the problem, the solution of the problem is based on the HCI design pattern. An evaluation shows the functionality of our approach compared to a traditional usability evaluation method.},
  annote          = {cited By 4},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902386283%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=d9c5472fb716ec4f466318647c5b14f5},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902386283{\&}partnerID=40{\&}md5=d9c5472fb716ec4f466318647c5b14f5},
}

@Article{Braghin200737,
  author          = {Braghin, C and Sharygina, N and Barone-Adesi, K},
  title           = {{Automated verification of security policies in mobile code}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2007},
  volume          = {4591 LNCS},
  pages           = {37--53},
  abstract        = {This paper describes an approach for the automated verification of mobile programs. Mobile systems are characterized by the explicit notion of locations (e.g., sites where they run) and the ability to execute at different locations, yielding a number of security issues. We give formal semantics to mobile systems as Labeled Kripke Structures, which encapsulate the notion of the location net. The location net summarizes the hierarchical nesting of threads constituting a mobile program and enables specifying security policies. We formalize a language for specifying security policies and show how mobile programs can be exhaustively analyzed against any given security policy by using model checking techniques. We developed and experimented with a prototype framework for analysis of mobile code, using the SATABS model checker. Our approach relies on SATABS's support for unbounded thread creation and enhances it with location net abstractions, which are essential for verifying large mobile programs. Our experimental results on various benchmarks are encouraging and demonstrate advantages of the model checking-based approach, which combines the validation of security properties with other checks, such as for buffer overflows. {\textcopyright} Springer-Verlag Berlin Heidelberg 2007.},
  annote          = {cited By 4},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-38149050539%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=7021b628d001809e008f787f2925d1df},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-38149050539{\&}partnerID=40{\&}md5=7021b628d001809e008f787f2925d1df},
}

@Article{Kamalrudin2014246,
  author          = {Kamalrudin, M and Noraiza, M and Grundy, J and Hosking, J and Robinson, M},
  title           = {{Automatic acceptance test case generation from essential use cases}},
  journal         = {Frontiers in Artificial Intelligence and Applications},
  year            = {2014},
  volume          = {265},
  pages           = {246--255},
  abstract        = {Requirements validation is a crucial process to determine whether client-stakeholders' needs and expectations of a product are sufficiently correct and complete. Various requirements validation techniques have been used to evaluate the correctness and quality of requirements, but most of these techniques are tedious, expensive and time consuming. Accordingly, most project members are reluctant to invest their time and efforts in the requirements validation process. Moreover, automated tool supports that promote effective collaboration between the client-stakeholders and the engineers are still lacking. In this paper, we describe a novel approach that combines prototyping and test-based requirements techniques to improve the requirements validation process and promote better communication and collaboration between requirements engineers and clientstakeholders. To justify the potential of this prototype tool, we also present three types of evaluation conducted on the prototpye tool, which are the usability survey, 3-tool comparison analysis and expert reviews. {\textcopyright} 2014 The authors and IOS Press. All rights reserved.},
  annote          = {cited By 6},
  bdsk-url-1      = {http://dx.doi.org/10.3233/978-1-61499-434-3-246},
  doi             = {10.3233/978-1-61499-434-3-246},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84948771900{\&}doi=10.3233{\%}2F978-1-61499-434-3-246{\&}partnerID=40{\&}md5=5a12105b401fd01c4a8986ebb841b12c},
}

@Article{ISI:000419409200041,
  author          = {Costa, Gabriele and Merlo, Alessio and Verderame, Luca and Armando, Alessandro},
  title           = {{Automatic security verification of mobile app configurations}},
  journal         = {FUTURE GENERATION COMPUTER SYSTEMS-THE INTERNATIONAL JOURNAL OF ESCIENCE},
  year            = {2018},
  volume          = {80},
  pages           = {519--536},
  month           = {mar},
  issn            = {0167-739X},
  abstract        = {The swift and continuous evolution of mobile devices is encouraging both
private and public organizations to adopt the Bring Your Own Device
(BYOD) paradigm. As a matter of fact, the BYOD paradigm drastically
reduces costs and increases productivity by allowing employees to carry
out business tasks on their personal devices. However, it also increases
the security concerns, since a compromised device could disruptively
access the resources of the organization. The current mobile application
distribution model based on application markets does not cope with this
issue. In a previous work the concept of secure meta-market has been
introduced as a mean to distribute mobile applications always guaranteed
to comply with any given BYOD policy. This is achieved through a
suitable combination of static analysis (i.e. model checking) and code
instrumentation techniques. Although crucial, enforcing security
policies over individual applications is not sufficient in general.
Indeed, several well documented threats arise from the malicious
interaction among applications which are harmless if isolated. In this
paper, a novel technique for the security verification of groups of
mobile app is proposed. The approach relies on partial model checking
(PMC) to extend the existing security guarantees to groups of
applications. The experimental results demonstrate the viability of the
approach. Moreover, we show through a case study that even a fairly
simple security policy can be violated by applications which are
compliant if considered one by one. (C) 2016 Elsevier B.V. All rights
reserved.},
  bdsk-url-1      = {http://dx.doi.org/10.1016/j.future.2016.06.014},
  doi             = {10.1016/j.future.2016.06.014},
}

@InProceedings{Hesenius:2014:AUT:2628363.2628391,
  author          = {Hesenius, Marc and Griebe, Tobias and Gries, Stefan and Gruhn, Volker},
  title           = {{Automating UI Tests for Mobile Applications with Formal Gesture Descriptions}},
  booktitle       = {Proceedings of the 16th International Conference on Human-computer Interaction with Mobile Devices {\&}{\#}38; Services},
  year            = {2014},
  series          = {MobileHCI '14},
  pages           = {213--222},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Touch- and gesture-based interfaces are common in applications for mobile devices. By evolving into mass market products, smartphones and tablets created an increased need for specialized software engineering methods. To ensure high quality applications, constant and efficient testing is crucial in software development. However, testing mobile applications is still cumbersome, time-consuming and error-prone. One reason is the devices' focus on touch-based interaction - gestures cannot be easily incorporated into automated application tests. We present an extension to the popular Calabash testing framework solving this problem by allowing to describe gestures with a formal language in tests scripts.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2628363.2628391},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2628363.2628391},
  doi             = {10.1145/2628363.2628391},
  isbn            = {978-1-4503-3004-6},
  keywords        = {gestures, mobile applications, software engineering, test automation, testing,gesture formalization},
  url             = {http://doi.acm.org/10.1145/2628363.2628391},
}

@Article{ZHANG2017516,
  author          = {Zhang, Xiaolu and Baggili, Ibrahim and Breitinger, Frank},
  title           = {{Breaking into the vault: Privacy, security and forensic analysis of Android vault applications}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {70},
  pages           = {516--531},
  issn            = {0167-4048},
  abstract        = {In this work we share the first account for the forensic analysis, security and privacy of Android vault applications. Vaults are designed to be privacy enhancing as they allow users to hide personal data but may also be misused to hide incriminating files. Our work has already helped law enforcement in the state of Connecticut to reconstruct 66 incriminating images and 18 videos in a single criminal case. We present case studies and results from analyzing 18 Android vault applications (accounting for nearly 220 million downloads from the Google Play store) by reverse engineering them and examining the forensic artifacts they produce. Our results showed that 1218 obfuscated their code and 518 applications used native libraries hindering the reverse engineering process of these applications. However, we still recovered data from the applications without root access to the Android device as we were able to ascertain hidden data on the device without rooting for 1018 of the applications. 618 of the vault applications were found to not encrypt photos they stored, and 818 were found to not encrypt videos. 718 of the applications were found to store passwords in cleartext. We were able to also implement a swap attack on 518 applications where we achieved unauthorized access to the data by swapping the files that contained the password with a self-created one. In some cases, our findings illustrate unfavorable security implementations of privacy enhancing applications, but also showcase practical mechanisms for investigators to gain access to data of evidentiary value. In essence, we broke into the vaults.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404817301529},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2017.07.011},
  doi             = {https://doi.org/10.1016/j.cose.2017.07.011},
  keywords        = {Android, Mobile applications, Privacy, Security, Vault applications,Forensics},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404817301529},
}

@Article{Tao20161605,
  author          = {Tao, Chuanqi and Gao, Jerry},
  title           = {{Building a Model-Based GUI Test Automation System for Mobile Applications}},
  journal         = {INTERNATIONAL JOURNAL OF SOFTWARE ENGINEERING AND KNOWLEDGE ENGINEERING},
  year            = {2016},
  volume          = {26},
  number          = {9-10},
  pages           = {1605--1615},
  issn            = {0218-1940},
  abstract        = {With the rapid advance of mobile computing technology and wireless networking, there is a significant increase of mobile applications (apps). This brings new business requirements and demands in mobile software testing, and causes new issues and challenges in mobile test automation. Existing mobile application testing approaches mostly concentrate on GUI-based testing, load and performance testing without considering large-scale concurrent mobile app test automation, and model-based test coverage analysis. In this paper, a mobile hierarchical GUI model is proposed to present mobile operation scenario flows and gesture features in a hierarchical manner, in order to facilitate test dependency analysis in test automation. Mobile app test coverage analysis is performed based on GUI ripping models. The paper also presents a developed system that provides a test automation solution using GUI models. Finally, the paper reports a case study to indicate the feasibility and effectiveness of the proposed approach. {\textcopyright} 2016 World Scientific Publishing Company.},
  annote          = {From Duplicate 1 (Building a Model-Based GUI Test Automation System for Mobile Applications - Tao, C; Gao, J) cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1142/S0218194016710042},
  doi             = {10.1142/S0218194016710042},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013324766{\&}doi=10.1142{\%}2FS0218194016710042{\&}partnerID=40{\&}md5=18c256f130aaf93de8a0bca52b49d271},
}

@Article{MARTIN2018121,
  author          = {Mart{\'{i}}n, Alejandro and Rodr{\'{i}}guez-Fern{\'{a}}ndez, V{\'{i}}ctor and Camacho, David},
  title           = {{CANDYMAN: Classifying Android malware families by modelling dynamic traces with Markov chains}},
  journal         = {Engineering Applications of Artificial Intelligence},
  year            = {2018},
  volume          = {74},
  pages           = {121--133},
  issn            = {0952-1976},
  abstract        = {Malware writers are usually focused on those platforms which are most used among common users, with the aim of attacking as many devices as possible. Due to this reason, Android has been heavily attacked for years. Efforts dedicated to combat Android malware are mainly concentrated on detection, in order to prevent malicious software to be installed in a target device. However, it is equally important to put effort into an automatic classification of the type, or family, of a malware sample, in order to establish which actions are necessary to mitigate the damage caused. In this paper, we present CANDYMAN, a tool that classifies Android malware families by combining dynamic analysis and Markov chains. A dynamic analysis process allows to extract representative information of a malware sample, in form of a sequence of states, while a Markov chain allows to model the transition probabilities between the states of the sequence, which will be used as features in the classification process. The space of features built is used to train classical Machine Learning, including methods for imbalanced learning, and Deep Learning algorithms, over a dataset of malware samples from different families, in order to evaluate the proposed method. Using a collection of 5,560 malware samples grouped into 179 different families (extracted from the Drebin dataset), and once made a selection based on a minimum number of relevant and valid samples, a final set of 4,442 samples grouped into 24 different malware families was used. The experimental results indicate a precision performance of 81.8{\%} over this dataset.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0952197618301374},
  bdsk-url-2      = {https://doi.org/10.1016/j.engappai.2018.06.006},
  doi             = {https://doi.org/10.1016/j.engappai.2018.06.006},
  keywords        = {Classification, Deep Learning, Dynamic analysis, Markov chains,Android malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S0952197618301374},
}

@InProceedings{Naik:2014:CCP:2593501.2593504,
  author          = {Naik, Kshirasagar and Ali, Yasir and Mahinthan, Veluppillai and Singh, Ajit and Abogharaf, Abdulhakim},
  title           = {{Categorizing Configuration Parameters of Smartphones for Energy Performance Testing}},
  booktitle       = {Proceedings of the 9th International Workshop on Automation of Software Test},
  year            = {2014},
  series          = {AST 2014},
  pages           = {15--21},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Energy performance testing in smartphones is a challenging task and the extent of exhaustive testing depends on the system configurations for different parameters and applications. In this paper, we propose a technique to classify the configuration parameters of a smartphone by partitioning them into two groups based on their maximum differential power (impact on power consumption). We validate the technique by applying it to four different smartphones: BlackBerry Bold 9700, BlackBerry Z10, Apple iPhone 3GS and Samsung Galaxy Nexus. The four devices represent a wide spectrum of devices with four operating systems (BB7, BB10, iOS, and Android), three makers (BlackBerry, Apple and Samsung), four hardware platforms, and relatively old and new devices.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2593501.2593504},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2593501.2593504},
  doi             = {10.1145/2593501.2593504},
  isbn            = {978-1-4503-2858-6},
  keywords        = {energy performance, software testing,Smartphone},
  url             = {http://doi.acm.org/10.1145/2593501.2593504},
}

@Article{WANG201730,
  author          = {Wang, Xing and Wang, Wei and He, Yongzhong and Liu, Jiqiang and Han, Zhen and Zhang, Xiangliang},
  title           = {{Characterizing Android apps' behavior for effective detection of malapps at large scale}},
  journal         = {Future Generation Computer Systems},
  year            = {2017},
  volume          = {75},
  pages           = {30--45},
  issn            = {0167-739X},
  abstract        = {Android malicious applications (malapps) have surged and been sophisticated, posing a great threat to users. How to characterize, understand and detect Android malapps at a large scale is thus a big challenge. In this work, we are motivated to discover the discriminatory and persistent features extracted from Android APK files for automated malapp detection at a large scale. To achieve this goal, firstly we extract a very large number of features from each app and categorize the features into two groups, namely, app-specific features as well as platform-defined features. These feature sets will then be fed into four classifiers (i.e., Logistic Regression, linear SVM, Decision Tree and Random Forest) for the detection of malapps. Secondly, we evaluate the persistence of app-specific and platform-defined features on classification performance with two data sets collected in different time periods. Thirdly, we comprehensively analyze the relevant features selected by Logistic Regression classifier to identify the contributions of each feature set. We conduct extensive experiments on large real-world app sets consisting of 213,256 benign apps collected from six app markets, 4,363 benign apps from Google Play market, and 18,363 malapps. The experimental results and our analysis give insights regarding what discriminatory features are most effective to characterize malapps for building an effective and efficient malapp detection system. With the selected discriminatory features, the Logistic Regression classifier yields the best true positive rate as 96{\%} with a false positive rate as 0.06{\%}.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X17307720},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2017.04.041},
  doi             = {https://doi.org/10.1016/j.future.2017.04.041},
  keywords        = {Feature comparison, Malicious apps detection,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X17307720},
}

@Article{YANG201727,
  author          = {Yang, Xinli and Lo, David and Li, Li and Xia, Xin and Bissyand{\'{e}}, Tegawend{\'{e}} F and Klein, Jacques},
  title           = {{Characterizing malicious Android apps by mining topic-specific data flow signatures}},
  journal         = {Information and Software Technology},
  year            = {2017},
  volume          = {90},
  pages           = {27--39},
  issn            = {0950-5849},
  abstract        = {Context: State-of-the-art works on automated detection of Android malware have leveraged app descriptions to spot anomalies w.r.t the functionality implemented, or have used data flow information as a feature to discriminate malicious from benign apps. Although these works have yielded promising performance, we hypothesize that these performances can be improved by a better understanding of malicious behavior. Objective: To characterize malicious apps, we take into account both information on app descriptions, which are indicative of apps' topics, and information on sensitive data flow, which can be relevant to discriminate malware from benign apps. Method: In this paper, we propose a topic-specific approach to malware comprehension based on app descriptions and data-flow information. First, we use an advanced topic model, adaptive LDA with GA, to cluster apps according to their descriptions. Then, we use information gain ratio of sensitive data flow information to build so-called ``topic-specific data flow signatures''. Results: We conduct an empirical study on 3691 benign and 1612 malicious apps. We group them into 118 topics and generate topic-specific data flow signature. We verify the effectiveness of the topic-specific data flow signatures by comparing them with the overall data flow signature. In addition, we perform a deeper analysis on 25 representative topic-specific signatures and yield several implications. Conclusion: Topic-specific data flow signatures are efficient in highlighting the malicious behavior, and thus can help in characterizing malware.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S095058491730366X},
  bdsk-url-2      = {https://doi.org/10.1016/j.infsof.2017.04.007},
  doi             = {https://doi.org/10.1016/j.infsof.2017.04.007},
  keywords        = {Data flow signature, Empirical study, Topic-specific,Malware characterization},
  url             = {http://www.sciencedirect.com/science/article/pii/S095058491730366X},
}

@InProceedings{Li:2018:CAD:3213846.3213857,
  author          = {Li, Li and Bissyand{\'{e}}, Tegawend{\'{e}} F and Wang, Haoyu and Klein, Jacques},
  title           = {{CiD: Automating the Detection of API-related Compatibility Issues in Android Apps}},
  booktitle       = {Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  year            = {2018},
  series          = {ISSTA 2018},
  pages           = {153--163},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {The Android Application Programming Interface provides the necessary building blocks for app developers to harness the functionalities of the Android devices, including for interacting with services and accessing hardware. This API thus evolves rapidly to meet new requirements for security, performance and advanced features, creating a race for developers to update apps. Unfortunately, given the extent of the API and the lack of automated alerts on important changes, Android apps are suffered from API-related compatibility issues. These issues can manifest themselves as runtime crashes creating a poor user experience. We propose in this paper an automated approach named CiD for systematically modelling the lifecycle of the Android APIs and analysing app bytecode to flag usages that can lead to potential compatibility issues. We demonstrate the usefulness of CiD by helping developers repair their apps, and we validate that our tool outperforms the state-of-the-art on benchmark apps that take into account several challenges for automatic detection.

},
  bdsk-url-1      = {http://doi.acm.org/10.1145/3213846.3213857},
  bdsk-url-2      = {http://dx.doi.org/10.1145/3213846.3213857},
  doi             = {10.1145/3213846.3213857},
  isbn            = {978-1-4503-5699-2},
  keywords        = {Android, CiD, Framework Base,API-related Compatibility Issue},
  url             = {http://doi.acm.org/10.1145/3213846.3213857},
}

@Conference{Ernst20141092,
  author          = {Ernst, M D and Just, R and Millstein, S and Dietl, W and Pernsteiner, S and Roesner, F and Koscher, K and Barros, P and Bhoraskar, R and Han, S and Vines, P and Wu, E X},
  title           = {{Collaborative verification of information flow for a high-assurance app store}},
  booktitle       = {Proceedings of the ACM Conference on Computer and Communications Security},
  year            = {2014},
  pages           = {1092--1104},
  abstract        = {Current app stores distribute some malware to unsuspecting users, even though the app approval process may be costly and timeconsuming. High-integrity app stores must provide stronger guarantees that their apps are not malicious. We propose a verification model for use in such app stores to guarantee that the apps are free of malicious information flows. In our model, the software vendor and the app store auditor collaborate - each does tasks that are easy for her/him, reducing overall verification cost. The software vendor provides a behavioral specification of information flow (at a finer granularity than used by current app stores) and source code annotated with information-flow type qualifiers. A flow-sensitive, context-sensitive information-flow type system checks the information flow type qualifiers in the source code and proves that only information flows in the specification can occur at run time. The app store auditor uses the vendor-provided source code to manually verify declassifications. We have implemented the information-flow type system for Android apps written in Java, and we evaluated both its effectiveness at detecting information-flow violations and its usability in practice. In an adversarial Red Team evaluation, we analyzed 72 apps (576,000 LOC) for malware. The 57 Trojans among these had been written specifically to defeat a malware analysis such as ours. Nonetheless, our information-flow type system was effective: it detected 96{\%} of malware whose malicious behavior was related to information flow and 82{\%} of all malware. In addition to the adversarial evaluation, we evaluated the practicality of using the collaborative model. The programmer annotation burden is low: 6 annotations per 100 LOC. Every sound analysis requires a human to review potential false alarms, and in our experiments, this took 30 minutes per 1,000 LOC for an auditor unfamiliar with the app. Copyright 2014 ACM.},
  annote          = {cited By 37},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2660267.2660343},
  doi             = {10.1145/2660267.2660343},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84910609863{\&}doi=10.1145{\%}2F2660267.2660343{\&}partnerID=40{\&}md5=eb324cf8594d9bc9e9ec93235c0d5354},
}

@Conference{Zhang2015179,
  author          = {Zhang, T and Gao, J and Cheng, J and Uehara, T},
  title           = {{Compatibility testing service for mobile applications}},
  booktitle       = {Proceedings - 9th IEEE International Symposium on Service-Oriented System Engineering, IEEE SOSE 2015},
  year            = {2015},
  volume          = {30},
  pages           = {179--186},
  abstract        = {As more and more mobile applications are developed, mobile app testing and quality assurance have become very important. Due to the diversity of mobile devices and platforms, compatibility testing for mobile apps has been identified as one urgent and challenging issue. There are two major reasons contributing to this issue. They are: a) the large number of mobile devices with diverse features and platforms which are upgraded frequently; b) a higher cost and complexity in mobile app compatibility testing. This paper proposes one optimized compatibility testing strategy using a statistical approach to reduce test costs, and improve engineer's operation efficiency. The paper provides a solution to generate an optimized compatibility test sequence for mobile apps using the K-Means statistical algorithm. A compatibility testing service has been proposed for mobile apps. Moreover, two case study results are reported to demonstrate its potential application and effectiveness. {\textcopyright} 2015 IEEE.},
  annote          = {cited By 11},
  bdsk-url-1      = {http://dx.doi.org/10.1109/SOSE.2015.35},
  doi             = {10.1109/SOSE.2015.35},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84990998492{\&}doi=10.1109{\%}2FSOSE.2015.35{\&}partnerID=40{\&}md5=76f48e8af4ab6e126e077a9af99dab1a},
}

@Article{Gunawan201375,
  author          = {Gunawan, L A and Herrmann, P},
  title           = {{Compositional verification of application-level security properties}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2013},
  volume          = {7781 LNCS},
  pages           = {75--90},
  abstract        = {Automatic model checking can be employed to verify that security properties are fulfilled by a system model. However, since security requirements constrain most, if not all, functional modules of a system, such a proof needs to consider nearly all of the system's control and data flows. For complex real-life applications, that leads to a large state space to be explored effectively restricting the applicability of a model checker. To deal with this problem, we advocate a compositional approach utilizing the features of our model-based engineering technique SPACE. Both functional behavior and security-related aspects are specified using UML 2 activities. Further, we supplement each activity with an interface behavior description which will be extended by a security contract modeling certain security properties to be fulfilled by the activity. This enables us to verify application-level security properties by using contracts instead of their respective activities in model checker runs so that the number of states to be checked is significantly reduced. The approach is exemplified by an Android application example in which one's location must only be shared with certain recipients. {\textcopyright} Springer-Verlag Berlin Heidelberg 2013.},
  annote          = {cited By 5},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-642-36563-8_6},
  doi             = {10.1007/978-3-642-36563-8_6},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893126507{\&}doi=10.1007{\%}2F978-3-642-36563-8{\_}6{\&}partnerID=40{\&}md5=a6b2fddb6d213521c04d3d1d768f44ba},
}

@Conference{Salva2013,
  author          = {Salva, S and Zafimiharisoa, S R},
  title           = {{Data vulnerability detection by security testing for Android applications}},
  booktitle       = {2013 Information Security for South Africa - Proceedings of the ISSA 2013 Conference},
  year            = {2013},
  abstract        = {The Android intent messaging is a mechanism that ties components together to build Mobile applications. Intents are kinds of messages composed of actions and data, sent by a component to another component to perform several operations, e.g., launching a user interface. The intent mechanism eases the writing of Mobile applications, but it might also be used as an entry point for security attacks. The latter can be easily sent with intents to components, that can indirectly forward attacks to other components and so on. In this context, this paper proposes a Model-based security testing approach to attempt to detect data vulnerabilities in Android applications. In other words, this approach generates test cases to check whether components are vulnerable to attacks, sent through intents, that expose personal data. Our method takes Android applications and intent-based vulnerabilities formally expressed with models called vulnerability patterns. Then, and this is the originality of our approach, partial specifications are automatically generated from configuration files and component codes. Test cases are then automatically generated from vulnerability patterns and the previous specifications. A tool, called APSET, is presented and evaluated with experimentations on some Android applications. {\textcopyright} 2013 IEEE.},
  annote          = {cited By 10},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ISSA.2013.6641043},
  doi             = {10.1109/ISSA.2013.6641043},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84890841326{\&}doi=10.1109{\%}2FISSA.2013.6641043{\&}partnerID=40{\&}md5=a81573f9a5027964984d5aece276ef6d},
}

@InProceedings{Canfora:2015:DAM:2804345.2804349,
  author          = {Canfora, Gerardo and Medvet, Eric and Mercaldo, Francesco and Visaggio, Corrado Aaron},
  title           = {{Detecting Android Malware Using Sequences of System Calls}},
  booktitle       = {Proceedings of the 3rd International Workshop on Software Development Lifecycle for Mobile},
  year            = {2015},
  series          = {DeMobile 2015},
  pages           = {13--20},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {The increasing diffusion of smart devices, along with the dynamism of the mobile applications ecosystem, are boosting the production of malware for the Android platform. So far, many different methods have been developed for detecting Android malware, based on either static or dynamic analysis. The main limitations of existing methods include: low accuracy, proneness to evasion techniques, and weak validation, often limited to emulators or modified kernels. We propose an Android malware detection method, based on sequences of system calls, that overcomes these limitations. The assumption is that malicious behaviors (e.g., sending high premium rate SMS, cyphering data for ransom, botnet capabilities, and so on) are implemented by specific system calls sequences: yet, no apriori knowledge is available about which sequences are associated with which malicious behaviors, in particular in the mobile applications ecosystem where new malware and non-malware applications continuously arise. Hence, we use Machine Learning to automatically learn these associations (a sort of "fingerprint" of the malware); then we exploit them to actually detect malware. Experimentation on 20000 execution traces of 2000 applications (1000 of them being malware belonging to different malware families), performed on a real device, shows promising results: we obtain a detection accuracy of 97%. Moreover, we show that the proposed method can cope with the dynamism of the mobile apps ecosystem, since it can detect unknown malware.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2804345.2804349},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2804345.2804349},
  doi             = {10.1145/2804345.2804349},
  isbn            = {978-1-4503-3815-8},
  keywords        = {dynamic analysis, machine learning, malware, security,Android},
  url             = {http://doi.acm.org/10.1145/2804345.2804349},
}

@InProceedings{7102585,
  author          = {Wan, M and Jin, Y and Li, D and Halfond, W G J},
  title           = {{Detecting Display Energy Hotspots in Android Apps}},
  booktitle       = {2015 IEEE 8th International Conference on Software Testing, Verification and Validation (ICST)},
  year            = {2015},
  pages           = {1--10},
  month           = {apr},
  abstract        = {Energy consumption of mobile apps has become an important consideration as the underlying devices are constrained by battery capacity. Display represents a significant portion of an app's energy consumption. However, developers lack techniques to identify the user interfaces in their apps for which energy needs to be improved. In this paper, we present a technique for detecting display energy hotspots - user interfaces of a mobile app whose energy consumption is greater than optimal. Our technique leverages display power modeling and automated display transformation techniques to detect these hotspots and prioritize them for developers. In an evaluation on a set of popular Android apps, our technique was very accurate in both predicting energy consumption and ranking the display energy hotspots. Our approach was also able to detect display energy hotspots in 398 Android market apps, showing its effectiveness and the pervasiveness of the problem. These results indicate that our approach represents a potentially useful technique for helping developers to detect energy related problems and reduce the energy consumption of their mobile apps.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICST.2015.7102585},
  doi             = {10.1109/ICST.2015.7102585},
  issn            = {2159-4848},
  keywords        = {Android (operating system);mobile computing;power aware computing;user interfaces;display energy hotspots detection;user interfaces;mobile app;energy consumption;display power modeling;automated display transformation techniques;Android market apps;Color;Energy consumption;User interfaces;Power demand;Mobile communication;Smart phones;Monitoring},
}

@InProceedings{ISI:000452049800051,
  author          = {Banerjee, Abhijeet and Chong, Lee Kee and Chattopadhyay, Sudipta and Roychoudhury, Abhik},
  title           = {{Detecting Energy Bugs and Hotspots in Mobile Apps}},
  booktitle       = {22ND ACM SIGSOFT INTERNATIONAL SYMPOSIUM ON THE FOUNDATIONS OF SOFTWARE ENGINEERING (FSE 2014)},
  year            = {2014},
  pages           = {588--598},
  organization    = {Assoc Comp Machinery Special Interest Grp Software Engn; CVIC SE; NSF; Microsoft Res; Huawei; Neusoft; Siemens; Yonyou; Hong Kong Univ Sci {\&} Technol; Google; Radica; Samsung Res Amer; IBM Res; TCL; CCC},
  abstract        = {Over the recent years, the popularity of smartphones has increased
dramatically. This has lead to a widespread availability of smartphone
applications. Since smartphones operate on a limited amount of battery
power, it is important to develop tools and techniques that aid in
energy-efficient application development. Energy inefficiencies in
smartphone applications can broadly be categorized into energy hotspots
and energy bugs. An energy hotspot can be described as a scenario where
executing an application causes the smartphone to consume abnormally
high amount of battery power, even though the utilization of its
hardware resources is low. In contrast, an energy bug can be described
as a scenario where a malfunctioning application prevents the smartphone
from becoming idle, even after it has completed execution and there is
no user activity.
In this paper, we present an automated test generation framework that
detects energy hotspots/bugs in Android applications. Our framework
systematically generates test inputs that are likely to capture energy
hotspots/bugs. Each test input captures a sequence of user interactions
(e.g. touches or taps on the smartphone screen) that leads to an energy
hotspot/bug in the application. Evaluation with 30 freely-available
Android applications from Google Play/F-Droid shows the efficacy of our
framework in finding hotspots/bugs. Manual validation of the
experimental results shows that our framework reports reasonably low
number of false positives. Finally, we show the usage of the generated
results by improving the energy-efficiency of some Android applications.},
  annote          = {22nd ACM SIGSOFT International Symposium on the Foundations of Software Engineering (FSE), Hong Kong, HONG KONG, NOV 16-21, 2014},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2635868.2635871},
  doi             = {10.1145/2635868.2635871},
  isbn            = {978-1-4503-3056-5},
}

@Article{Zhang2015454,
  author          = {Zhang, L and Zhang, Y and Zang, T},
  title           = {{Detecting malicious behaviors in repackaged android apps with loosely-coupled payloads filtering scheme}},
  journal         = {Lecture Notes of the Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering, LNICST},
  year            = {2015},
  volume          = {152},
  pages           = {454--462},
  abstract        = {Recently, the security problem of Android applications has been increasingly prominent. In this paper, we propose a novel approach to detect malicious behaviors in loosely-coupled repackaged Android apps. We extract and modify the FCG of an app based on its loosely-coupled property, and divide it into several sub-graphs to identify primary module and its related modules. In each remaining sub-graph, API calls are added and sensitive API paths are extracted for dynamic instrumentation on top of APIMonitor. The experiments are conducted with 438 malwares and 1529 apps from two third-party Android markets. Through manual verification, we confirm 5 kinds of malwares in 16 apps detected by our approach. And the detection rate of collected malwares reaches 99.77{\%}. The reduction rate of monitored functions reaches 42.95{\%} with 98.79{\%} of malicious functions being successfully saved. The time spent on static and dynamic analysis is 74.9 s and 16.0 s on average. {\textcopyright} Institute for Computer Sciences, Social Informatics and Telecommunications Engineering 2015.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-23829-6_31},
  doi             = {10.1007/978-3-319-23829-6_31},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84948154951{\&}doi=10.1007{\%}2F978-3-319-23829-6{\_}31{\&}partnerID=40{\&}md5=587ccd78d5d74b8e0c2d139fa7ebc9b5},
}

@Article{SEO201443,
  author          = {Seo, Seung-Hyun and Gupta, Aditi and Sallam, Asmaa Mohamed and Bertino, Elisa and Yim, Kangbin},
  title           = {{Detecting mobile malware threats to homeland security through static analysis}},
  journal         = {Journal of Network and Computer Applications},
  year            = {2014},
  volume          = {38},
  pages           = {43--53},
  issn            = {1084-8045},
  abstract        = {Recent years have seen the significant increase in the popularity of smartphones. This popularity has been accompanied with an equally alarming rise in mobile malware. Recently released mobile malware targeting Android devices have been found to specifically focus on root exploits to obtain root-level access and execute instructions from a remote server. Thus, this kind of mobile malware presents a significant threat to Homeland Security. This is possible because smartphones can serve as zombie devices which are then controlled by hackers' via a C{\&}C server. In this paper, we discuss the defining characteristics inherent in mobile malware and show mobile attack scenarios which are feasible against Homeland Security. We also propose a static analysis tool, DroidAnalyzer, which identifies potential vulnerabilities of Android apps and the presence of root exploits. Then, we analyze various mobile malware samples and targeting apps such as banking, flight tracking and booking, home{\&}office monitoring apps to examine potential vulnerabilities by applying DroidAnalyzer.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1084804513001227},
  bdsk-url-2      = {https://doi.org/10.1016/j.jnca.2013.05.008},
  doi             = {https://doi.org/10.1016/j.jnca.2013.05.008},
  keywords        = {Android OS, Homeland security, Smartphone,Mobile malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S1084804513001227},
}

@InProceedings{Zhang:2018:DEI:3236024.3236073,
  author          = {Zhang, Hailong and Wu, Haowei and Rountev, Atanas},
  title           = {{Detection of Energy Inefficiencies in Android Wear Watch Faces}},
  booktitle       = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  year            = {2018},
  series          = {ESEC/FSE 2018},
  pages           = {691--702},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {This work considers watch faces for Android Wear devices such as smartwatches. Watch faces are a popular category of apps that display current time and relevant contextual information. Our study of watch faces in an app market indicates that energy efficiency is a key concern for users and developers.

The first contribution of this work is the definition of several energy-inefficiency patterns of watch face behavior, focusing on two energy-intensive resources: sensors and displays. Based on these patterns, we propose a control-flow model and static analysis algorithms to identify instances of these patterns. The algorithms use interprocedural control-flow analysis of callback methods and the invocation sequences of these methods. Potential energy inefficiencies are then used for automated test generation and execution, where the static analysis reports are validated via run-time execution. Our experimental results and case studies demonstrate that the analysis achieves high precision and low cost, and provide insights into potential pitfalls faced by developers of watch faces.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/3236024.3236073},
  bdsk-url-2      = {http://dx.doi.org/10.1145/3236024.3236073},
  doi             = {10.1145/3236024.3236073},
  isbn            = {978-1-4503-5573-5},
  keywords        = {energy, sensor, smartwatch, static analysis, testing,Android Wear},
  url             = {http://doi.acm.org/10.1145/3236024.3236073},
}

@Book{Salva2013397,
  title           = {{Detection of Intent-Based Vulnerabilities in Android Applications}},
  year            = {2013},
  author          = {Salva, S and Zafimiharisoa, S R},
  abstract        = {The intent mechanism of the Android platform is a powerful message-passing system that allows for sharing data among components and applications. Nevertheless, it might also be used as an entry point for security attacks if incautiously employed. Attacks can be easily sent through intents to components, which can indirectly forward them to other components, and so on. In this context, this chapter proposes a model-based security testing approach to attempt to detect data vulnerabilities in Android applications. In other words, this approach generates test cases to check whether components are vulnerable to attacks, sent through intents that expose personal data. Our method takes Android applications and intent-based vulnerabilities formally expressed with models called vulnerability patterns. Then, and this is the originality of our approach, partial specifications are automatically generated from Android applications with algorithms reflecting the Android documentation. These specifications avoid false positives and refine test verdicts. A tool called APSET is presented and evaluated with tests on some Android applications. {\textcopyright} 2014 Elsevier Inc. All rights reserved.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1016/B978-0-12-411474-6.00024-4},
  booktitle       = {Emerging Trends in ICT Security},
  doi             = {10.1016/B978-0-12-411474-6.00024-4},
  pages           = {397--417},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84902238649{\&}doi=10.1016{\%}2FB978-0-12-411474-6.00024-4{\&}partnerID=40{\&}md5=02df65da781d0dc07987419470daadb4},
}

@Article{DiCerbo2011138,
  author          = {{Di Cerbo}, F and Girardello, A and Michahelles, F and Voronkova, S},
  title           = {{Detection of malicious applications on android OS}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2011},
  volume          = {6540 LNCS},
  pages           = {138--149},
  abstract        = {The paper presents a methodology for mobile forensics analysis, to detect "malicious" (or "malware") applications, i.e., those that deceive users hiding some of their functionalities. This methodology is specifically targeted for the Android mobile operating system, and relies on its security model features, namely the set of permissions exposed by each application. The methodology has been trained on more than 13,000 applications hosted on the Android Market, collected with AppAware. A case study is presented as a preliminary validation of the methodology. {\textcopyright} 2011 Springer-Verlag Berlin Heidelberg.},
  annote          = {cited By 44},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-642-19376-7_12},
  doi             = {10.1007/978-3-642-19376-7_12},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-79952266600{\&}doi=10.1007{\%}2F978-3-642-19376-7{\_}12{\&}partnerID=40{\&}md5=07c25416affbf64892c2484249f95ef1},
}

@Article{ISI:000358163500008,
  author          = {Aldini, Alessandro and Martinelli, Fabio and Saracino, Andrea and Sgandurra, Daniele},
  title           = {{Detection of repackaged mobile applications through a collaborative approach}},
  journal         = {CONCURRENCY AND COMPUTATION-PRACTICE {\&} EXPERIENCE},
  year            = {2015},
  volume          = {27},
  number          = {11, SI},
  pages           = {2818--2838},
  issn            = {1532-0626},
  abstract        = {Repackaged applications are based on genuine applications, but they
subtlety include some modifications. In particular, trojanized
applications are one of the most dangerous threats for smartphones.
Malware code may be hidden inside applications to access private data or
to leak user credit. In this paper, we propose a contract-based approach
to detect such repackaged applications, where a contract specifies the
set of legal actions that can be performed by an application. Current
methods to generate contracts lack information from real usage
scenarios, thus being inaccurate and too coarse-grained. This may result
either in generating too many false positives or in missing misbehaviors
when verifying the compliance between the application and the contract.
In the proposed framework, application contracts are generated
dynamically by a central server merging execution traces collected and
shared continuously by collaborative users executing the application.
More precisely, quantitative information extracted from execution traces
is used to define a contract describing the expected application
behavior, which is deployed to the cooperating users. Then, every user
can use the received contract to check whether the related application
is either genuine or repackaged. Such a verification is based on an
enforcement mechanism that monitors the application execution at
run-time and compares it against the contract through statistical tests.
Copyright (c) 2014 John Wiley {\&} Sons, Ltd.},
  annote          = {International Conference on Collaboration Technologies and Systems (CTS), San Diego, CA, MAY 20-24, 2013},
  bdsk-url-1      = {http://dx.doi.org/10.1002/cpe.3447},
  doi             = {10.1002/cpe.3447},
  institution     = {IEEE; Intelligent Automat Inc; Knowledge Based Syst Inc; LexisNexis Corp; Ball Aerosp {\&} Technologies Corp; Intel Corp; Microsoft Res; Progeny Syst Corp; Springer Verlag},
}

@Article{Zhu2018638,
  author          = {Zhu, H.-J. and You, Z.-H. and Zhu, Z.-X. and Shi, W.-L. and Chen, X and Cheng, L},
  title           = {{DroidDet: Effective and robust detection of android malware using static analysis along with rotation forest model}},
  journal         = {Neurocomputing},
  year            = {2018},
  volume          = {272},
  pages           = {638--646},
  abstract        = {The Android platform is becoming increasingly popular and various organizations have developed a variety of applications (App) to cater to market trends. Due to the characteristics of the Android platform, such as supporting the unofficial App stores, open source policy and the great tolerance for App verification, it is inevitable that it faces serious problems of malicious software intrusion. In order to protect the users from the serious damages caused by Android malware, we propose a low-cost and high-efficient method to extract permissions, sensitive APIs, monitoring system events and permission-rate as key features, and employ the ensemble Rotation Forest (RF) to construct a model to detect whether an Android App is malicious or not. Specifically, a dataset containing 2,130 samples is used to verify the performance of the proposed method. The experimental results show that the proposed method achieves an high accuracy of 88.26{\%} with 88.40{\%} sensitivity at the precision of 88.16{\%}. To further evaluate the performance of the proposed model, we also compare it with the state-of-the-art Support Vector Machine (SVM) model under the same experimental conditions, and the comparison results demonstrate that the proposed method improves the accuracy by 3.33{\%} compared to SVM. The experimental results show that the proposed model is extremely promising and could provide a cost-effective alternative for Android malware detection. {\textcopyright} 2017},
  annote          = {cited By 7},
  bdsk-url-1      = {http://dx.doi.org/10.1016/j.neucom.2017.07.030},
  doi             = {10.1016/j.neucom.2017.07.030},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025821067{\&}doi=10.1016{\%}2Fj.neucom.2017.07.030{\&}partnerID=40{\&}md5=99d7f6ad889ced982589caf7eed65293},
}

@Article{FAN2017224,
  author          = {Fan, Wenhao and Sang, Yaohui and Zhang, Daishuai and Sun, Ran and Liu, Yuan'an},
  title           = {{DroidInjector: A process injection-based dynamic tracking system for runtime behaviors of Android applications}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {70},
  pages           = {224--237},
  issn            = {0167-4048},
  abstract        = {As the most widely applied mobile operating system for smartphones, Android is challenged by fast growing security problems, which are caused by malicious applications (apps). Behaviors of malicious apps become more and more inconspicuous, which largely increase the difficulty of security detection. This paper provides a new dynamic method, called DroidInjector, to further enrich Android malware detection technologies. DroidInjector is a process injection-based dynamic tracking method for monitoring the behaviors of target app during its running period. Distinguished with existing works, 1) DroidInjector uses a ptrace-based technology to attach itself to the process of the target app, so tracking can be done on smartphones or emulators, and without modifying Android OS; 2) DroidInjector can monitor security-sensitive Java API calls in Android Runtime (Android Virtual Machine) by hooking the APIs related to Android component lifecycle phases, dynamic library loading, multi-threading, inter-component and inter-process communications, and system resources. Thus, DroidInjector supports flexible deployments, and is able to provide a fine-grained context-aware, flow-aware and library-aware API calls tracking for the target app. DroidInjector is validated in extensive experiments through performance evaluation, application evaluation and case evaluation for multiple malicious and benign apps running on several smartphones installed with standard or customized Android systems.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404817301207},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2017.06.001},
  doi             = {https://doi.org/10.1016/j.cose.2017.06.001},
  keywords        = {App behavior, Process injection, Security, Tracking,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404817301207},
}

@Article{ALAM2017230,
  author          = {Alam, Shahid and Qu, Zhengyang and Riley, Ryan and Chen, Yan and Rastogi, Vaibhav},
  title           = {{DroidNative: Automating and optimizing detection of Android native code malware variants}},
  journal         = {Computers {\&} Security},
  year            = {2017},
  volume          = {65},
  pages           = {230--246},
  issn            = {0167-4048},
  abstract        = {According to the Symantec and F-Secure threat reports, mobile malware development in 2013 and 2014 has continued to focus almost exclusively ({\~{}}99{\%}) on the Android platform. Malware writers are applying stealthy mutations (obfuscations) to create malware variants, thwarting detection by signature-based detectors. In addition, the plethora of more sophisticated detectors making use of static analysis techniques to detect such variants operate only at the bytecode level, meaning that malware embedded in native code goes undetected. A recent study shows that 86{\%} of the most popular Android applications contain native code, making native code malware a plausible threat vector. This paper proposes DroidNative, an Android malware detector that uses specific control flow patterns to reduce the effect of obfuscations and provides automation. As far as we know, DroidNative is the first system that builds cross-platform (x86 and ARM) semantic-based signatures at the Android native code level, allowing the system to detect malware embedded in either bytecode or native code. When tested with a dataset of 5490 samples, DroidNative achieves a detection rate (DR) of 93.57{\%} and a false positive rate of 2.7{\%}. When tested with traditional malware variants, it achieves a DR of 99.48{\%}, compared to the DRs of academic and commercial tools that range from 8.33{\%} to 93.22{\%}.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S016740481630164X},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2016.11.011},
  doi             = {https://doi.org/10.1016/j.cose.2016.11.011},
  keywords        = {Control flow analysis, Data mining, Malware analysis, Malware variant detection,Android native code},
  url             = {http://www.sciencedirect.com/science/article/pii/S016740481630164X},
}

@InProceedings{Hu:2014:DLI:2627393.2627404,
  author          = {Hu, Wenhui and Octeau, Damien and McDaniel, Patrick Drew and Liu, Peng},
  title           = {{Duet: Library Integrity Verification for Android Applications}},
  booktitle       = {Proceedings of the 2014 ACM Conference on Security and Privacy in Wireless {\&}{\#}38; Mobile Networks},
  year            = {2014},
  series          = {WiSec '14},
  pages           = {141--152},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {In recent years, the Android operating system has had an explosive growth in the number of applications containing third-party libraries for different purposes. In this paper, we identify three library-centric threats in the real-world Android application markets: (i) the library modification threat, (ii) the masquerading threat and (iii) the aggressive library threat. These three threats cannot effectively be fully addressed by existing defense mechanisms such as software analysis, anti-virus software and anti-repackaging techniques. To mitigate these threats, we propose Duet, a library integrity verification tool for Android applications at application stores. This is non-trivial because the Android application build process merges library code and application-specific logic into a single binary file. Our approach uses reverse-engineering to achieve integrity verification. We implemented a full working prototype of Duet. In a dataset with 100,000 Android applications downloaded from Google Play between February 2012 and September 2013, we verify integrity of 15 libraries. On average, 80.50% of libraries can pass the integrity verification. In-depth analysis indicates that code insertion, obfuscation, and optimization on libraries by application developers are the primary reasons for not passing integrity verification. The evaluation results not only indicate that Duet is an effective tool to mitigate library-centric attacks, but also provide empirical insight into the library integrity situation in the wild.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2627393.2627404},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2627393.2627404},
  doi             = {10.1145/2627393.2627404},
  isbn            = {978-1-4503-2972-9},
  keywords        = {library integrity verification, library-centric security threat, smartphone, third-party library,android},
  url             = {http://doi.acm.org/10.1145/2627393.2627404},
}

@Conference{Hay2015118,
  author          = {Hay, R and Tripp, O and Pistoia, M},
  title           = {{Dynamic detection of inter-application communication vulnerabilities in android}},
  booktitle       = {2015 International Symposium on Software Testing and Analysis, ISSTA 2015 - Proceedings},
  year            = {2015},
  pages           = {118--128},
  abstract        = {A main aspect of the Android platform is Inter-Application Communication (IAC), which enables reuse of functionality across apps and app components via message passing. While a powerful feature, IAC also constitutes a serious attack surface. A malicious app can embed a payload into an IAC message, thereby driving the recipient app into a potentially vulnerable behavior if the message is processed without its fields first being sanitized or validated. We present what to our knowledge is the first comprehensive testing algorithm for Android IAC vulnerabilities. Toward this end, we first describe a catalog, stemming from our field experience, of 8 concrete vulnerability types that can potentially arise due to unsafe handling of incoming IAC messages. We then explain the main challenges that automated discovery of Android IAC vulnerabilities entails, including in particular path coverage and custom data fields, and present simple yet surprisingly effective solutions to these challenges. We have realized our testing approach as the Intent-Droid system, which is available as a commercial cloud service. IntentDroid utilizes lightweight platform-level in-strumentation, implemented via debug breakpoints (to run atop any Android device without any setup or customization), to recover IAC-relevant app-level behaviors. Evaluation of IntentDroid over a set of 80 top-popular apps has revealed a total 150 IAC vulnerabilities | some already fixed by the developers following our report | with a recall rate of 92{\%} w.r.t. a ground truth established via manual auditing by a security expert. {\textcopyright} 2015 ACM.},
  annote          = {cited By 19},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2771783.2771800},
  doi             = {10.1145/2771783.2771800},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84963711206{\&}doi=10.1145{\%}2F2771783.2771800{\&}partnerID=40{\&}md5=47d01a22bce7a25d618d5960de3aa998},
}

@Article{Zhao2017101,
  author          = {Zhao, R and Li, X and Xu, G and Feng, Z and Hao, J},
  title           = {{E-SSL: An SSL security-enhanced method for bypassing MITM attacks in mobile internet}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2017},
  volume          = {10189 LNCS},
  pages           = {101--120},
  abstract        = {In mobile internet, the Secure Sockets Layer (SSL) validation vulnerabilities of applications can be easily exploited through SSL Man-in-the-Middle (MITM) attacks, which are difficult to defeat. In this paper, an SSL Security-Enhanced method (E-SSL) is proposed to detect and defeat SSL MITM attacks, which improves the security of internet communication under malicious attacks. SSL proxy is used to find SSL certificate validation vulnerabilities and detect SSL MITM attacks. Based on randomness and hash theory, an SSL shared service with random port mapping is implemented to bypass SSL MITM attacks, the spatio-temporal randomization will increase the difficulty of attacker's correct guessing. We implement a prototype on Android platform, and verify its effectiveness and reliability with 650 apps under realistic SSL MITM attacks. Using the E-SSL approach, 185 apps out of 650 are detected with SSL certificate validation vulnerabilities. Furthermore, evaluation results show that the E-SSL approach enables these SSL certificate validation vulnerabilities apps to successfully bypass SSL MITM attacks, thus significantly increases the security of user data privacy in public mobile internet. {\textcopyright} Springer International Publishing AG 2017.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-57708-1_7},
  doi             = {10.1007/978-3-319-57708-1_7},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85018669458{\&}doi=10.1007{\%}2F978-3-319-57708-1{\_}7{\&}partnerID=40{\&}md5=9ab7b03577c83ab6ed941e8d46107846},
}

@Article{WU201617,
  author          = {Wu, Songyang and Wang, Pan and Li, Xun and Zhang, Yong},
  title           = {{Effective detection of android malware based on the usage of data flow APIs and machine learning}},
  journal         = {Information and Software Technology},
  year            = {2016},
  volume          = {75},
  pages           = {17--25},
  issn            = {0950-5849},
  abstract        = {Context. Android has been ranked as the top smartphone platform nowadays. Studies show that Android malware have increased dramatically and that personal privacy theft has become a major form of attack in recent years. These critical security circumstances have generated a strong interest in developing systems that automatically detect malicious behaviour in Android applications (apps). However, most methods of detecting sensitive data leakage have certain shortcomings, including computational expensiveness and false positives. Objective. This study proposes an Android malware detecting system that provides highly accurate classification and efficient sensitive data transmission analysis. Method. The study adopts a machine learning approach that leverages the use of dataflow application program interfaces (APIs) as classification features to detect Android malware. We conduct a thorough analysis to extract dataflow-related API-level features and improve the k-nearest neighbour classification model. The dataflow-related API list is further optimized through machine learning, which enables us to improve considerably the efficiency of sensitive data transmission analysis, whereas analytical accuracy is approximated to that of the experiment using a full dataflow-related API list. Results. The proposed scheme is evaluated using 1160 benign and 1050 malicious samples. Results show that the system can achieve an accuracy rate of as high as 97.66{\%} in detecting unknown Android malware. Our experiment of static dataflow analysis shows that more than 85{\%} of sensitive data transmission paths can be determined using the refined API subset, whereas time of analysis decreases by nearly 40{\%}. Conclusion. The usage of dataflow-related APIs is a valid feature for identifying Android malware. The proposed scheme provides an efficient approach to detecting Android malware and investigating privacy violations in malicious apps.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0950584916300386},
  bdsk-url-2      = {https://doi.org/10.1016/j.infsof.2016.03.004},
  doi             = {https://doi.org/10.1016/j.infsof.2016.03.004},
  keywords        = {Malware detection, Privacy leakage,Android security},
  url             = {http://www.sciencedirect.com/science/article/pii/S0950584916300386},
}

@InProceedings{ISI:000417469700006,
  author          = {Song, Wei and Qian, Xiangxing and Huang, Jeff},
  title           = {{EHBDroid: Beyond GUI Testing for Android Applications}},
  booktitle       = {PROCEEDINGS OF THE 2017 32ND IEEE/ACM INTERNATIONAL CONFERENCE ON AUTOMATED SOFTWARE ENGINEERING (ASE'17)},
  year            = {2017},
  editor          = {{Rosu, G and DiPenta, M and Nguyen, TN}},
  series          = {IEEE ACM International Conference on Automated Software Engineering},
  pages           = {27--37},
  organization    = {IEEE; Assoc Comp Machinery; IEEE Comp Soc; ACM SIGSOFT; ACM SIGAI; Coll Engn; NASA; Microsoft; DENSO; Univ Minnesota; Runtime Verificat; Huawei; InputOutput; Google; Toyota Infotechnol Ctr; Fox Dev Corp; Galois},
  abstract        = {With the prevalence of Android-based mobile devices, automated testing
for Android apps has received increasing attention. However, owing to
the large variety of events that Android supports, test input generation
is a challenging task. In this paper, we present a novel approach and an
open source tool called EHBDroid for testing Android apps. In contrast
to conventional GUI testing approaches, a key novelty of EHBDroid is
that it does not generate events from the GUI, but directly invokes
callbacks of event handlers. By doing so, EHBDroid can efficiently
simulate a large number of events that are difficult to generate by
traditional UI-based approaches. We have evaluated EHBDroid on a
collection of 35 real-world large-scale Android apps and compared its
performance with two state-of-the-art UI-based approaches, Monkey and
Dynodroid. Our experimental results show that EHBDroid is significantly
more effective and efficient than Monkey and Dynodroid: in a much
shorter time, EHBDroid achieves as much as 22.3{\%} higher statement
coverage (11.1{\%} on average) than the other two approaches, and found 12
bugs in these benchmarks, including 5 new bugs that the other two failed
to find.},
  annote          = {32nd IEEE/ACM International Conference on Automated Software Engineering (ASE), Univ Illinois Urbana Champaign, Urbana Champaign, IL, OCT 29-NOV 03, 2017},
  isbn            = {978-1-5386-2684-9},
  issn            = {1527-1366},
}

@Article{Allix2016183,
  author          = {Allix, K and Bissyand{\'{e}}, T F and J{\'{e}}rome, Q and Klein, J and State, R and {Le Traon}, Y},
  title           = {{Empirical assessment of machine learning-based malware detectors for Android: Measuring the gap between in-the-lab and in-the-wild validation scenarios}},
  journal         = {Empirical Software Engineering},
  year            = {2016},
  volume          = {21},
  number          = {1},
  pages           = {183--211},
  abstract        = {To address the issue of malware detection through large sets of applications, researchers have recently started to investigate the capabilities of machine-learning techniques for proposing effective approaches. So far, several promising results were recorded in the literature, many approaches being assessed with what we call in the lab validation scenarios. This paper revisits the purpose of malware detection to discuss whether such in the lab validation scenarios provide reliable indications on the performance of malware detectors in real-world settings, aka in the wild. To this end, we have devised several Machine Learning classifiers that rely on a set of features built from applications' CFGs. We use a sizeable dataset of over 50 000 Android applications collected from sources where state-of-the art approaches have selected their data. We show that, in the lab, our approach outperforms existing machine learning-based approaches. However, this high performance does not translate in high performance in the wild. The performance gap we observed---F-measures dropping from over 0.9 in the lab to below 0.1 in the wild---raises one important question: How do state-of-the-art approaches perform in the wild? {\textcopyright} 2014, Springer Science+Business Media New York.},
  annote          = {cited By 20},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s10664-014-9352-6},
  doi             = {10.1007/s10664-014-9352-6},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84955185163{\&}doi=10.1007{\%}2Fs10664-014-9352-6{\&}partnerID=40{\&}md5=efec207f34bf7f03efffe550ab162be5},
}

@InProceedings{Jabbarvand:2016:ETM:2931037.2931067,
  author          = {Jabbarvand, Reyhaneh and Sadeghi, Alireza and Bagheri, Hamid and Malek, Sam},
  title           = {{Energy-aware Test-suite Minimization for Android Apps}},
  booktitle       = {Proceedings of the 25th International Symposium on Software Testing and Analysis},
  year            = {2016},
  series          = {ISSTA 2016},
  pages           = {425--436},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {The rising popularity of mobile apps deployed on battery-constrained devices has motivated the need for effective energy-aware testing techniques. Energy testing is generally more labor intensive and expensive than functional testing, as tests need to be executed in the deployment environment and specialized equipment needs to be used to collect energy measurements. Currently, there is a dearth of automatic mobile testing techniques that consider energy as a program property of interest. This paper presents an energy-aware test-suite minimization approach to significantly reduce the number of tests needed to effectively test the energy properties of an Android app. It relies on an energy-aware coverage criterion that indicates the degree to which energy-greedy segments of a program are tested. We describe and evaluate two complementary algorithms for test-suite minimization. Experiments over test suites provided for real-world apps have corroborated our ability to reduce the test suite size by 84% on average, while maintaining the effectiveness of test suite in revealing the great majority of energy bugs.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2931037.2931067},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2931037.2931067},
  doi             = {10.1145/2931037.2931067},
  isbn            = {978-1-4503-4390-9},
  keywords        = {Coverage criterion, Green software engineering, Test-suite minimization,Android},
  url             = {http://doi.acm.org/10.1145/2931037.2931067},
}

@Article{MAN201429,
  author          = {Man, Yemao and Ngai, Edith C.-H.},
  title           = {{Energy-efficient automatic location-triggered applications on smartphones}},
  journal         = {Computer Communications},
  year            = {2014},
  volume          = {50},
  pages           = {29--40},
  issn            = {0140-3664},
  abstract        = {With the prevalence of localization techniques in smartphones, location-based applications on mobiles have become increasingly popular. However, only minorities of applications can be triggered automatically by the predefined locations of interest without any human interaction. One reason is that the inevitable operation of location detection by GPS is power-intensive. While existing work has focused on energy efficiency in continuous location tracking, energy-efficient location detection for matching predefined location of interest remains to be further explored. This paper proposes a unified framework that supports energy-efficient location detection for automatic location-triggered applications. Our framework triggers desired events only when the user is approaching the predefined locations of interest. Besides the efforts we make to reduce the number of GPS updates by cooperating with other types of on-device sensors, the framework also aims to coordinate multiple location-triggered applications to further reduce energy consumption on location updates. We implemented our framework as a middleware in the Android operating system and conducted extensive real experiments. The experimental results demonstrate that our framework can reduce the number of GPS requests and low the energy consumption of the smartphones significantly.},
  annote          = {Green Networking},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0140366414001200},
  bdsk-url-2      = {https://doi.org/10.1016/j.comcom.2014.03.023},
  doi             = {https://doi.org/10.1016/j.comcom.2014.03.023},
  keywords        = {Data collection, Location-based services, Mobile applications,Energy-efficiency},
  url             = {http://www.sciencedirect.com/science/article/pii/S0140366414001200},
}

@Article{Banerjee2018470,
  author          = {Banerjee, A and Chong, L K and Ballabriga, C and Roychoudhury, A},
  title           = {{EnergyPatch: Repairing Resource Leaks to Improve Energy-Efficiency of Android Apps}},
  journal         = {IEEE Transactions on Software Engineering},
  year            = {2018},
  volume          = {44},
  number          = {5},
  pages           = {470--490},
  abstract        = {Increased usage of mobile devices, such as smartphones and tablets, has led to widespread popularity and usage of mobile apps. If not carefully developed, such apps may demonstrate energy-inefficient behaviour, where one or more energy-intensive hardware components (such as Wifi, GPS, etc) are left in a high-power state, even when no apps are using these components. We refer to such kind of energy-inefficiencies as energy bugs. Executing an app with an energy bug causes the mobile device to exhibit poor energy consumption behaviour and a drastically shortened battery life. Since mobiles apps can have huge input domains, therefore exhaustive exploration is often impractical. We believe that there is a need for a framework that can systematically detect and fix energy bugs in mobile apps in a scalable fashion. To address this need, we have developed EnergyPatch, a framework that uses a combination of static and dynamic analysis techniques to detect, validate and repair energy bugs in Android apps. The use of a light-weight, static analysis technique enables EnergyPatch to quickly narrow down to the potential program paths along which energy bugs may occur. Subsequent exploration of these potentially buggy program paths using a dynamic analysis technique helps in validations of the reported bugs and to generate test cases. Finally, EnergyPatch generates repair expressions to fix the validated energy bugs. Evaluation with real-life apps from repositories such as F-droid and Github, shows that EnergyPatch is scalable and can produce results in reasonable amount of time. Additionally, we observed that the repair expressions generated by EnergyPatch could bring down the energy consumption on tested apps up to 60 percent. {\textcopyright} 2017 IEEE.},
  annote          = {cited By 3},
  bdsk-url-1      = {http://dx.doi.org/10.1109/TSE.2017.2689012},
  doi             = {10.1109/TSE.2017.2689012},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85047012040{\&}doi=10.1109{\%}2FTSE.2017.2689012{\&}partnerID=40{\&}md5=90975c442961d54a3871d02bc1433323},
}

@InProceedings{Lee:2015:ESF:2750858.2807531,
  author          = {Lee, Seokjun and Jung, Wonwoo and Chon, Yohan and Cha, Hojung},
  title           = {{EnTrack: A System Facility for Analyzing Energy Consumption of Android System Services}},
  booktitle       = {Proceedings of the 2015 ACM International Joint Conference on Pervasive and Ubiquitous Computing},
  year            = {2015},
  series          = {UbiComp '15},
  pages           = {191--202},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Energy accounting is an essential requirement for optimizing energy consumption on mobile devices. State-of-the-art approaches consider application processes and threads as the sole components of energy consumption. In this framework, the energy consumption of system services is unclear and has not been comprehensively studied. In this paper, we suggest that the energy consumption of system services should be investigated to understand the behavior of applications. We propose a fine-grained energy tracing scheme, EnTrack, to enhance the accuracy of energy tracing by identifying and incorporating the energy portions consumed by system services. We implemented EnTrack on the Android platform and validated its functionality and usefulness. In addition, practical usage cases of EnTrack, which uses it as an energy behavior analysis tool, were introduced. The case studies demonstrated that EnTrack enables an understanding of fine-grained energy consumption, especially in system services, which have previously been concealed.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2750858.2807531},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2750858.2807531},
  doi             = {10.1145/2750858.2807531},
  isbn            = {978-1-4503-3574-4},
  keywords        = {energy optimization, mobile systems,energy consumption tracing},
  url             = {http://doi.acm.org/10.1145/2750858.2807531},
}

@Article{Coleti2017363,
  author          = {Coleti, T A and Souza, L S and Morandini, M and Allard, S and Correa, P L P},
  title           = {{ErgoMobile: A software to support usability evaluations in mobile devices using observation techniques}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2017},
  volume          = {10288 LNCS},
  pages           = {363--378},
  abstract        = {The characteristics of mobile devices and their applications have led to changes in the way these systems are developed and tested. Usability tests are stages of development that are under constant modifications, since it is being taken into account that traditional techniques may not be sufficient to accomplish the testing activity for mobile devices. For example, the User Observation and Filming/Verbalization techniques involve the use of secondary devices to record the data. This may be a problem as the testing activity can become more complex and less comfortable for the users/evaluators. Aiming to present a strategy to minimize this issue, we are presenting the ErgoMobile environment that was developed with the main objective of avoiding the use of secondary devices since it can be installed directly in the mobile device and can collect images from the camera, sounds from the microphone and store interface snapshots. Initial tests presented that this tool behaves well when working in conjunction with other mobile applications, collecting good amounts of data and working in the background and practically had not created any disturbances to the participant or to the evaluator. {\textcopyright} Springer International Publishing AG 2017.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-58634-2_27},
  doi             = {10.1007/978-3-319-58634-2_27},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025137833{\&}doi=10.1007{\%}2F978-3-319-58634-2{\_}27{\&}partnerID=40{\&}md5=3778b1c0e5e3ba92c7839f05c6b2d10f},
}

@InProceedings{ISI:000418466000250,
  author          = {Martinelli, Fabio and Marulli, Fiammetta and Mercaldo, Francesco},
  title           = {{Evaluating Convolutional Neural Network for Effective Mobile Malware Detection}},
  booktitle       = {KNOWLEDGE-BASED AND INTELLIGENT INFORMATION {\&} ENGINEERING SYSTEMS},
  year            = {2017},
  editor          = {{ZanniMerk, C and Frydman, C and Toro, C and Hicks, Y and Howlett, RJ and Jain, LC}},
  volume          = {112},
  series          = {Procedia Computer Science},
  pages           = {2372--2381},
  organization    = {Lab Sci Informat Syst; KES Int},
  abstract        = {In last years smartphone and tablet devices have been handling an
increasing variety of sensitive resources. As a matter of fact, these
devices store a plethora of information related to our every-day life,
from the contact list, the received email, and also our position during
the day (using not only the GPS chipset that can be disabled but only
the Wi-Fi/mobile connection it is possible to discover the device
geolocalization).
This is the reason why mobile attackers are producing a large number of
malicious applications targeting Android (that is the most diffused
mobile operating system), often by modifying existing applications,
which results in malware being organized in families, where each
application belonging to the same family exhibit the same malicious
behaviour. These behaviours are typically information gathering related,
for instance a very widespread malicious behaviour in mobile is
represented by sending personal information (as examples: the contact
list, the received and send SMSs, the browser history) to a remote
server managed by the attackers.
In this paper, we investigate whether deep learning algorithms are able
to discriminate between malicious and legitimate Android samples. To
this end, we designed a method based on convolutional neural network
applied to syscalls occurrences through dynamic analysis. We
experimentally evaluated the built deep learning classifiers on a recent
dataset composed of 7100 real-world applications, more than 3000 of
which are widespread malware belonging to several different families in
order to test the effectiveness of the proposed method, obtaining
encouraging results. (C) 2017 The Authors. Published by Elsevier B.V.},
  annote          = {21st International Conference on Knowledge - Based and Intelligent Information and Engineering Systems (KES), Aix Marseille Univ, St Charles Campus, Marseille, FRANCE, SEP 06-08, 2017},
  bdsk-url-1      = {http://dx.doi.org/10.1016/j.procs.2017.08.216},
  doi             = {10.1016/j.procs.2017.08.216},
  issn            = {1877-0509},
}

@Article{ISI:000398352000002,
  author          = {Betarte, Gustavo and Campo, Juan and Luna, Carlos and Romano, Agustin},
  title           = {{Formal Analysis of Android's Permission-Based Security Model}},
  journal         = {SCIENTIFIC ANNALS OF COMPUTER SCIENCE},
  year            = {2016},
  volume          = {26},
  number          = {1},
  pages           = {27--68},
  issn            = {1843-8121},
  abstract        = {In this work we present a comprehensive formal specification of an
idealized formulation of Android's permission model. Permissions in
Android are basically tags that developers declare in their
applications, more precisely in the so-called application manifest, to
gain access to sensitive resources. Several analyses have recently been
carried out concerning the security of the Android system. Few of them,
however, pay attention to the formal aspects of the permission enforcing
framework. We provide a complete and uniform formulation of several
security properties using the higher order logic of the Calculus of
Inductive Constructions and sketch the proofs that have been developed
and verified using the Coq proof assistant. We also analyze how the
changes introduced in the latest version of Android, that allows to
manage permissions at runtime, impact the presented model.},
  bdsk-url-1      = {http://dx.doi.org/10.7561/SACS.2016.1.27},
  doi             = {10.7561/SACS.2016.1.27},
}

@InProceedings{Keng:2016:GDT:2896921.2896930,
  author          = {Keng, Joseph Chan Joo and Jiang, Lingxiao and Wee, Tan Kiat and Balan, Rajesh Krishna},
  title           = {{Graph-aided Directed Testing of Android Applications for Checking Runtime Privacy Behaviours}},
  booktitle       = {Proceedings of the 11th International Workshop on Automation of Software Test},
  year            = {2016},
  series          = {AST '16},
  pages           = {57--63},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {While automated testing of mobile applications is very useful for checking run-time behaviours and specifications, its capability in discovering issues in apps is often limited in practice due to long testing time. A common practice is to randomly and exhaustively explore the whole app test space, which takes a lot of time and resource to achieve good coverage and reach targeted parts of the apps.

In this paper, we present MAMBA, a directed testing system for checking privacy in Android apps. MAMBA performs path searches of user events in control-flow graphs of callbacks generated from static analysis of app bytecode. Based on the paths found, it builds test cases comprised of user events that can trigger the executions of the apps and quickly direct the apps' activity transitions from the starting activity towards target activities of interest, revealing potential accesses to privacy-sensitive data in the apps.

MAMBA's backend testing engine then simulates the executions of the apps following the generated test cases to check actual run-time behavior of the apps that may leak users' private data. We evaluated MAMBA against another automated testing approach that exhaustively searches for target activities in 24 apps, and found that our graph-aided directed testing achieves the same coverage of target activities 6.1 times faster on average, including the time required for bytecode analysis and test case generation. By instrumenting privacy access/leak detectors during testing, we were able to verify from test logs that almost half of target activities accessed user privacy data, and 26.7% of target activities leaked privacy data to the network.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2896921.2896930},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2896921.2896930},
  doi             = {10.1145/2896921.2896930},
  isbn            = {978-1-4503-4151-6},
  keywords        = {mobile privacy,automated mobile application testing},
  url             = {http://doi.acm.org/10.1145/2896921.2896930},
}

@Article{Zhu20183353,
  author          = {Zhu, H.-J. and Jiang, T.-H. and Ma, B and You, Z.-H. and Shi, W.-L. and Cheng, L},
  title           = {{HEMD: a highly efficient random forest-based malware detection framework for Android}},
  journal         = {Neural Computing and Applications},
  year            = {2018},
  volume          = {30},
  number          = {11},
  pages           = {3353--3361},
  abstract        = {Mobile phones are rapidly becoming the most widespread and popular form of communication; thus, they are also the most important attack target of malware. The amount of malware in mobile phones is increasing exponentially and poses a serious security threat. Google's Android is the most popular smart phone platforms in the world and the mechanisms of permission declaration access control cannot identify the malware. In this paper, we proposed an ensemble machine learning system for the detection of malware on Android devices. More specifically, four groups of features including permissions, monitoring system events, sensitive API and permission rate are extracted to characterize each Android application (app). Then an ensemble random forest classifier is learned to detect whether an app is potentially malicious or not. The performance of our proposed method is evaluated on the actual data set using tenfold cross-validation. The experimental results demonstrate that the proposed method can achieve a highly accuracy of 89.91{\%}. For further assessing the performance of our method, we compared it with the state-of-the-art support vector machine classifier. Comparison results demonstrate that the proposed method is extremely promising and could provide a cost-effective alternative for Android malware detection. {\textcopyright} 2017, The Natural Computing Applications Forum.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s00521-017-2914-y},
  doi             = {10.1007/s00521-017-2914-y},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85014789938{\&}doi=10.1007{\%}2Fs00521-017-2914-y{\&}partnerID=40{\&}md5=e53a9fbb193d31cfdb0a555baa60de39},
}

@Article{LIN2013340,
  author          = {Lin, Ying-Dar and Lai, Yuan-Cheng and Chen, Chien-Hung and Tsai, Hao-Chuan},
  title           = {{Identifying android malicious repackaged applications by thread-grained system call sequences}},
  journal         = {Computers {\&} Security},
  year            = {2013},
  volume          = {39},
  pages           = {340--350},
  issn            = {0167-4048},
  abstract        = {Android security has become highly desirable since adversaries can easily repackage malicious codes into various benign applications and spread these malicious repackaged applications (MRAs). Most MRA detection mechanisms on Android focus on detecting a specific family of MRAs or requiring the original benign application to compare with the malicious ones. This work proposes a new mechanism, SCSdroid (System Call Sequence Droid), which adopts the thread-grained system call sequences activated by applications. The concept is that even if MRAs can be camouflaged as benign applications, their malicious behavior would still appear in the system call sequences. SCSdroid extracts the truly malicious common subsequences from the system call sequences of MRAs belonging to the same family. Therefore, these extracted common subsequences can be used to identify any evaluated application without requiring the original benign application. Experimental results show that SCSdroid falsely detected only two applications among 100 evaluated benign applications, and falsely detected only one application among 49 evaluated malicious applications. As a result, SCSdroid achieved up to 95.97{\%} detection accuracy, i.e., 143 correct detections among 149 applications.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404813001272},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2013.08.010},
  doi             = {https://doi.org/10.1016/j.cose.2013.08.010},
  keywords        = {Android, Dynamic analysis, Longest common substring, System call,Malicious repackaged applications},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404813001272},
}

@Article{DEYPIR201820,
  author          = {Deypir, Mahmood and Horri, Abbas},
  title           = {{Instance based security risk value estimation for Android applications}},
  journal         = {Journal of Information Security and Applications},
  year            = {2018},
  volume          = {40},
  pages           = {20--30},
  issn            = {2214-2126},
  abstract        = {Android has emerged as the widest-used operating system for smartphones and mobile devices. Security of this platform mainly relies on applications (apps) installed by the device owner since permissions and sandboxing have reduced the attack surface. Android antivirus programs detect known malware based on their signature, but they cannot detect zero-day viruses. Therefore, estimating security risk could be helpful for comparing and selecting apps that are more likely to be malicious or benign based on the estimated risk values. Therefore, systematic assistance for making appropriate decisions can significantly improve the security of Android-based devices. Additionally, Android markets can leverage estimated risks to recognize suspicious apps for further analysis. In this study, a new metric is introduced for effective risk estimation of untrusted apps. While previously proposed risk measurements are based on features such as permissions and function calls, our devised metric benefits from previously known malicious and non-malicious app instances. The metric uses previously identified malware and normal app samples to compute the security risk of untrusted apps. Thus, previously known samples are represented in the feature space, and for each untrusted input app, the risk is estimated using distances to malicious and non-malicious app instances. Moreover, to increase the metric's detection rate, an instance and feature weighting schema is suggested. Empirical evaluations on various datasets show that the proposed instance-based metric has higher detection rates and is more effective than a previously proposed feature based on risk score measurements.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S2214212616300941},
  bdsk-url-2      = {https://doi.org/10.1016/j.jisa.2018.02.002},
  doi             = {https://doi.org/10.1016/j.jisa.2018.02.002},
  keywords        = {Decision making, Instance based risk metric, Malwares,Android security},
  url             = {http://www.sciencedirect.com/science/article/pii/S2214212616300941},
}

@Conference{Salva2013355,
  author          = {Salva, S and Zafimiharisoa, S R and Lauren{\c{c}}ot, P},
  title           = {{Intent security testing: An approach to testing the intent-based vulnerability of android components}},
  booktitle       = {ICETE 2013 - 10th International Joint Conference on E-Business and Telecommunications; SECRYPT 2013 - 10th International Conference on Security and Cryptography, Proceedings},
  year            = {2013},
  pages           = {355--362},
  abstract        = {The intent mechanism is a powerful feature of the Android platform that helps compose existing components together to build a Mobile application. However, hackers can leverage the intent messaging to extract personal data or to call components without credentials by sending malicious intents to components. This paper tackles this issue by proposing a security testing method which aims at detecting whether the components of an Android application are vulnerable to malicious intents. Our method takes Android projects and intent-based vulnerabilities formally represented with models called vulnerability patterns. The originality of our approach resides in the generation of partial specifications from configuration files and component codes to generate test cases. A tool, called APSET, is presented and evaluated with experimentations on some Android applications. Copyright {\textcopyright} 2013 SCITEPRESS.},
  annote          = {cited By 0},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84887752022%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=f5fec53831b10cd846e07beb2d30c33e},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84887752022{\&}partnerID=40{\&}md5=f5fec53831b10cd846e07beb2d30c33e},
}

@Article{Fang2015378,
  author          = {Fang, Z and Liu, Q and Zhang, Y and Wang, K and Wang, Z},
  title           = {{IVDroid: Static detection for input validation vulnerability in Android inter-component communication}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2015},
  volume          = {9065},
  pages           = {378--392},
  abstract        = {Input validation vulnerability in Android inter-component communication is a kind of severe vulnerabilities in Android apps. Malicious attacks can exploit the vulnerability to bypass Android security mechanism and compromise the integrity, confidentiality and availability of Android devices. However, so far there is not a sound approach at source code level designed for app developers to detect such vulnerabilities. In this paper we propose a novel approach aiming at detecting input validation flaws in Android apps and implement a prototype named IVDroid, which provides practical static analysis of Java source code. IVDroid leverages backward program slicing to abstract application logic from Java source code. On slice level, IVDroid detects flaws of known pattern by security rule matching and detects flaws of unknown pattern by duplicate validation behavior mining. Then IVDroid semi-automatically confirms the suspicious rule violations and report the confirmed ones as vulnerabilities. We evaluate IVDroid on 3 versions of Android spanning from version 2.2 to 4.4.2 and it detects 37 vulnerabilities including confused deputy and denial of service attack. Our results prove that IVDroid can provide a practical defence solution for app developers. {\textcopyright} Springer International Publishing Switzerland 2015.},
  annote          = {cited By 3},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-17533-1_26},
  doi             = {10.1007/978-3-319-17533-1_26},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942532162{\&}doi=10.1007{\%}2F978-3-319-17533-1{\_}26{\&}partnerID=40{\&}md5=1c3ba5eef42ddeff5cd683abb56f7e9d},
}

@Article{NAVARRO2018429,
  author          = {Navarro, Luiz C and Navarro, Alexandre K W and Gr{\'{e}}gio, Andr{\'{e}} and Rocha, Anderson and Dahab, Ricardo},
  title           = {{Leveraging ontologies and machine-learning techniques for malware analysis into Android permissions ecosystems}},
  journal         = {Computers {\&} Security},
  year            = {2018},
  volume          = {78},
  pages           = {429--453},
  issn            = {0167-4048},
  abstract        = {Smartphones form a complex application ecosystem with a myriad of components, properties, and interfaces that produce an intricate relationship network. Given the intrinsic complexity of this system, we hereby propose two main contributions. First, we devise a methodology to systematically determine and analyze the complex relationship network among components, properties, and interfaces associated with the permission mechanism in Android ecosystems. Second, we investigate whether it is possible to identify characteristics shared by malware samples at this high level of abstraction that could be leveraged to unveil their presence. We propose an ontology-based framework to model the relationships between application and system elements, together with a machine-learning approach to analyze the complex network that arises therefrom. We represent the ontological model for the considered Android ecosystem with 4570 apps through a graph with some 55,000 nodes and 120,000 edges. Experiments have shown that a classifier operating on top of this complex representation can achieve an accuracy of 88{\%} and precision of 91{\%} and is capable of identifying and determining 24 features that correspond to 70 important graph nodes related to malware activity, which is a remarkable feat for security.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404818302311},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2018.07.013},
  doi             = {https://doi.org/10.1016/j.cose.2018.07.013},
  keywords        = {Android permissions, Bags of graphs, Discriminant features, Machine learning, Ontology,Malware},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404818302311},
}

@Article{ISI:000343508700001,
  author          = {Ham, Hyo-Sik and Kim, Hwan-Hee and Kim, Myung-Sup and Choi, Mi-Jung},
  title           = {{Linear SVM-Based Android Malware Detection for Reliable IoT Services}},
  journal         = {JOURNAL OF APPLIED MATHEMATICS},
  year            = {2014},
  issn            = {1110-757X},
  abstract        = {Current many Internet of Things (IoT) services are monitored and
controlled through smartphone applications. By combining IoT with
smartphones, many convenient IoT services have been provided to users.
However, there are adverse underlying effects in such services including
invasion of privacy and information leakage. In most cases, mobile
devices have become cluttered with important personal user information
as various services and contents are provided through them. Accordingly,
attackers are expanding the scope of their attacks beyond the existing
PC and Internet environment into mobile devices. In this paper, we apply
a linear support vector machine (SVM) to detect Android malware and
compare the malware detection performance of SVM with that of other
machine learning classifiers. Through experimental validation, we show
that the SVM outperforms other machine learning classifiers.},
  bdsk-url-1      = {http://dx.doi.org/10.1155/2014/594501},
  doi             = {10.1155/2014/594501},
}

@Article{CHEN2018346,
  author          = {Chen, Zhenxiang and Yan, Qiben and Han, Hongbo and Wang, Shanshan and Peng, Lizhi and Wang, Lin and Yang, Bo},
  title           = {{Machine learning based mobile malware detection using highly imbalanced network traffic}},
  journal         = {Information Sciences},
  year            = {2018},
  volume          = {433-434},
  pages           = {346--364},
  issn            = {0020-0255},
  abstract        = {In recent years, the number and variety of malicious mobile apps have increased drastically, especially on Android platform, which brings insurmountable challenges for malicious app detection. Researchers endeavor to discover the traces of malicious apps using network traffic analysis. In this study, we combine network traffic analysis with machine learning methods to identify malicious network behavior, and eventually to detect malicious apps. However, most network traffic generated by malicious apps is benign, while only a small portion of traffic is malicious, leading to an imbalanced data problem when the traffic model skews towards modeling the benign traffic. To address this problem, we introduce imbalanced classification methods, including the synthetic minority oversampling technique (SMOTE) + support vector machine (SVM), SVM cost-sensitive (SVMCS), and C4.5 cost-sensitive (C4.5CS) methods. However, when the imbalance rate reaches a certain threshold, the performance of common imbalanced classification algorithms degrades significantly. To avoid performance degradation, we propose to use the imbalanced data gravitation-based classification (IDGC) algorithm to classify imbalanced data. Moreover, we develop a simplex imbalanced data gravitation classification (S-IDGC) model to further reduce the time costs of IDGC without sacrificing the classification performance. In addition, we propose a machine learning based comparative benchmark prototype system, which provides users with substantial autonomy, such as multiple choices of the desired classifiers or traffic features. Using this prototype system, users can compare the detection performance of different classification algorithms on the same data set, as well as the performance of a specific classification algorithm on multiple data sets.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0020025517307077},
  bdsk-url-2      = {https://doi.org/10.1016/j.ins.2017.04.044},
  doi             = {https://doi.org/10.1016/j.ins.2017.04.044},
  keywords        = {Imbalanced data, Machine learning, Malicious apps, Malware detection,Network traffic},
  url             = {http://www.sciencedirect.com/science/article/pii/S0020025517307077},
}

@Article{REHMAN2018828,
  author          = {Rehman, Zahoor-Ur and Khan, Sidra Nasim and Muhammad, Khan and Lee, Jong Weon and Lv, Zhihan and Baik, Sung Wook and Shah, Peer Azmat and Awan, Khalid and Mehmood, Irfan},
  title           = {{Machine learning-assisted signature and heuristic-based detection of malwares in Android devices}},
  journal         = {Computers {\&} Electrical Engineering},
  year            = {2018},
  volume          = {69},
  pages           = {828--841},
  issn            = {0045-7906},
  abstract        = {Malware detection is an important factor in the security of the smart devices. However, currently utilized signature-based methods cannot provide accurate detection of zero-day attacks and polymorphic viruses. In this context, an efficient hybrid framework is presented for detection of malware in Android Apps. The proposed framework considers both signature and heuristic-based analysis for Android Apps. We have reverse engineered the Android Apps to extract manifest files, and binaries, and employed state-of-the-art machine learning algorithms to efficiently detect malwares. For this purpose, a rigorous set of experiments are performed using various classifiers such as SVM, Decision Tree, W-J48 and KNN. It has been observed that SVM in case of binaries and KNN in case of manifest.xml files are the most suitable options in robustly detecting the malware in Android devices. The proposed framework is tested on benchmark datasets and results show improved accuracy in malware detection.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0045790617320256},
  bdsk-url-2      = {https://doi.org/10.1016/j.compeleceng.2017.11.028},
  doi             = {https://doi.org/10.1016/j.compeleceng.2017.11.028},
  keywords        = {Android applications, Heuristic analysis, Hybrid approach, Security,Malware detection},
  url             = {http://www.sciencedirect.com/science/article/pii/S0045790617320256},
}

@Article{KARBAB2018S48,
  author          = {Karbab, ElMouatez Billah and Debbabi, Mourad and Derhab, Abdelouahid and Mouheb, Djedjiga},
  title           = {{MalDozer: Automatic framework for android malware detection using deep learning}},
  journal         = {Digital Investigation},
  year            = {2018},
  volume          = {24},
  pages           = {S48 -- S59},
  issn            = {1742-2876},
  abstract        = {Android OS experiences a blazing popularity since the last few years. This predominant platform has established itself not only in the mobile world but also in the Internet of Things (IoT) devices. This popularity, however, comes at the expense of security, as it has become a tempting target of malicious apps. Hence, there is an increasing need for sophisticated, automatic, and portable malware detection solutions. In this paper, we propose MalDozer, an automatic Android malware detection and family attribution framework that relies on sequences classification using deep learning techniques. Starting from the raw sequence of the app's API method calls, MalDozer automatically extracts and learns the malicious and the benign patterns from the actual samples to detect Android malware. MalDozer can serve as a ubiquitous malware detection system that is not only deployed on servers, but also on mobile and even IoT devices. We evaluate MalDozer on multiple Android malware datasets ranging from 1 K to 33 K malware apps, and 38 K benign apps. The results show that MalDozer can correctly detect malware and attribute them to their actual families with an F1-Score of 96{\%}--99{\%} and a false positive rate of 0.06{\%}--2{\%}, under all tested datasets and settings.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1742287618300392},
  bdsk-url-2      = {https://doi.org/10.1016/j.diin.2018.01.007},
  doi             = {https://doi.org/10.1016/j.diin.2018.01.007},
  keywords        = {Android, Deep learning, IoT, Malware,Mobile},
  url             = {http://www.sciencedirect.com/science/article/pii/S1742287618300392},
}

@Article{Meng2016274,
  author          = {Meng, X and Spanoudakis, G},
  title           = {{MBotCS: A mobile botnet detection system based on machine learning}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2016},
  volume          = {9572},
  pages           = {274--291},
  abstract        = {As the use of mobile devices spreads dramatically, hackers have started making use of mobile botnets to steal user information or perform other malicious attacks. To address this problem, in this paper we propose a mobile botnet detection system, called MBotCS. MBotCS can detect mobile device traffic indicative of the presence of a mobile botnet based on prior training using machine learning techniques. Our approach has been evaluated using real mobile device traffic captured from Android mobile devices, running normal apps and mobile botnets. In the evaluation, we investigated the use of 5 machine learning classifier algorithms and a group of machine learning box algorithms with different validation schemes. We have also evaluated the effect of our approach with respect to its effect on the overall performance and battery consumption of mobile devices. {\textcopyright} Springer International Publishing Switzerland 2016},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-31811-0_17},
  doi             = {10.1007/978-3-319-31811-0_17},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84964547495{\&}doi=10.1007{\%}2F978-3-319-31811-0{\_}17{\&}partnerID=40{\&}md5=c9c855346570705b295aabd57c6ff9e5},
}

@Article{MOONSAMY2014122,
  author          = {Moonsamy, Veelasha and Rong, Jia and Liu, Shaowu},
  title           = {{Mining permission patterns for contrasting clean and malicious android applications}},
  journal         = {Future Generation Computer Systems},
  year            = {2014},
  volume          = {36},
  pages           = {122--132},
  issn            = {0167-739X},
  abstract        = {An Android application uses a permission system to regulate the access to system resources and users' privacy-relevant information. Existing works have demonstrated several techniques to study the required permissions declared by the developers, but little attention has been paid towards used permissions. Besides, no specific permission combination is identified to be effective for malware detection. To fill these gaps, we have proposed a novel pattern mining algorithm to identify a set of contrast permission patterns that aim to detect the difference between clean and malicious applications. A benchmark malware dataset and a dataset of 1227 clean applications has been collected by us to evaluate the performance of the proposed algorithm. Valuable findings are obtained by analyzing the returned contrast permission patterns.},
  annote          = {Special Section: Intelligent Big Data Processing Special Section: Behavior Data Security Issues in Network Information Propagation Special Section: Energy-efficiency in Large Distributed Computing Architectures Special Section: eScience Infrastructure and Applications},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X13001933},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2013.09.014},
  doi             = {https://doi.org/10.1016/j.future.2013.09.014},
  keywords        = {Biclustering, Contrast mining, Data mining, Permission pattern,Android permission},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X13001933},
}

@Article{SHARMA2018416,
  author          = {Sharma, Kavita and Gupta, B B},
  title           = {{Mitigation and risk factor analysis of android applications}},
  journal         = {Computers {\&} Electrical Engineering},
  year            = {2018},
  volume          = {71},
  pages           = {416--430},
  issn            = {0045-7906},
  abstract        = {Today, researchers face numerous challenges when attempting to identify malicious apps in the android market. Android apps require permissions to access the functionality of the mobile device. Moreover, these permissions can be used to know the app's behaviour. In this paper, we present a novel approach (called RNPDroid) for risk mitigation using the analysis of permissions. To evaluate the proposed approach, the M0Droid dataset is used, which consists of 400 Android app samples. All permissions of the obtained samples are analysed through reverse engineering, and total 165 permissions are attained. The computed value of F (517.3) is much higher than the tabulated value of F (2.61) at a 5{\%} level of significance. The analysis of variance (ANOVA) states that one of the risk factors is significantly different from others. Moreover, the t-test is used to show the significant difference between medium and low risk.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0045790618305494},
  bdsk-url-2      = {https://doi.org/10.1016/j.compeleceng.2018.08.003},
  doi             = {https://doi.org/10.1016/j.compeleceng.2018.08.003},
  keywords        = {Android app analysis, Data leakage, Malicious app classification, Reverse engineering, Risk analysis,Android permission},
  url             = {http://www.sciencedirect.com/science/article/pii/S0045790618305494},
}

@Article{Armando2014103,
  author          = {Armando, A and Bocci, G and Chiarelli, G and Costa, G and {De Maglie}, G and Mammoliti, R and Merlo, A},
  title           = {{Mobile app security analysis with the MAVeriC static analysis}},
  journal         = {Journal of Wireless Mobile Networks, Ubiquitous Computing, and Dependable Applications},
  year            = {2014},
  volume          = {5},
  number          = {4},
  pages           = {103--119},
  abstract        = {The success of the mobile application model is mostly due to the ease with which new applications are uploaded by developers, distributed through the application markets (e.g. Google Play), and installed by users. Yet, the very same model is cause of serious security concerns, since users have no or little means to ascertain the trustworthiness of the applications they install on their devices. Such concerns grow up when dealing with professional scenarios like the use of mobile devices within organisations. To protect their customers, Poste Italiane has defined the Mobile Application Verification Cluster (MAVeriC), a process for the systematic security analysis of third-party mobile apps leveraging their online services (e.g. home banking, parcel tracking). MAVeriC is an ongoing project that will be completed in the next few years. At the core of the MAVeriC project lies the Static Analysis Module (SAM), a toolkit that supports automatic static analysis of mobile applications by automating a number of operations including reverse engineering, privilege analysis and automatic verification of security properties. In this paper we present the SAM that has been fully developed and tested. We introduce the functionalities of SAM through a demonstration of the platform applied to real Android applications. {\textcopyright} 2014 Innovative Information Science and Technology Research Group. All rights reserved.},
  annote          = {cited By 5},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84920192515%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=d5ccf21836b9eecf61c2e489aef498cd},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84920192515{\&}partnerID=40{\&}md5=d5ccf21836b9eecf61c2e489aef498cd},
}

@Conference{Mendoza2018756,
  author          = {Mendoza, A and Gu, G},
  title           = {{Mobile Application Web API Reconnaissance: Web-to-Mobile Inconsistencies {\&} Vulnerabilities}},
  booktitle       = {Proceedings - IEEE Symposium on Security and Privacy},
  year            = {2018},
  volume          = {2018-May},
  pages           = {756--769},
  abstract        = {Modern mobile apps use cloud-hosted HTTP-based API services and heavily rely on the Internet infrastructure for data communication and storage. To improve performance and leverage the power of the mobile device, input validation and other business logic required for interfacing with web API services are typically implemented on the mobile client. However, when a web service implementation fails to thoroughly replicate input validation, it gives rise to inconsistencies that could lead to attacks that can compromise user security and privacy. Developing automatic methods of auditing web APIs for security remains challenging. In this paper, we present a novel approach for automatically analyzing mobile app-to-web API communication to detect inconsistencies in input validation logic between apps and their respective web API services. We present our system, WARDroid, which implements a static analysis-based web API reconnaissance approach to uncover inconsistencies on real world API services that can lead to attacks with severe consequences for potentially millions of users throughout the world. Our system utilizes program analysis techniques to automatically extract HTTP communication templates from Android apps that encode the input validation constraints imposed by the apps on outgoing web requests to web API services. WARDroid is also enhanced with blackbox testing of server validation logic to identify inconsistencies that can lead to attacks. We evaluated our system on a set of 10,000 popular free apps from the Google Play Store. We detected problematic logic in APIs used in over 4,000 apps, including 1,743 apps that use unencrypted HTTP communication. We further tested 1,000 apps to validate web API hijacking vulnerabilities that can lead to potential compromise of user privacy and security and found that millions of users are potentially affected from our sample set of tested apps. {\textcopyright} 2018 IEEE.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1109/SP.2018.00039},
  doi             = {10.1109/SP.2018.00039},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051003743{\&}doi=10.1109{\%}2FSP.2018.00039{\&}partnerID=40{\&}md5=d67a4f9a38e0a37326d2fc51769b8d88},
}

@Article{Kim2012158,
  author          = {Kim, H.-K.},
  title           = {{Mobile applications software testing methodology}},
  journal         = {Communications in Computer and Information Science},
  year            = {2012},
  volume          = {342 CCIS},
  pages           = {158--166},
  abstract        = {Today's Mobile Applications deliver complex functionality on platforms that have limited resources for computing. Yet, unlike the PC-based environment, the Mobile environment comprises a number of devices with diverse hardware and software configurations and communication intricacies. This diversity in mobile computing environments presents unique challenges in mobile application development, quality assurance, and deployment, requiring unique testing strategies. Many enterprise applications that were deployed as desktop/web applications are now being ported to Mobile devices. In this paper, we have constructed the Mobile Applications Quality Assurance Tool(MAQAT) by integrating tools and prototype systems that we built for program analysis and testing for mobile applications software. MAQAS provides a architecture of program analysis and testing for mobile, and supports many program-analysis-based techniques, including automated mobile applications software inspection, software visualization, testing coverage analysis, performance evaluation, concurrent program debugging, software measurement, etc. The paper briefly describes the overall architecture of MAQAS, and introduces the implementation of its tools and components. {\textcopyright} 2012 Springer-Verlag Berlin Heidelberg.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-642-35270-6_22},
  doi             = {10.1007/978-3-642-35270-6_22},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84869803721{\&}doi=10.1007{\%}2F978-3-642-35270-6{\_}22{\&}partnerID=40{\&}md5=5421f4bd3b687e9afcd88eca93fdc661},
}

@Article{SHABTAI20141,
  author          = {Shabtai, A and Tenenboim-Chekina, L and Mimran, D and Rokach, L and Shapira, B and Elovici, Y},
  title           = {{Mobile malware detection through analysis of deviations in application network behavior}},
  journal         = {Computers {\&} Security},
  year            = {2014},
  volume          = {43},
  pages           = {1--18},
  issn            = {0167-4048},
  abstract        = {In this paper we present a new behavior-based anomaly detection system for detecting meaningful deviations in a mobile application's network behavior. The main goal of the proposed system is to protect mobile device users and cellular infrastructure companies from malicious applications by: (1) identification of malicious attacks or masquerading applications installed on a mobile device, and (2) identification of republished popular applications injected with a malicious code (i.e., repackaging). More specifically, we attempt to detect a new type of mobile malware with self-updating capabilities that were recently found on the official Google Android marketplace. Malware of this type cannot be detected using the standard signatures approach or by applying regular static or dynamic analysis methods. The detection is performed based on the application's network traffic patterns only. For each application, a model representing its specific traffic pattern is learned locally (i.e., on the device). Semi-supervised machine-learning methods are used for learning the normal behavioral patterns and for detecting deviations from the application's expected behavior. These methods were implemented and evaluated on Android devices. The evaluation experiments demonstrate that: (1) various applications have specific network traffic patterns and certain application categories can be distinguished by their network patterns; (2) different levels of deviation from normal behavior can be detected accurately; (3) in the case of self-updating malware, original (benign) and infected versions of an application have different and distinguishable network traffic patterns that in most cases, can be detected within a few minutes after the malware is executed while presenting very low false alarms rate; and (4) local learning is feasible and has a low performance overhead on mobile devices.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404814000285},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2014.02.009},
  doi             = {https://doi.org/10.1016/j.cose.2014.02.009},
  keywords        = {Android malware, Anomaly detection, Machine learning, Network traffic, Smartphone security,Mobile applications},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404814000285},
}

@Article{Haller:2013:MT:2532780.2532813,
  author          = {Haller, Klaus},
  title           = {{Mobile Testing}},
  journal         = {SIGSOFT Softw. Eng. Notes},
  year            = {2013},
  volume          = {38},
  number          = {6},
  pages           = {1--8},
  issn            = {0163-5948},
  address         = {New York, NY, USA},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2532780.2532813},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2532780.2532813},
  doi             = {10.1145/2532780.2532813},
  keywords        = {mobile devices, software quality management, software testing, test automation, test strategy,mobile apps},
  publisher       = {ACM},
  url             = {http://doi.acm.org/10.1145/2532780.2532813},
}

@Conference{Ferrara2015371,
  author          = {Ferrara, P and Tripp, O and Pistoia, M},
  title           = {{MORPHDROID: Fine-grained privacy verification}},
  booktitle       = {ACM International Conference Proceeding Series},
  year            = {2015},
  volume          = {7-11-December-2015},
  pages           = {371--380},
  abstract        = {Mobile devices are rich in sensors, such as a Global Positioning System (GPS) tracker, microphone and camera, and have access to numerous sources of personal information, including the device ID, contacts and social data. This richness increases the functionality of mobile apps, but also creates privacy threats. As a result, different solutions have been proposed to verify or enforce privacy policies. A key limitation of existing approaches is that they reason about privacy at a coarse level, without accounting for declassification rules, such that the location for instance is treated as a single unit of information without reference to its many fields. As a result, legitimate app behaviors - such as releasing the user's city rather than exact address-are perceived as privacy violations, rendering existing analyses overly conservative and thus of limited usability. In this paper, we present MORPHDROID, a novel static analysis algorithm that verifies mobile applications against fine-grained privacy policies. Such policies define constraints over combinations of fine-grained units of private data. Specifically, through a novel design, MORPHDROID tracks flows of fine-grained privacy units while addressing important challenges, including (i) detection of correlations between different units (e.g. longitude and latitude) and (ii) modeling of semantic transformations over private data (e.g. conversion of the location into an address). We have implemented MORPHDROID, and present a thorough experimental evaluation atop a comprehensive benchmark suite for Android static and dynamic analyses (DroidBench), as well as the 500 top-popular Google Play applications in 2014. Our experiments involve a spectrum of 5 security policies, ranging from a strict coarse-grained policy to a more realistic fine-grained policy that accounts for declassification rules. The experiment on DroidBench shows that MORPHDROID achieves precision and recall scores of over 90{\%}. The experiments on popular apps show that the gap between policies is dramatic, the most conservative policy yielding warnings on 171 of the applications (34{\%}), and the more realistic policy flagging only 4 of the applications as misbehaved ({\textless} 1{\%}). In addition, MORPHDROID exhibits good performance with an average analysis time of {\textless} 20 seconds, where on average apps consist of 1.4M lines of code. {\textcopyright} 2015 ACM.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2818000.2818037},
  doi             = {10.1145/2818000.2818037},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84969213486{\&}doi=10.1145{\%}2F2818000.2818037{\&}partnerID=40{\&}md5=0a635aff30ff87979e6a831c98bbc3ad},
}

@InProceedings{7928006,
  author          = {Tang, J and Cui, X and Zhao, Z and Guo, S and Xu, X and Hu, C and Ban, T and Mao, B},
  title           = {{NIVAnalyzer: A Tool for Automatically Detecting and Verifying Next-Intent Vulnerabilities in Android Apps}},
  booktitle       = {2017 IEEE International Conference on Software Testing, Verification and Validation (ICST)},
  year            = {2017},
  pages           = {492--499},
  abstract        = {In the Android system design, any app can start another app's public components to facilitate code reuse by sending an asynchronous message called Intent. In addition, Android also allows an app to have private components that should only be visible to the app itself. However, malicious apps can bypass this system protection and directly invoke private components in vulnerable apps through a class of newly discovered vulnerability, which is called next-intent vulnerability. In this paper, we design an intent flow analysis strategy which accurately tracks the intent in smali code to statically detect next-intent vulnerabilities efficiently and effectively on a large scale. We further propose an automated approach to dynamically verify the discovered vulnerabilities by generating exploit apps. Then we implement a tool named NIVAnalyzer and evaluate it on 20,000 apps downloaded from Google Play. As the result, we successfully confirms 190 vulnerable apps, some of which even have millions of downloads. We also confirmed that an open-source project and a third-party SDK, which are still used by other apps, have next intent vulnerabilities.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICST.2017.56},
  doi             = {10.1109/ICST.2017.56},
  keywords        = {Android (operating system);program diagnostics;security of data;NIVAnalyzer;next-intent vulnerabilities;Android apps;Android system design;code reuse;asynchronous message;malicious apps;intent flow analysis strategy;exploit apps;Google Play;third-party SDK;open-source project;static analysis;dynamic analysis;Registers;Androids;Humanoid robots;Electronic mail;Target tracking;Tools;Facebook;Android;Intent;vulnerability;static and dynamic analysis;tool},
}

@Article{Chen2016326,
  author          = {Chen, W and Aspinall, D and Gordon, A D and Sutton, C and Muttik, I},
  title           = {{On robust malware classifiers by verifying unwanted behaviours}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2016},
  volume          = {9681},
  pages           = {326--341},
  abstract        = {Machine-learning-based Android malware classifiers perform badly on the detection of new malware, in particular, when they take API calls and permissions as input features, which are the best performing features known so far. This is mainly because signature-based features are very sensitive to the training data and cannot capture general behaviours of identified malware. To improve the robustness of classifiers, we study the problem of learning and verifying unwanted behaviours abstracted as automata. They are common patterns shared by malware instances but rarely seen in benign applications, e.g., intercepting and forwarding incoming SMS messages. We show that by taking the verification results against unwanted behaviours as input features, the classification performance of detecting new malware is improved dramatically. In particular, the precision and recall are respectively 8 and 51 points better than those using API calls and permissions, measured against industrial datasets collected across several years. Our approach integrates several methods: formal methods, machine learning and text mining techniques. It is the first to automatically generate unwanted behaviours for Android malware detection. We also demonstrate unwanted behaviours constructed for well-known malware families. They compare well to those described in human-authored descriptions of these families. {\textcopyright} Springer International Publishing Switzerland 2016.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-33693-0_21},
  doi             = {10.1007/978-3-319-33693-0_21},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84977470909{\&}doi=10.1007{\%}2F978-3-319-33693-0{\_}21{\&}partnerID=40{\&}md5=2a6580bd6adcd79134462fd73827919e},
}

@Article{Dmitrienko2014365,
  author          = {Dmitrienko, A and Liebchen, C and Rossow, C and Sadeghi, A.-R.},
  title           = {{On the (in)security of mobile two-factor authentication}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2014},
  volume          = {8437},
  pages           = {365--383},
  abstract        = {Two-factor authentication (2FA) schemes aim at strengthening the security of login password-based authentication by deploying secondary authentication tokens. In this context, mobile 2FA schemes require no additional hardware (e.g., a smartcard) to store and handle the secondary authentication token, and hence are considered as a reasonable trade-off between security, usability and costs. They are widely used in online banking and increasingly deployed by Internet service providers. In this paper, we investigate 2FA implementations of several well-known Internet service providers such as Google, Dropbox, Twitter and Facebook. We identify various weaknesses that allow an attacker to easily bypass them, even when the secondary authentication token is not under attacker's control. We then go a step further and present a more general attack against mobile 2FA schemes. Our attack relies on cross-platform infection that subverts control over both end points (PC and a mobile device) involved in the authentication protocol. We apply this attack in practice and successfully circumvent diverse schemes: SMSbased TAN solutions of four large banks, one instance of a visual TAN scheme, 2FA login verification systems of Google, Dropbox, Twitter and Facebook accounts, and the Google Authenticator app currently used by 32 third-party service providers. Finally, we cluster and analyze hundreds of real-world malicious Android apps that target mobile 2FA schemes and show that banking Trojans already deploy mobile counterparts that steal 2FA credentials like TANs. {\textcopyright} International Financial Cryptography Association 2014.},
  annote          = {cited By 13},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-662-45472-5_24},
  doi             = {10.1007/978-3-662-45472-5_24},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84916597460{\&}doi=10.1007{\%}2F978-3-662-45472-5{\_}24{\&}partnerID=40{\&}md5=a38cc01be91b433396c396973a0eb0fd},
}

@Conference{Grassi2005107,
  author          = {Grassi, V},
  title           = {{Performance analysis of mobile systems}},
  booktitle       = {Lecture Notes in Computer Science},
  year            = {2005},
  volume          = {3465},
  pages           = {107--154},
  abstract        = {Mobile systems, where both computing nodes and software components can dynamically change their location, are already a reality, thanks to technological advances in several related fields. The high variability and heterogeneity of these systems raises severe performance problems, thus requiring a careful planning of any performance validation activity concerning these systems. This paper reviews some approaches that have been proposed to this end, presenting them within a general framework aimed at supporting a systematic approach to the validation of non functional attributes. In this framework we emphasize that one of the key points for the actual and effective introduction of non-functional attributes validation since the early design phases is the definition of model-based transformations from design-oriented models to analysis-oriented models. {\textcopyright} Springer-Verlag Berlin Heidelberg 2005.},
  annote          = {cited By 1},
  bdsk-url-1      = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-24944580883%7B%5C&%7DpartnerID=40%7B%5C&%7Dmd5=bed1ba6d9c958f71c4133577a8b9d0d6},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-24944580883{\&}partnerID=40{\&}md5=bed1ba6d9c958f71c4133577a8b9d0d6},
}

@Article{Espada2017,
  author          = {Espada, A R and Gallardo, M D M and Salmer{\'{o}}n, A and Merino, P},
  title           = {{Performance Analysis of Spotify{\textregistered} for Android with Model-Based Testing}},
  journal         = {Mobile Information Systems},
  year            = {2017},
  volume          = {2017},
  abstract        = {This paper presents the foundations and the real use of a tool to automatically detect anomalies in Internet traffic produced by mobile applications. In particular, our MVE tool is focused on analyzing the impact that user interactions have on the traffic produced and received by the smartphones. To make the analysis exhaustive with regard to the potential user behaviors, we follow a model-based approach to automatically generate test cases to be executed on the smartphones. In addition, we make use of a specification language to define traffic patterns to be compared with the actual traffic in the device. MVE also includes monitoring and verification support to detect executions that do not fit the patterns. In these cases, the developer will obtain detailed information on the user actions that produce the anomaly in order to improve the application. To validate the approach, the paper presents an experimental study with the well-known Spotify app for Android, in which we detected some interesting behaviors. For instance, some HTTP connections do not end successfully due to timeout errors from the remote Spotify service. {\textcopyright} 2017 Ana Rosario Espada et al.},
  annote          = {cited By 3},
  bdsk-url-1      = {http://dx.doi.org/10.1155/2017/2012696},
  doi             = {10.1155/2017/2012696},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85014163603{\&}doi=10.1155{\%}2F2017{\%}2F2012696{\&}partnerID=40{\&}md5=e07a3faa51dbc62c4999e712745b9646},
}

@Article{CALLEJA2018113,
  author          = {Calleja, Alejandro and Mart{\'{i}}n, Alejandro and Men{\'{e}}ndez, H{\'{e}}ctor D and Tapiador, Juan and Clark, David},
  title           = {{Picking on the family: Disrupting android malware triage by forcing misclassification}},
  journal         = {Expert Systems with Applications},
  year            = {2018},
  volume          = {95},
  pages           = {113--126},
  issn            = {0957-4174},
  abstract        = {Machine learning classification algorithms are widely applied to different malware analysis problems because of their proven abilities to learn from examples and perform relatively well with little human input. Use cases include the labelling of malicious samples according to families during triage of suspected malware. However, automated algorithms are vulnerable to attacks. An attacker could carefully manipulate the sample to force the algorithm to produce a particular output. In this paper we discuss one such attack on Android malware classifiers. We design and implement a prototype tool, called IagoDroid, that takes as input a malware sample and a target family, and modifies the sample to cause it to be classified as belonging to this family while preserving its original semantics. Our technique relies on a search process that generates variants of the original sample without modifying their semantics. We tested IagoDroid against RevealDroid, a recent, open source, Android malware classifier based on a variety of static features. IagoDroid successfully forces misclassification for 28 of the 29 representative malware families present in the DREBIN dataset. Remarkably, it does so by modifying just a single feature of the original malware. On average, it finds the first evasive sample in the first search iteration, and converges to a 100{\%} evasive population within 4 iterations. Finally, we introduce RevealDroid*, a more robust classifier that implements several techniques proposed in other adversarial learning domains. Our experiments suggest that RevealDroid* can correctly detect up to 99{\%} of the variants generated by IagoDroid.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0957417417307881},
  bdsk-url-2      = {https://doi.org/10.1016/j.eswa.2017.11.032},
  doi             = {https://doi.org/10.1016/j.eswa.2017.11.032},
  keywords        = {Adversarial learning, Genetic algorithms, Iagodroid,Malware classification},
  url             = {http://www.sciencedirect.com/science/article/pii/S0957417417307881},
}

@Article{Costa2017407,
  author          = {Costa, G and Sinigaglia, F and Carbone, R},
  title           = {{PolEnA: Enforcing fine-grained permission policies in android}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2017},
  volume          = {10489 LNCS},
  pages           = {407--414},
  abstract        = {In this paper we present PolEnA, an extension of the Android Security Framework (ASF). PolEnA enables a number of features that are not currently provided by the ASF. Among them, PolEnA allows for the definition of fine-grained security policies and their dynamic verification. The runtime enforcement of the policies is supported by a state-of-the-art SAT solver. One of the main features of our approach is the low invasiveness as it does not require modifications to the operating system. {\textcopyright} Springer International Publishing AG 2017.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-66284-8_34},
  doi             = {10.1007/978-3-319-66284-8_34},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85029485146{\&}doi=10.1007{\%}2F978-3-319-66284-8{\_}34{\&}partnerID=40{\&}md5=35d5f617bf9c842799f0d18017cf2858},
}

@InProceedings{7579768,
  author          = {Bagheri, H and Sadeghi, A and Jabbarvand, R and Malek, S},
  title           = {{Practical, Formal Synthesis and Automatic Enforcement of Security Policies for Android}},
  booktitle       = {2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)},
  year            = {2016},
  pages           = {514--525},
  abstract        = {As the dominant mobile computing platform, Android has become a prime target for cyber-security attacks. Many of these attacks are manifested at the application level, and through the exploitation of vulnerabilities in apps downloaded from the popular app stores. Increasingly, sophisticated attacks exploit the vulnerabilities in multiple installed apps, making it extremely difficult to foresee such attacks, as neither the app developers nor the store operators know a priori which apps will be installed together. This paper presents an approach that allows the end-users to safeguard a given bundle of apps installed on their device from such attacks. The approach, realized in a tool, called SEPAR, combines static analysis with lightweight formal methods to automatically infer security-relevant properties from a bundle of apps. It then uses a constraint solver to synthesize possible security exploits, from which fine-grained security policies are derived and automatically enforced to protect a given device. In our experiments with over 4,000 Android apps, SEPAR has proven to be highly effective at detecting previously unknown vulnerabilities as well as preventing their exploitation.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/DSN.2016.53},
  doi             = {10.1109/DSN.2016.53},
  issn            = {2158-3927},
  keywords        = {Android (operating system);formal specification;formal verification;mobile computing;program diagnostics;security of data;formal synthesis;security policies automatic enforcement;mobile computing platform;cyber-security attacks;sophisticated attacks;SEPAR;static analysis;lightweight formal methods;security-relevant properties;constraint solver;Android apps;vulnerabilities detection;Security;Androids;Humanoid robots;Smart phones;Software;Analytical models;Metals},
}

@Article{ISI:000383055100004,
  author          = {Qian, Ju and Zhou, Di},
  title           = {{Prioritizing Test Cases for Memory Leaks in Android Applications}},
  journal         = {Journal of Computer Science and Technology},
  year            = {2016},
  volume          = {31},
  number          = {5},
  pages           = {869--882},
  issn            = {1000-9000},
  abstract        = {Mobile applications usually can only access limited amount of memory. Improper use of the memory can cause memory leaks, which may lead to performance slowdowns or even cause applications to be unexpectedly killed. Although a large body of research has been devoted into the memory leak diagnosing techniques after leaks have been discovered, it is still challenging to find out the memory leak phenomena at first. Testing is the most widely used technique for failure discovery. However, traditional testing techniques are not directed for the discovery of memory leaks. They may spend lots of time on testing unlikely leaking executions and therefore can be inefficient. To address the problem, we propose a novel approach to prioritize test cases according to their likelihood to cause memory leaks in a given test suite. It firstly builds a prediction model to determine whether each test can potentially lead to memory leaks based on machine learning on selected code features. Then, for each input test case, we partly run it to get its code features and predict its likelihood to cause leaks. The most suspicious test cases will be suggested to run at first in order to reveal memory leak faults as soon as possible. Experimental evaluation on several Android applications shows that our approach is effective. {\textcopyright} 2016, Springer Science+Business Media New York.},
  annote          = {From Duplicate 2 (Prioritizing Test Cases for Memory Leaks in Android Applications - Qian, J; Zhou, D) cited By 5},
  bdsk-url-1      = {http://dx.doi.org/10.1007/s11390-016-1670-2},
  doi             = {10.1007/s11390-016-1670-2},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84984868155{\&}doi=10.1007{\%}2Fs11390-016-1670-2{\&}partnerID=40{\&}md5=d5d8baaadff61544bc7e327737b51ab9},
}

@Article{SONG2018663,
  author          = {Song, Jun and Gao, Kun and Shen, Xinyang and Qi, Xiaotian and Liu, Rui and Choo, Kim-Kwang Raymond},
  title           = {{QRFence: A flexible and scalable QR link security detection framework for Android devices}},
  journal         = {Future Generation Computer Systems},
  year            = {2018},
  volume          = {88},
  pages           = {663--674},
  issn            = {0167-739X},
  abstract        = {Android security is an ongoing topic of interest to both the research community and industry, particularly as the mobile threat landscape evolves. A threat that has yet to be resolved is malicious link dissemination via QR codes, and such codes are widely used by mobile users in countries such as China. Thus, this paper proposes a threat-oriented QR malicious link detection framework, QRFence, based on a novel machine learning-based link threat-degree evaluation model. Specifically, QRFence comprises a QR malicious link detection scheme and an integrated permission detection scheme, and provides the following properties: multiple classification algorithms, extensive training features and various permission combinations. The proposed framework is independent of the security detection plugin, and performs threat evaluation on the QR links during decoding; therefore, allowing users to understand potential threats of malicious links on-the-fly. Findings from our evaluations indicate that the average accuracy rate of this proposed QR link detection framework is 93.20{\%}.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X17324160},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2018.05.082},
  doi             = {https://doi.org/10.1016/j.future.2018.05.082},
  keywords        = {Android security, Machine learning, Malicious link, Threat degree,QR code},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X17324160},
}

@Conference{Backes2016129,
  author          = {Backes, M and Bugiel, S and Derr, E and Gerling, S and Hammer, C},
  title           = {{R-Droid: Leveraging android app analysis with static slice optimization}},
  booktitle       = {ASIA CCS 2016 - Proceedings of the 11th ACM Asia Conference on Computer and Communications Security},
  year            = {2016},
  pages           = {129--140},
  abstract        = {Today's feature-rich smartphone apps intensively rely on access to highly sensitive (personal) data. This puts the user's privacy at risk of being violated by overly curious apps or libraries (like advertisements). Central app markets conceptually represent a first line of defense against such invasions of the user's privacy, but unfortunately we are still lacking full support for automatic analysis of apps' internal data flows and supporting analysts in statically assessing apps' behavior. In this paper we present a novel slice-optimization approach to leverage static analysis of Android applications. Building on top of precise application lifecycle models, we employ a slicing-based analysis to generate data-dependent statements for arbitrary points of interest in an application. As a result of our optimization, the produced slices are, on average, 49{\%} smaller than standard slices, thus facilitating code understanding and result validation by security analysts. Moreover, by re-targeting strings, our approach enables automatic assessments for a larger number of use-cases than prior work. We consolidate our improvements on statically analyzing Android apps into a tool called R-Droid and conducted a large-scale data-leak analysis on a set of 22,700 Android apps from Google Play. R-Droid managed to identify a significantly larger set of potential privacy-violating information flows than previous work, including 2,157 sensitive flows of password-flagged UI widgets in 256 distinct apps. {\textcopyright} 2016 ACM.},
  annote          = {cited By 11},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2897845.2897927},
  doi             = {10.1145/2897845.2897927},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84979696970{\&}doi=10.1145{\%}2F2897845.2897927{\&}partnerID=40{\&}md5=00f5b9341f6071dc084d4ec12e51bf49},
}

@InProceedings{7784627,
  author          = {Mercaldo, F and Nardone, V and Santone, A},
  title           = {{Ransomware Inside Out}},
  booktitle       = {2016 11th International Conference on Availability, Reliability and Security (ARES)},
  year            = {2016},
  pages           = {628--637},
  abstract        = {Android is currently the most widely used mobile environment. This trend encourages malware writers to develop specific attacks targeting this platform with threats designed to covertly collect data or financially extort victims, the so-called ransomware. In this paper we use formal methods, in particular model checking, to automatically dissect ransomware samples. Starting from manual inspection of few samples, we define a set of rule in order to check whether the behaviours we find are representative of ransomware functionalities.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ARES.2016.35},
  doi             = {10.1109/ARES.2016.35},
  keywords        = {formal verification;invasive software;mobile computing;smart phones;ransomware functionality;Android;mobile environment;malware;formal method;model checking;Malware;Smart phones;Java;Mobile communication;Model checking;Androids;Humanoid robots;formal methods;ransomware;security;malware;Android},
}

@InProceedings{ISI:000379297600014,
  author          = {Mercaldo, Francesco and Nardone, Vittoria and Santone, Antonella and Visaggio, Corrado Aaron},
  title           = {{Ransomware Steals Your Phone. Formal Methods Rescue It}},
  booktitle       = {FORMAL TECHNIQUES FOR DISTRIBUTED OBJECTS, COMPONENTS, AND SYSTEMS (FORTE 2016)},
  year            = {2016},
  editor          = {{Albert, E and Lanese, I}},
  volume          = {9688},
  series          = {Lecture Notes in Computer Science},
  pages           = {212--221},
  organization    = {IFIP WG 6 1; Fdn Res {\&} Technol, Inst Comp Sci; Univ Ioannina},
  abstract        = {Ransomware is a recent type of malware which makes inaccessible the
files or the device of the victim. The only way to unlock the infected
device or to have the keys for decrypting the files is to pay a ransom
to the attacker. Commercial solutions for removing ransomware and
restoring the infected devices and files are ineffective, since this
malware uses a very robust form of asymmetric cryptography and erases
shadow copies and recovery points of the operating system. Literature
does not count many solutions for effectively detecting and blocking
ransomware and, at the best knowledge of the authors, formal methods
were never applied to identify ransomware. In this paper we propose a
methodology based on formal methods that is able to detect the
ransomware and to identify in the malware's code the instructions that
implement the characteristic instructions of the ransomware. The results
of the experimentation are strongly encouraging and suggest that the
proposed methodology could be the right way to follow for developing
commercial solutions that could successful intercept the ransomware and
blocking the infections it provokes.},
  annote          = {36th IFIP WG 6.1 International Conference on Formal Techniques for Distributed Objects, Components and Systems(FORTE) held as part of the 11th International Federated Conference on Distributed Computing Techniques (DisCoTec), Heraklion, GREECE, JUN 05-07, 2016},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-39570-8_14},
  doi             = {10.1007/978-3-319-39570-8_14},
  isbn            = {978-3-319-39570-8; 978-3-319-39569-2},
  issn            = {0302-9743},
}

@Article{GURULIAN2018537,
  author          = {Gurulian, Iakovos and Markantonakis, Konstantinos and Cavallaro, Lorenzo and Mayes, Keith},
  title           = {{Reprint of ``You can't touch this: Consumer-centric android application repackaging detection''}},
  journal         = {Future Generation Computer Systems},
  year            = {2018},
  volume          = {80},
  pages           = {537--545},
  issn            = {0167-739X},
  abstract        = {Application repackaging is a widely used method for malware distribution, revenue stealing and piracy. Repackaged applications are modified versions of original applications, that can potentially target large audiences based on the original application's popularity. In this paper, we propose an approach for detecting repackaged applications. Our approach takes advantage of the attacker's reluctance to significantly alter the elements that characterise an application without notably impacting the application's distribution. These elements include the application's name and icon. The detection is initiated from the client side, prior to an application's installation, making it application store agnostic. Our experimental results show that detection based on our algorithm is effective and efficient.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X17325451},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2017.11.011},
  doi             = {https://doi.org/10.1016/j.future.2017.11.011},
  keywords        = {Application repackaging, Effectiveness analysis, Electronic fraud, User privacy, User-centric security,Android},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X17325451},
}

@Article{DINI2018505,
  author          = {Dini, Gianluca and Martinelli, Fabio and Matteucci, Ilaria and Petrocchi, Marinella and Saracino, Andrea and Sgandurra, Daniele},
  title           = {{Risk analysis of Android applications: A user-centric solution}},
  journal         = {Future Generation Computer Systems},
  year            = {2018},
  volume          = {80},
  pages           = {505--518},
  issn            = {0167-739X},
  abstract        = {Android applications (apps) pose many risks to their users, e.g., by including code that may threaten user privacy or system integrity. Most of the current security countermeasures for detecting dangerous apps show some weaknesses, mainly related to users' understanding and acceptance. Hence, users would benefit from an effective but simple technique that indicates whether an app is safe or risky to be installed. In this paper, we present MAETROID (Multi-criteria App Evaluator of TRust for AndrOID), a framework to evaluate the trustworthiness of Android apps, i.e., the amount of risk they pose to users, e.g., in terms of confidentiality and integrity. MAETROID performs a multi-criteria analysis of an app at deploy-time and returns a single easy-to-understand evaluation of the app's risk level (i.e., Trusted, Medium Risk, and High Risk), aimed at driving the user decision on whether or not installing a new app. The criteria include the set of requested permissions and a set of metadata retrieved from the marketplace, denoting the app quality and popularity. We have tested MAETROID on a set of 11,000 apps both coming from Google Play and from a database of known malicious apps. The results show a good accuracy in both identifying the malicious apps and in terms of false positive rate.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X16301534},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2016.05.035},
  doi             = {https://doi.org/10.1016/j.future.2016.05.035},
  keywords        = {Malware, Risk analysis, Usability, User experience and expectations, User-centric devices,Android security},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X16301534},
}

@Article{Falcone201388,
  author          = {Falcone, Y and Currea, S and Jaber, M},
  title           = {{Runtime verification and enforcement for android applications with RV-droid}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2013},
  volume          = {7687 LNCS},
  pages           = {88--95},
  abstract        = {RV-Droid is an implemented framework dedicated to runtime verification (RV) and runtime enforcement (RE) of Android applications. RV-Droid consists of an Android application that interacts closely with a cloud. Running RV-Droid on their devices, users can select targeted Android applications from Google Play (or a dedicated repository) and a property. The cloud hosts third-party RV tools that are used to synthesize AspectJ aspects from the property. According to the chosen RV tool and the specification, some appropriate monitoring code, the original application and the instrumentation aspect are woven together. Weaving can occur either on the user's device or in the dedicated cloud. The woven application is then retrieved and executed on the user's device and the property is runtime verified. RV-Droid is generic and currently works with two existing runtime verification frameworks for (pure) Java programs: with Java-MOP and (partially) with RuleR. RV-Droid does not require any modification to the Android kernel and targeted applications can be retrieved off-the-shelf. We carried out several experiments that demonstrated the effectiveness of RV-Droid on monitoring (security) properties. {\textcopyright} 2013 Springer-Verlag Berlin Heidelberg.},
  annote          = {cited By 15},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-642-35632-2-11},
  doi             = {10.1007/978-3-642-35632-2-11},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84872845348{\&}doi=10.1007{\%}2F978-3-642-35632-2-11{\&}partnerID=40{\&}md5=dba8c89cefcbf2020b784f97682ca252},
}

@Article{ISI:000420076400006,
  author          = {Londono, Sebastian and {Camilo Urcuqui}, Christian and {Navarro Cadavid}, Andres and {Fuentes Amaya}, Manuel and Gomez, Johan},
  title           = {{SafeCandy: System for security, analysis and validation in Android}},
  journal         = {SISTEMAS {\&} TELEMATICA},
  year            = {2015},
  volume          = {13},
  number          = {35},
  pages           = {89--102},
  issn            = {1692-5238},
  abstract        = {Android is an operating system which currently has over one billion
active users for all their mobile devices, a market impact that is
influencing an increase in the amount of information that can be
obtained from different users, facts that have motivated the development
of malicious software by cybercriminals. To solve the problems caused by
malware, Android implements a different architecture and security
controls, such as a unique user ID (UID) for each application, while an
API permits its distribution platform, Google Play applications. It has
been shown that there are ways to violate that protection, so the
developer community has been developing alternatives aimed at improving
the level of safety. This paper presents: the latest information on the
various trends and security solutions for Android, and SafeCandy, an app
proposed as a new system for analysis, validation and configuration of
Android applications that implements static and dynamic analysis with
improved ASEF. Finally, a study is included to evaluate the
effectiveness in threat detection of different malware antivirus
software for Android.},
  bdsk-url-1      = {http://dx.doi.org/10.18046/syt.v13i35.2154},
  doi             = {10.18046/syt.v13i35.2154},
}

@InProceedings{Chen:2017:SES:3134600.3134636,
  author          = {Chen, Lingwei and Hou, Shifu and Ye, Yanfang},
  title           = {{SecureDroid: Enhancing Security of Machine Learning-based Detection Against Adversarial Android Malware Attacks}},
  booktitle       = {Proceedings of the 33rd Annual Computer Security Applications Conference},
  year            = {2017},
  series          = {ACSAC 2017},
  pages           = {362--372},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {With smart phones being indispensable in people's everyday life, Android malware has posed serious threats to their security, making its detection of utmost concern. To protect legitimate users from the evolving Android malware attacks, machine learning-based systems have been successfully deployed and offer unparalleled flexibility in automatic Android malware detection. In these systems, based on different feature representations, various kinds of classifiers are constructed to detect Android malware. Unfortunately, as classifiers become more widely deployed, the incentive for defeating them increases. In this paper, we explore the security of machine learning in Android malware detection on the basis of a learning-based classifier with the input of a set of features extracted from the Android applications (apps). We consider different importances of the features associated with their contributions to the classification problem as well as their manipulation costs, and present a novel feature selection method (named SecCLS) to make the classifier harder to be evaded. To improve the system security while not compromising the detection accuracy, we further propose an ensemble learning approach (named SecENS) by aggregating the individual classifiers that are constructed using our proposed feature selection method SecCLS. Accordingly, we develop a system called SecureDroid which integrates our proposed methods (i.e., SecCLS and SecENS) to enhance security of machine learning-based Android malware detection. Comprehensive experiments on the real sample collections from Comodo Cloud Security Center are conducted to validate the effectiveness of SecureDroid against adversarial Android malware attacks by comparisons with other alternative defense methods. Our proposed secure-learning paradigm can also be readily applied to other malware detection tasks.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/3134600.3134636},
  bdsk-url-2      = {http://dx.doi.org/10.1145/3134600.3134636},
  doi             = {10.1145/3134600.3134636},
  isbn            = {978-1-4503-5345-8},
  keywords        = {Android Malware Detection, Machine Learning,Adversarial Attack},
  url             = {http://doi.acm.org/10.1145/3134600.3134636},
}

@Article{TANG2019257,
  author          = {Tang, Zhushou and Xue, Minhui and Meng, Guozhu and Ying, Chengguo and Liu, Yugeng and He, Jianan and Zhu, Haojin and Liu, Yang},
  title           = {{Securing android applications via edge assistant third-party library detection}},
  journal         = {Computers {\&} Security},
  year            = {2019},
  volume          = {80},
  pages           = {257--272},
  issn            = {0167-4048},
  abstract        = {Third-party library (TPL) detection in Android has been a hot topic to security researchers for a long time. A precise yet scalable detection of TPLs in applications can greatly facilitate other security activities such as TPL integrity checking, malware detection, and privacy leakage detection. Since TPLs of specific versions may exhibit their own security issues, the identification of TPL as well as its concrete version, can help assess the security of Android APPs. However in reality, existing approaches of TPL detection suffer from low efficiency for their detection algorithm to impracticable and low accuracy due to insufficient analysis data, inappropriate features, or the disturbance from code obfuscation, shrinkage, and optimization. In this paper, we present an automated approach, named PanGuard, to detect TPLs from an enormous number of Android APPs. We propose a novel combination of features including both structural and content information for packages in APPs to characterize TPLs. In order to address the difficulties caused by code obfuscation, shrinkage, and optimization, we identify the invariants that are unchanged during mutation, separate TPLs from the primary code in APPs, and use these invariants to determine the contained TPLs as well as their versions. The extensive experiments show that PanGuard achieves a high accuracy and scalability simultaneously in TPL detection. In order to accommodate to optimized TPL detection, which has not been mentioned by previous work, we adopt set analysis, which speed up the detection as a side effect. PanGuard is implemented and applied on an industrial edge computing platform, and powers the identification of TPL. Beside fast detection algorithm, the edge computing deployment architecture make the detection scalable to real-time detection on a large volume of emerging APPs. Based on the detection results from millions of Android APPs, we successfully identify over 800 TPLs with 12 versions on average. By investigating the differences amongst these versions, we identify over 10 security issues in TPLs, and shed light on the significance of TPL detection with the caused harmful impacts on the Android ecosystem.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404818311301},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2018.07.024},
  doi             = {https://doi.org/10.1016/j.cose.2018.07.024},
  keywords        = {Edge computing, Malware detection, Mobile security, Vulnerability detection,Third-party library detection},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404818311301},
}

@Conference{Wang2016410,
  author          = {Wang, Y and Zhang, Y and Wang, K and Yan, J},
  title           = {{Security analysis and vulnerability detection of gesture-based lock in android applications}},
  booktitle       = {Proceedings - 15th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, 10th IEEE International Conference on Big Data Science and Engineering and 14th IEEE International Symposium on Parallel and Distributed Processing with Applications, IEEE TrustCom/BigDataSE/ISPA 2016},
  year            = {2016},
  pages           = {410--417},
  abstract        = {Gesture-based lock plays an important role in many Android applications to prevent unauthorized access. Unfortunately, application developers tend to abuse some features provided by Android platform and neglect their influence on the security. This may result in fatal vulnerabilities which can be exploited to bypass gesture-based lock. In this paper, we focus on the vulnerabilities of gesture-based locks in Android applications and propose a dynamic testing tool named Lock-Breaker to detect them. We test 63 popular applications from android markets using Lock-Breaker. The results show that 28 out of these 63 applications are facing security threats, and 13 of the 28 applications have obvious vulnerabilities. In the end, we make some suggestions on defence for vulnerabilities in gesture-based locks to help enhance the security of android applications. {\textcopyright} 2016 IEEE.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1109/TrustCom.2016.0091},
  doi             = {10.1109/TrustCom.2016.0091},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85015253608{\&}doi=10.1109{\%}2FTrustCom.2016.0091{\&}partnerID=40{\&}md5=d0b6340673ad08d938d62046f17105a7},
}

@Article{ARMANDO2014247,
  author          = {Armando, Alessandro and Merlo, Alessio and Verderame, Luca},
  title           = {{Security considerations related to the use of mobile devices in the operation of critical infrastructures}},
  journal         = {International Journal of Critical Infrastructure Protection},
  year            = {2014},
  volume          = {7},
  number          = {4},
  pages           = {247--256},
  issn            = {1874-5482},
  abstract        = {An increasing number of attacks by mobile malware have begun to target critical infrastructure assets. Since malware attempts to defeat the security mechanisms provided by an operating system, it is of paramount importance to understand the strengths and weaknesses of the security frameworks of mobile device operating systems such as Android. Many recently discovered vulnerabilities suggest that security issues may be hidden in the cross-layer interplay between the Android layers and the underlying Linux kernel. This paper presents an empirical security evaluation of the interactions between Android layers. The experiments indicate that the Android Security Framework does not discriminate between callers of invocations to the Linux kernel, thereby enabling Android applications to directly interact with the kernel. This paper shows how this trait allows malware to adversely affect the security of mobile devices by exploiting previously unknown vulnerabilities unveiled by analyses of the Android interplay. The impact of the resulting attacks on critical infrastructures is discussed. Finally, an enhancement to the Android Security Framework is proposed for detecting and preventing direct kernel invocations by applications, thereby dramatically reducing the impact of malware.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1874548214000626},
  bdsk-url-2      = {https://doi.org/10.1016/j.ijcip.2014.10.002},
  doi             = {https://doi.org/10.1016/j.ijcip.2014.10.002},
  keywords        = {Android, Critical infrastructure, Cross-layer interplay, Malware, Security,Mobile devices},
  url             = {http://www.sciencedirect.com/science/article/pii/S1874548214000626},
}

@Conference{Knorr2015,
  author          = {Knorr, K and Aspinall, D},
  title           = {{Security testing for Android mHealth apps}},
  booktitle       = {2015 IEEE 8th International Conference on Software Testing, Verification and Validation Workshops, ICSTW 2015 - Proceedings},
  year            = {2015},
  abstract        = {Mobile health (mHealth) apps are an ideal tool for monitoring and tracking long-term health conditions; they are becoming incredibly popular despite posing risks to personal data privacy and security. In this paper, we propose a testing method for Android mHealth apps which is designed using a threat analysis, considering possible attack scenarios and vulnerabilities specific to the domain. To demonstrate the method, we have applied it to apps for managing hypertension and diabetes, discovering a number of serious vulnerabilities in the most popular applications. Here we summarise the results of that case study, and discuss the experience of using a testing method dedicated to the domain, rather than out-of-the-box Android security testing methods. We hope that details presented here will help design further, more automated, mHealth security testing tools and methods. {\textcopyright} 2015 IEEE.},
  annote          = {cited By 13},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICSTW.2015.7107459},
  doi             = {10.1109/ICSTW.2015.7107459},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84934344036{\&}doi=10.1109{\%}2FICSTW.2015.7107459{\&}partnerID=40{\&}md5=c734e91d095c7d450634bc587d304461},
}

@Conference{Santos2018153,
  author          = {Santos, J and Antunes, M and Mangana, J and Monteiro, D and Santos, P and Casal, J},
  title           = {{Security testing framework for a novel mobile wallet ecosystem}},
  booktitle       = {Proceedings - 9th International Conference on Computational Intelligence and Communication Networks, CICN 2017},
  year            = {2018},
  volume          = {2018-January},
  pages           = {153--160},
  abstract        = {Tasks related with payments, personal identification, and the usage of tickets and marketing items can be achieved through mobile wallets. Despite the advantages that these present, such as their ease of usage and great accessibility, some security concerns are still pointed out by consumers. On this paper are presented the main security issues existent on mobile wallet ecosystems nowadays, and the possible tests and security measures that can be adopted on those ecosystems. The tests that we describe on the paper are performed on a novel mobile wallet ecosystem named weWallet, and are segmented on three axes: Mobile applications, cloud infrastructure, and physical communication technologies. {\textcopyright} 2017 IEEE.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1109/CICN.2017.8319376},
  doi             = {10.1109/CICN.2017.8319376},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050772017{\&}doi=10.1109{\%}2FCICN.2017.8319376{\&}partnerID=40{\&}md5=b880ed6d0bfa2bbf057e064be74c0934},
}

@InProceedings{Wu:2016:SDE:2892208.2892218,
  author          = {Wu, Haowei and Yang, Shengqian and Rountev, Atanas},
  title           = {{Static Detection of Energy Defect Patterns in Android Applications}},
  booktitle       = {Proceedings of the 25th International Conference on Compiler Construction},
  year            = {2016},
  series          = {CC 2016},
  pages           = {185--195},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {For static analysis researchers, Android software presents a wide variety of interesting challenges. The target of our work is static detection of energy-drain defects in Android applications. The management of energy-intensive resources (e.g., GPS) creates various opportunities for software defects. Our goal is to detect statically missing deactivation energy-drain defects in the user interface of the application. First, we define precisely two patterns of run-time energy-drain behaviors, based on modeling of Android GUI control-flow paths and energy-related listener leaks along such paths. Next, we define a static detection algorithm targeting these patterns. The analysis considers valid interprocedural control-flow paths in a callback method and its transitive callees, in order to detect operations that add or remove listeners. Sequences of callbacks are then analyzed for possible listener leaks. Our evaluation considers the detection of GUI-related energy-drain defects reported in prior work, as well as new defects not discovered by prior approaches. In summary, the detection is very effective and precise, suggesting that the proposed analysis is suitable for practical use in static checking tools for Android.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2892208.2892218},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2892208.2892218},
  doi             = {10.1145/2892208.2892218},
  isbn            = {978-1-4503-4241-4},
  keywords        = {GUI analysis, energy, static analysis,Android},
  url             = {http://doi.acm.org/10.1145/2892208.2892218},
}

@Conference{Yan2013411,
  author          = {Yan, D and Yang, S and Rountev, A},
  title           = {{Systematic testing for resource leaks in Android applications}},
  booktitle       = {2013 IEEE 24th International Symposium on Software Reliability Engineering, ISSRE 2013},
  year            = {2013},
  pages           = {411--420},
  abstract        = {The use of mobile devices and the complexity of their software continue to grow rapidly. This growth presents significant challenges for software correctness and performance. In addition to traditional defects, a key consideration are defects related to the limited resources available on these devices. Resource leaks in an application, due to improper management of resources, can lead to slowdowns, crashes, and negative user experience. Despite a large body of existing work on leak detection, testing for resource leaks remains a challenging problem. We propose a novel and comprehensive approach for systematic testing for resource leaks in Android software. Similar to existing testing techniques, the approach is based on a GUI model, but is focused specifically on coverage criteria aimed at resource leak defects. These criteria are based on neutral cycles: sequences of GUI events that should have a 'neutral' effect and should not lead to increases in resource usage. Several important categories of neutral cycles are considered in the proposed test coverage criteria. Experimental evaluation and case studies were performed on eight Android applications. The approach exposed 18 resource leak defects, 12 of which were previously unknown. These results provide motivation for future work on analysis, testing, and prevention of resource leaks in Android software. {\textcopyright} 2013 IEEE.},
  annote          = {cited By 24},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ISSRE.2013.6698894},
  doi             = {10.1109/ISSRE.2013.6698894},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84893274946{\&}doi=10.1109{\%}2FISSRE.2013.6698894{\&}partnerID=40{\&}md5=6645f69e14baa1b2d75f9994d41f72af},
}

@Article{TSAI2017103,
  author          = {Tsai, Tsai-Hsuan and Tseng, Kevin C and Chang, Yung-Sheng},
  title           = {{Testing the usability of smartphone surface gestures on different sizes of smartphones by different age groups of users}},
  journal         = {Computers in Human Behavior},
  year            = {2017},
  volume          = {75},
  pages           = {103--116},
  issn            = {0747-5632},
  abstract        = {This study focuses on testing the usability of 3 different sizes of smartphones by children, adults, and the elderly. Forty-seven participants from each age group were recruited. The research consisted of two stages of experiments. In the first experiment, three existing gestures used by the Android system were evaluated: drag, pinch, and double-touch drag. In the second experiment, two additional re-design gestures were tested: multi-long press and slide down. The users' performances were measured based on their overall time, success time, accuracy, Fitts' Law values, and a subjective questionnaire. Among the five gestures, drag and multi-long press were categorized as the drag gesture, and pinch, double-touch drag and slide down were categorized as the enlarging gesture. The results show that children and adults outperformed the elderly in gesture operation. With respect to smartphone size, the subjects had faster response times and better Fitts' Law values on 6-inch phones. When comparing the subjective preference and the objective use measurement values of the two drag gestures and three enlarging gestures among the different age groups, it was found that children and adults were consistent, whereas the elderly were inconsistent. Overall, in operating the original drag and pinch gestures, the elderly exhibited better objective use measurements, but they preferred the improved gestures, such as slide down.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0747563217303254},
  bdsk-url-2      = {https://doi.org/10.1016/j.chb.2017.05.013},
  doi             = {https://doi.org/10.1016/j.chb.2017.05.013},
  keywords        = {Children, Elderly, Fitts' law, Gestures, Usability,Smartphone size},
  url             = {http://www.sciencedirect.com/science/article/pii/S0747563217303254},
}

@Conference{Cheng20161,
  author          = {Cheng, L C},
  title           = {{The mobile app usability inspection (MAUi) framework as a guide for minimal viable product (MVP) testing in lean development cycle}},
  booktitle       = {Proceedings of CHIuXiD 2016, the 2nd International Human Computer Interaction and User Experience Conference in Indonesia: Bridging the Gaps in the HCI and UX World},
  year            = {2016},
  pages           = {1--11},
  abstract        = {The Mobile App Usability Inspection (MAUi) framework is an improvised user-interface auditing technique based on the classical work of Heuristic Evaluation, pioneered by Jakob Nielsen {\&} Rolf Molich. While the method of HE has been extensively cross-examined and reported in wide arrays of usability testing activities, its potential as a highly reliable inspection procedure is yet to be systematically formalized for lean development cycle. This paper demonstrated the application of the MAUi framework to the evaluation of a high-fidelity prototype that explored touchscreen interactions between three-dimension virtual objects on a mobile device. The initial results suggested that MAUi is a much reliable usability inspection method as the findings, given by four different inspectors shared 85{\%} of true ability from user testing event. In addition, the MAUi framework can be used as a checklist for fine-Tuning the readiness of any minimal viable products on mobile device. {\textcopyright} 2016 ACM.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2898459.2898460},
  doi             = {10.1145/2898459.2898460},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84966549525{\&}doi=10.1145{\%}2F2898459.2898460{\&}partnerID=40{\&}md5=6ad79a7c1e5bb2062e85f6df23a39c29},
}

@Article{MASOOD20151818,
  author          = {Masood, Mona and Thigambaram, Menaga},
  title           = {{The Usability of Mobile Applications for Pre-schoolers}},
  journal         = {Procedia - Social and Behavioral Sciences},
  year            = {2015},
  volume          = {197},
  pages           = {1818--1826},
  issn            = {1877-0428},
  abstract        = {The purpose of this study is to investigate the importance of usability in user interface (UI) design of mobile educational applications (MEA) designed for children aged 4-5 years. Usability testing was conducted with four children to evaluate the UI design based on the children's mental model in addition to the quality of their learning experience. An eye tracking glasses was utilized to capture the children's eye movements while the usability heuristics was used to collect the descriptive data regarding the interface design. Results indicated that the usability study can be considered as a multi-stage problem solving process where it analyses and foresee how the children use a product and the actual first-time users' intuition of their design experience and learning curve. The observation, eye tracking data and usability testing of the MEA with the four children validates that the UI application was based on the developers and designers adult mental model and guideline or own assumptions. This paper ends with a suggestion of a UI design guideline of design elements and principles for designers and developers to adhere when developing MEA for children.},
  annote          = {7th World Conference on Educational Sciences},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1877042815042421},
  bdsk-url-2      = {https://doi.org/10.1016/j.sbspro.2015.07.241},
  doi             = {https://doi.org/10.1016/j.sbspro.2015.07.241},
  keywords        = {educational application, eye tracking glasses, mobile apps, tablets,usability testing},
  url             = {http://www.sciencedirect.com/science/article/pii/S1877042815042421},
}

@Article{ALIGOMBE2018235,
  author          = {Ali-Gombe, Aisha I and Saltaformaggio, Brendan and Ramanujam, J ``Ram'' and Xu, Dongyan and Richard, Golden G},
  title           = {{Toward a more dependable hybrid analysis of android malware using aspect-oriented programming}},
  journal         = {Computers {\&} Security},
  year            = {2018},
  volume          = {73},
  pages           = {235--248},
  issn            = {0167-4048},
  abstract        = {The growing threat to user privacy by Android applications (app) has tremendously increased the need for more reliable and accessible analysis techniques. This paper presents AspectDroid11A poster version of this paper appears in CODASPY 2016 (Ali-Gombe et al., 2016).---an offline app-level hybrid analysis system designed to investigate Android applications for possible unwanted activities. It leverages static bytecode instrumentation to weave in analysis routines into an existing application to provide efficient dataflow analysis, detection of resource abuse, and analytics of suspicious behaviors, which are then monitored dynamically at runtime. Unlike operating system or framework dependent approaches, AspectDroid does not require porting from one version of Android to another, nor does it depend on a particular Android runtime, making it a more adaptable and easier to use technique. We evaluate the strength of our dataflow algorithm on 105 apps from the DroidBench corpus, with experimental results demonstrating that AspectDroid can detect tagged data with 94.68{\%} accuracy. Furthermore, we compare and contrast the behavioral patterns in 100 malware samples from the Drebin dataset (Arp et al., 2014) and 100 apps downloaded from Google Play. Our results showed more traces of sensitive data exfiltration, abuse of resources, as well as suspicious use of programming concepts like reflection, native code, and dynamic classes in the malware set than the Google Play apps. In terms of runtime overhead, our experiments indicate AspectDroid can comprehensively log relevant security concerns with an approximate overhead of 1MB memory and a 5.9{\%} average increase in CPU usage.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167404817302377},
  bdsk-url-2      = {https://doi.org/10.1016/j.cose.2017.11.006},
  doi             = {https://doi.org/10.1016/j.cose.2017.11.006},
  keywords        = {Android, Bytecode weaving, Dataflow, Dynamic execution, Instrumentation, Malware,Hybrid analysis},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167404817302377},
}

@Conference{Cao2015361,
  author          = {Cao, C and Gao, N and Liu, P and Xiang, J},
  title           = {{Towards analyzing the input validation vulnerabilities associated with android system services}},
  booktitle       = {ACM International Conference Proceeding Series},
  year            = {2015},
  volume          = {7-11-December-2015},
  pages           = {361--370},
  abstract        = {Although the input validation vulnerabilities play a critical role in web application security, such vulnerabilities are so far largely neglected in the Android security research community. We found that due to the unique Framework Code layer, Android devices do need specific input validation vulnerability analysis in system services. In this work, we take the first steps to analyze Android specific input validation vulnerabilities. In particular, a) we take the first steps towards measuring the corresponding attack surface and reporting the current input validation status of Android system services. b) We developed a new input validation vulnerability scanner for Android devices. This tool fuzzes all the Android system services by sending requests with malformed arguments to them. Through comprehensive evaluation of Android system with over 90 system services and over 1,900 system service methods, we identified 16 vulnerabilities in Android system services. We have reported all the issues to Google and Google has confirmed them. {\textcopyright} 2015 ACM.},
  annote          = {cited By 8},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2818000.2818033},
  doi             = {10.1145/2818000.2818033},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84959334018{\&}doi=10.1145{\%}2F2818000.2818033{\&}partnerID=40{\&}md5=967f72e73e5c7f659e5a9c9bb5f24c3e},
}

@Article{SAHAR201928,
  author          = {Sahar, Hareem and Bangash, Abdul A and Beg, Mirza O},
  title           = {{Towards energy aware object-oriented development of android applications}},
  journal         = {Sustainable Computing: Informatics and Systems},
  year            = {2019},
  volume          = {21},
  pages           = {28--46},
  issn            = {2210-5379},
  abstract        = {Energy consumption has become a concern for developers due to the increasing complexity of applications that are to run on devices with limited battery power. Developers want to develop energy efficient applications however existing tools do not bridge the gap between understanding where energy is consumed and suggesting how the code can be modified in order to reduce energy consumption. A generalized method to relate software structure with its energy consumption is hence desirable. Previous attempts to relate change in object-oriented structure to its effects on energy consumption have been inconclusive. In this paper, we proposed a methodology to relate software structural information represented as metrics to energy consumption. Employing our methodology we empirically validated three Object Oriented (OO) metric suites; the Abreus Metrics (MOOD), Chidamber and Kemerer (CK) metrics and Martin's package metric suite and determine their relationship with energy consumption. Our results show that software structural metrics can be reliably related to energy consumption behavior of programs using a total of 63 releases from seven open-source iteratively developed android applications.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S2210537918302014},
  bdsk-url-2      = {https://doi.org/10.1016/j.suscom.2018.10.005},
  doi             = {https://doi.org/10.1016/j.suscom.2018.10.005},
  keywords        = {Energy-aware development, Mining software repositories, Software metrics, Static analysis, Sustainable software,Energy consumption},
  url             = {http://www.sciencedirect.com/science/article/pii/S2210537918302014},
}

@Article{ISI:000435335100005,
  author          = {Bai, Guangdong and Ye, Quanqi and Wu, Yongzheng and Botha, Heila and Sun, Jun and Liu, Yang and Dong, Jin Song and Visser, Willem},
  title           = {{Towards Model Checking Android Applications}},
  journal         = {IEEE TRANSACTIONS ON SOFTWARE ENGINEERING},
  year            = {2018},
  volume          = {44},
  number          = {6},
  pages           = {595--612},
  issn            = {0098-5589},
  abstract        = {As feature-rich Android applications (apps for short) are increasingly popularized in security-sensitive scenarios, methods to verify their security properties are highly desirable. Existing approaches on verifying Android apps often have limited effectiveness. For instance, static analysis often suffers from a high false-positive rate, whereas approaches based on dynamic testing are limited in coverage. In this work, we propose an alternative approach, which is to apply the software model checking technique to verify Android apps. We have built a general framework named DroidPF upon Java PathFinder (JPF), towards model checking Android apps. In the framework, we craft an executable mock-up Android OS which enables JPF to dynamically explore the concrete state spaces of the tested apps; we construct programs to generate user interaction and environmental input so as to drive the dynamic execution of the apps; and we introduce Android specific reduction techniques to help alleviate the state space explosion. DroidPF focuses on common security vulnerabilities in Android apps including sensitive data leakage involving a non-trivial flow- and context-sensitive taint-style analysis. DroidPF has been evaluated with 131 apps, which include real-world apps, third-party libraries, malware samples and benchmarks for evaluating app analysis techniques like ours. DroidPF precisely identifies nearly all of the previously known security issues and nine previously unreported vulnerabilities/bugs.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/TSE.2017.2697848},
  doi             = {10.1109/TSE.2017.2697848},
  keywords        = {,Android (operating system),Android OS,Android apps verification,Android specific reduction techniques,Androids,DroidPF,Humanoid robots,Java,Java PathFinder,Libraries,Model checking,Security,Software,Software model checking,android application,app analysis techniques,concrete state spaces,context-sensitive taint-style analysis,dynamic execution,environmental input,feature-rich Android applications,invasive software,malware samples,mobile computing,model checking,nontrivial flow-style analysis,program diagnostics,program verification,public domain software,real-world apps,security properties,security verification,security-sensitive scenarios,sensitive data leakage,state space explosion,tested apps,third-party libraries,user interaction},
}

@Article{Su2019389,
  author          = {Su, X and Lin, J and Shen, F and Zheng, Y},
  title           = {{Two-phases detection scheme: Detecting android malware in android markets}},
  journal         = {Advances in Intelligent Systems and Computing},
  year            = {2019},
  volume          = {842},
  pages           = {389--399},
  abstract        = {Recently, Android application becomes popular and important in human's daily work, life, entertainment. However, because of open source of Android application, more and more malware aim to this platform and launch various malicious attacks to threaten Android users' security. Previous research works focus on using static behavioral analysis to detect Android malware, which cannot capture dynamic behaviors and in-efficiency to detect Android malware. In this paper, we present a Android application two-stage detection scheme that using two kinds of dynamic behavioral characteristics to detect Android malware. This framework first uses system call statistics to identify potential malicious apps. After verification, if the software is clean, the application will then be released to the relevant markets. To mitigate against false negative cases, users who run new apps can invoke our network traffic monitoring (NTM) tool which triggers network traffic capture upon detecting some suspicious behaviors e.g. detecting sensitive data being sent to output stream of an open socket. The network traffic will be analyzed to see if it matches network characteristics observed from malware apps. If suspicious network traffic is observed, the relevant Android markets will be notified to remove the application from the repository. We trained our system call and network traffic classifiers using 32 families of known Android malware families and some typical normal apps. Later, we evaluated our framework using other malware and normal apps that used in the training set. Our experimental results using 120 test apps (which consist of 50 malware and 70 normal apps) indicate that we can achieve a 94.2{\%} and 99.2{\%} accuracy with J.48 and Random forest classifier respectively using our framework. {\textcopyright} Springer Nature Switzerland AG 2019.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-98776-7_41},
  doi             = {10.1007/978-3-319-98776-7_41},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056839530{\&}doi=10.1007{\%}2F978-3-319-98776-7{\_}41{\&}partnerID=40{\&}md5=920df0e8e09f8285606529a17eea3300},
}

@Conference{Feng2016398,
  author          = {Feng, H and Shin, K G},
  title           = {{Understanding and defending the binder attack surface in android}},
  booktitle       = {ACM International Conference Proceeding Series},
  year            = {2016},
  volume          = {5-9-December-2016},
  pages           = {398--409},
  abstract        = {In Android, communications between apps and system services are supported by a transaction-based Inter-Process Communication (IPC) mechanism. Binder, as the cornerstone of this IPC mechanism, separates two communicating parties as client and server. As with any client-server model, the server should not make any assumption on the validity (sanity) of client-side transaction. To our surprise, we find this principle has frequently been overlooked in the implementation of Android system services. In this paper, we try to answer why developers keep making this seemingly simple mistake by studying more than 100 vulnerabilities on this attack surface. We analyzed these vulnerabilities to find that most of them are rooted at a common confusion of where the actual security boundary is among system developers. We thus highlight the deficiency of testing only on client-side public APIs and argue for the necessity of testing and protection on the Binder interface - the actual security boundary. Specifically, we design and implement BinderCracker, an automatic testing framework that supports context-aware fuzzing and actively manages the dependency between transactions. It does not require the source codes of the component under test, is compatible with services in different layers, and performs much more effectively than simple black-box fuzzing. We also call attention to the attack attribution problem for IPC-based attacks. The lack of OS-level support makes it very difficult to identify the culprit apps even for developers with adb access. We address this issue by providing an informative runtime diagnostic tool that tracks the origin, schema, content, and parsing details of each failed transaction. This brings transparency into the IPC process and provides an essential step for other in-depth analysis or forensics. {\textcopyright} 2016 ACM.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2991079.2991120},
  doi             = {10.1145/2991079.2991120},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85007557397{\&}doi=10.1145{\%}2F2991079.2991120{\&}partnerID=40{\&}md5=1368f91f407112e2d758370bdc5d4a52},
}

@Conference{Xing2014393,
  author          = {Xing, L and Pan, X and Wang, R and Yuan, K and Wang, X F},
  title           = {{Upgrading your Android, elevating my malware: Privilege escalation through mobile OS updating}},
  booktitle       = {Proceedings - IEEE Symposium on Security and Privacy},
  year            = {2014},
  pages           = {393--408},
  abstract        = {Android is a fast evolving system, with new updates coming out one after another. These updates often completely overhaul a running system, replacing and adding tens of thousands of files across Android's complex architecture, in the presence of critical user data and applications (apps for short). To avoid accidental damages to such data and existing apps, the upgrade process involves complicated program logic, whose security implications, however, are less known. In this paper, we report the first systematic study on the Android updating mechanism, focusing on its Package Management Service (PMS). Our research brought to light a new type of security-critical vulnerabilities, called Pileup flaws, through which a malicious app can strategically declare a set of privileges and attributes on a low-version operating system (OS) and wait until it is upgraded to escalate its privileges on the new system. Specifically, we found that by exploiting the Pileup vulnerabilities, the app can not only acquire a set of newly added system and signature permissions but also determine their settings (e.g., protection levels), and it can further substitute for new system apps, contaminate their data (e.g., cache, cookies of Android default browser) to steal sensitive user information or change security configurations, and prevent installation of critical system services. We systematically analyzed the source code of PMS using a program verification tool and confirmed the presence of those security flaws on all Android official versions and over 3000 customized versions. Our research also identified hundreds of exploit opportunities the adversary can leverage over thousands of devices across different device manufacturers, carriers and countries. To mitigate this threat without endangering user data and apps during an upgrade, we also developed a new detection service, called SecUP, which deploys a scanner on the user's device to capture the malicious apps designed to exploit Pileup vulnerabilities, based upon the vulnerability-related information automatically collected from newly released Android OS images. {\textcopyright} 2014 IEEE.},
  annote          = {cited By 52},
  bdsk-url-1      = {http://dx.doi.org/10.1109/SP.2014.32},
  doi             = {10.1109/SP.2014.32},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84914140121{\&}doi=10.1109{\%}2FSP.2014.32{\&}partnerID=40{\&}md5=017fa059652d68dec9a89ce0084a3e2e},
}

@Article{IQBAL20172185,
  author          = {Iqbal, Muhammad Waseem and Ahmad, Nadeem and Shahzad, Syed Khuram},
  title           = {{Usability evaluation of adaptive features in smartphones}},
  journal         = {Procedia Computer Science},
  year            = {2017},
  volume          = {112},
  pages           = {2185--2194},
  issn            = {1877-0509},
  abstract        = {This paper presents a usability study that aims to analyze effectiveness, efficiency, and satisfaction based on the existing adaptive features in smartphones. The adaptive features include screen rotation, voice commands, LED notifications and kid mode for android and iOS platforms. The effectiveness and efficiency are measured by considering task completion within a specific time while satisfaction is measured through After Scenario Questionnaire (ASQ) technique. The experiment is carried out with the involvement of 128 participants. The study shows interesting patterns in usability where screen rotation and voice commands resulted in lower usability. Whereas, LED notifications is a dominant feature having almost 88{\%} effectiveness comparing to a non-adaptive environment. Finally, the study suggests that the adaptive features must be applied after careful analysis of user tasks and context.},
  annote          = {Knowledge-Based and Intelligent Information {\&} Engineering Systems: Proceedings of the 21st International Conference, KES-20176-8 September 2017, Marseille, France},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1877050917316678},
  bdsk-url-2      = {https://doi.org/10.1016/j.procs.2017.08.258},
  doi             = {https://doi.org/10.1016/j.procs.2017.08.258},
  keywords        = {adaptive mobile feature, smartphone, user experience, user interface, user satisfaction,Usability patterns},
  url             = {http://www.sciencedirect.com/science/article/pii/S1877050917316678},
}

@Article{Bollini2014652,
  author          = {Bollini, L and {De Palma}, R and Nota, R and Pietra, R},
  title           = {{User experience {\&} usability for mobile geo-referenced apps. A case study applied to cultural heritage field}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2014},
  volume          = {8580 LNCS},
  number          = {PART 2},
  pages           = {652--662},
  abstract        = {The mobile revolution has become the main access gate to Internet in a diffused communication ecosystems. Consequently the apps become the interface mediation between the user and the real/virtual space of information. The opportunity of associating data to a physical position requires deeper thought: this means the interweaving between perception of the real-world, representation in digital systems and the mental model of users. The research presented proposes an extension of user testing methodologies - of the user-centered design - applied to user interaction with mobile app in which the geo-referenced feature is the focus of the user experience. In particular, the case study The Bethroted 2.0 becomes the experimental research field. Using a mixed methodology approach - qualitative interviews, in-field research and spatial user tests according to both ambient psychology and user-centered design - the prototype is tested. The experimental activities were addressed analyze both the environmental interactions and with the app trying to better understand the relations between real and digital space and the mental model of the users. {\textcopyright} 2014 Springer International Publishing.},
  annote          = {cited By 4},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-09129-7_47},
  doi             = {10.1007/978-3-319-09129-7_47},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904861828{\&}doi=10.1007{\%}2F978-3-319-09129-7{\_}47{\&}partnerID=40{\&}md5=f173380d47c4667ed0c93c6f9bad6905},
}

@Article{Forte2017614,
  author          = {Forte, J and Darin, T},
  title           = {{User experience evaluation for user interface redesign: A case study on a bike sharing application}},
  journal         = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year            = {2017},
  volume          = {10290 LNCS},
  pages           = {614--631},
  abstract        = {Mobile application redesign requires the accurate use of design methods and guidelines, as well as detailed evaluation. In the context of alternative and environmentally friendly transportation supported by mobile applications, the redesign process can help enhancing the user experience resulting in a greater adherence of the citizen. To illustrate this scenario and inspire designers to further consider the user experience aspects, we present a case study of the redesign of Bicicletar, a Brazilian bike-sharing application. Our main goal is to analyze how the User Experience (UX) with this outdoor mobility application may affect the design choices in the User Interface. Overall, our iterative redesign process comprised: (1) UX evaluation of the application in the real usage context; (2) redesign of the application through a high-fidelity prototype; and (3) prototype validation. The results showed that the user experience problems regarding the identification and interaction with the main features of Bicicletar affected the perceived usability of the application. On the other hand, the redesigned prototype improvements on the user interface positively affected not only the user experience but also how the users trust the application. The present research is a starting point for the implementation of improvements in Bicicletar and in over 10 variations of this application in other Brazilian states, benefiting the local community, and serving as a reference for the redesign of other mobile applications. {\textcopyright} Springer International Publishing AG 2017.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-58640-3_44},
  doi             = {10.1007/978-3-319-58640-3_44},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025135856{\&}doi=10.1007{\%}2F978-3-319-58640-3{\_}44{\&}partnerID=40{\&}md5=2e665c43a2cab1e77e3d8bf4e9cbb0b9},
}

@Article{Qian201544,
  author          = {Qian, C and Luo, X and Le, Y and Gu, G},
  title           = {{VulHunter: Toward discovering vulnerabilities in android applications}},
  journal         = {IEEE Micro},
  year            = {2015},
  volume          = {35},
  number          = {1},
  pages           = {44--53},
  abstract        = {With the prosperity of the Android app economy, many apps have been published and sold in various markets. However, short development cycles and insufficient security development guidelines have led to many vulnerable apps. Although some systems have been developed for automatically discovering specific vulnerabilities in apps, their effectiveness and efficiency are usually restricted because of the exponential growth of paths to examine and simplified assumptions. In this article, the authors propose a new static-analysis framework for facilitating security analysts to detect vulnerable apps from three aspects. First, they propose an app property graph (APG), a new data structure containing detailed and precise information from apps. Second, by modeling app-related vulnerabilities as graph traversals, the authors conduct graph traversals over APGs to identify vulnerable apps for easing the identification process. Third, they reduce the workload of manual verification by removing infeasible paths and generating attack inputs whenever possible. They have implemented the framework in a system named VulHunter with 9,145 lines of Java code and modeled five types of vulnerabilities. Checking 557 popular apps that are randomly collected from Google Play and have at least 1 million installations, the authors found that 375 apps (67.3 percent) have at least one vulnerability. {\textcopyright} 2015 IEEE.},
  annote          = {cited By 14},
  bdsk-url-1      = {http://dx.doi.org/10.1109/MM.2015.25},
  doi             = {10.1109/MM.2015.25},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84925070537{\&}doi=10.1109{\%}2FMM.2015.25{\&}partnerID=40{\&}md5=289f2cd69ab31fe96cc3c4fb64a1f4d6},
}

@InProceedings{Wang:2015:VAO:2818000.2818024,
  author          = {Wang, Hui and Zhang, Yuanyuan and Li, Juanru and Liu, Hui and Yang, Wenbo and Li, Bodong and Gu, Dawu},
  title           = {{Vulnerability Assessment of OAuth Implementations in Android Applications}},
  booktitle       = {Proceedings of the 31st Annual Computer Security Applications Conference},
  year            = {2015},
  series          = {ACSAC 2015},
  pages           = {61--70},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Enforcing security on various implementations of OAuth in Android apps should consider a wide range of issues comprehensively. OAuth implementations in Android apps differ from the recommended specification due to the provider and platform factors, and the varied implementations often become vulnerable. Current vulnerability assessments on these OAuth implementations are ad hoc and lack a systematic manner. As a result, insecure OAuth implementations are still widely used and the situation is far from optimistic in many mobile app ecosystems.

To address this problem, we propose a systematic vulnerability assessment framework for OAuth implementations on Android platform. Different from traditional OAuth security analyses that are experiential with a restrictive three-party model, our proposed framework utilizes an systematic security assessing methodology that adopts a five-party, three-stage model to detect typical vulnerabilities of popular OAuth implementations in Android apps. Based on this framework, a comprehensive investigation on vulnerable OAuth implementations is conducted at the level of an entire mobile app ecosystem. The investigation studies the Chinese mainland mobile app markets (e.g., Baidu App Store, Tencent, Anzhi) that covers 15 mainstream OAuth service providers. Top 100 relevant relying party apps (RP apps) are thoroughly assessed to detect vulnerable OAuth implementations, and we further perform an empirical study of over 4,000 apps to validate how frequently developers misuse the OAuth protocol. The results demonstrate that 86.2% of the apps incorporating OAuth services are vulnerable, and this ratio of Chinese mainland Android app market is much higher than that (58.7%) of Google Play.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2818000.2818024},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2818000.2818024},
  doi             = {10.1145/2818000.2818024},
  isbn            = {978-1-4503-3682-6},
  url             = {http://doi.acm.org/10.1145/2818000.2818024},
}

@InProceedings{ISI:000389470200002,
  author          = {{Feijo Filho}, Jackson and Prata, Wilson and Oliveira, Juan},
  title           = {{Where-How-What Am I Feeling: User Context Logging in Automated Usability Tests for Mobile Software}},
  booktitle       = {Design, User Experience, and Usability: Technological Contexts, Pt III},
  year            = {2016},
  volume          = {9748},
  series          = {Lecture Notes in Computer Science},
  pages           = {14--23},
  abstract        = {This work proposes the use of a system to implement user context and
emotional feedback and logging in automated usability tests for mobile
devices. Our proposal augments the traditional methods of software
usability evaluation by monitoring users' location, weather conditions,
moving/ stationary status, data connection availability and spontaneous
facial expressions automatically. This aims to identify the moment of
negative and positive events. Identifying those situations and
systematically associating them to the context of interaction, assisted
software creators to overcome design flaws and enhancing interfaces'
strengths.
The validation of our approach include post-test questionnaires with
test subjects. The results indicate that the automated user-context
logging can be a substantial supplement to mobile software usability
tests.},
  annote          = {5th International Conference on Design, User Experience, and Usability (DUXU) held as part of 18th International Conference on Human-Computer Interaction (HCI International), Toronto, CANADA, JUL 17-22, 2016},
  bdsk-url-1      = {http://dx.doi.org/10.1007/978-3-319-40406-6_2},
  doi             = {10.1007/978-3-319-40406-6_2},
  isbn            = {978-3-319-40406-6; 978-3-319-40405-9},
  issn            = {0302-9743},
}

@Article{TOMASONI2018193,
  author          = {Tomasoni, Mattia and Capponi, Andrea and Fiandrino, Claudio and Kliazovich, Dzmitry and Granelli, Fabrizio and Bouvry, Pascal},
  title           = {{Why energy matters? Profiling energy consumption of mobile crowdsensing data collection frameworks}},
  journal         = {Pervasive and Mobile Computing},
  year            = {2018},
  volume          = {51},
  pages           = {193--208},
  issn            = {1574-1192},
  abstract        = {Mobile Crowdsensing (MCS) has emerged in the last years and has become one of the most prominent paradigms for urban sensing. The citizens actively participate in the sensing process by contributing data with their mobile devices. To produce data, citizens sustain costs, i.e., the energy consumed for sensing and reporting operations. Hence, devising energy efficient data collection frameworks (DCFs) is essential to foster participation. In this work, we investigate from an energy-perspective the performance of different DCFs. Our methodology is as follows: (i) we developed an Android application that implements the DCFs, (ii) we profiled the energy and network performance with a power monitor and Wireshark, (iii) we included the obtained traces into CrowdSenSim simulator for large-scale evaluations in city-wide scenarios such as Luxembourg City, Turin and Washington DC. The amount of collected data, energy consumption and fairness are the performance indexes evaluated. The results unveil that DCFs with continuous data reporting require particular adjustments to be more energy-effective in harvesting data from the crowd than DCFs with probabilistic reporting. The latter exhibit high variability of energy consumption, i.e., to produce the same amount of data, the associated energy cost of different users can vary significantly.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1574119217305965},
  bdsk-url-2      = {https://doi.org/10.1016/j.pmcj.2018.10.002},
  doi             = {https://doi.org/10.1016/j.pmcj.2018.10.002},
  keywords        = {Data collection, Energy consumption,Mobile crowdsensing},
  url             = {http://www.sciencedirect.com/science/article/pii/S1574119217305965},
}

@Article{ATKINSON2018546,
  author          = {Atkinson, John S and Mitchell, John E and Rio, Miguel and Matich, George},
  title           = {{Your WiFi is leaking: What do your mobile apps gossip about you?}},
  journal         = {Future Generation Computer Systems},
  year            = {2018},
  volume          = {80},
  pages           = {546--557},
  issn            = {0167-739X},
  abstract        = {This paper describes how mobile device apps can inadvertently broadcast personal information through their use of wireless networks despite the correct use of encryption. Using a selection of personas we illustrate how app usage can be tied to personal information. Users would likely assume the confidentiality of personal information (including age, religion, sexuality and gender) when using an encrypted network. However, we demonstrate how encrypted traffic pattern analysis can allow a remote observer to infer potentially sensitive data passively and undetectably without any network credentials. Without the ability to read encrypted WiFi traffic directly, we process the limited side-channel data available (timings and frame sizes) to enable remote app detection. These side-channel data measurements are represented as histograms and used to construct a Random Forest classifier capable of accurately identifying mobile apps from the encrypted traffic they cause. The Random Forest algorithm was able to correctly identify apps with a mean accuracy of 99{\%} within the training set. The classifier was then adapted to form the core of a detection program that could monitor multiple devices in real-time. Tests in a closed-world scenario showed 84{\%} accuracy and demonstrated the ability to overcome the data limitations imposed by WiFi encryption. Although accuracy suffers greatly (67{\%}) when moving to an open-world scenario, a high recall rate of 86{\%} demonstrates that apps can unwittingly broadcast personal information openly despite using encrypted WiFi. The open-world false positive rate (38{\%} overall, or 72{\%} for unseen activity alone) leaves much room for improvement but the experiment demonstrates a plausible threat nevertheless. Finally, avenues for improvement and the limitations of this approach are identified. We discuss potential applications, strategies to prevent these leaks, and consider the effort required for an observer to present a practical privacy threat to the everyday WiFi user. This paper presents and demonstrates a nuanced and difficult to solve privacy vulnerability that cannot not be mitigated without considerable changes to current- and next-generation wireless communication protocols.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S0167739X16301480},
  bdsk-url-2      = {https://doi.org/10.1016/j.future.2016.05.030},
  doi             = {https://doi.org/10.1016/j.future.2016.05.030},
  keywords        = {Data protection, Information inference, Mobile apps, Privacy, Security,WiFi},
  url             = {http://www.sciencedirect.com/science/article/pii/S0167739X16301480},
}

@Conference{Deka2017727,
  author          = {Deka, B and Huang, Z and Franzen, C and Nichols, J and Li, Y and Kumar, R},
  title           = {{ZIPT: Zero-integration performance testing of mobile app designs}},
  booktitle       = {UIST 2017 - Proceedings of the 30th Annual ACM Symposium on User Interface Software and Technology},
  year            = {2017},
  pages           = {727--736},
  abstract        = {To evaluate the performance of mobile app designs, designers Andresearchers employ techniques such as A/B, usability, and analytics-driven testing. While these are all useful strategies for evaluating known designs, comparing many divergent solutions to identify the most performant remains a costly and difficult problem. This paper introduces a design performance testing approach that leverages existing app implementations and crowd workers to enable comparative testing at scale. This approach is manifest in ZIPT, a zero-integration performance testing platform that allows designers to collect detailed design and interaction data over any android app -including apps they do not own and did not build. Designers can deploy scripted tests via ZIPT to collect aggregate user performance metrics (e.g., completion rate, time on task) and qualitative feedback over third-party apps. Through case studies, we demonstrate that designers can use ZIPT's aggregate data and visualizations to understand the relative performance of interaction patterns found in the wild, and identify usability issues in existing android apps. {\textcopyright} 2017 Copyright held by the owner/author(s).},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1145/3126594:3126647},
  doi             = {10.1145/3126594:3126647},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041520399{\&}doi=10.1145{\%}2F3126594{\%}3A3126647{\&}partnerID=40{\&}md5=94feddecc1f241bf1410ae7abf0dae85},
}

@Conference{VanDerLee20181,
  author          = {{Van Der Lee}, W and Verwer, S},
  title           = {{Vulnerability Detection on Mobile Applications Using State Machine Inference}},
  booktitle       = {Proceedings - 3rd IEEE European Symposium on Security and Privacy Workshops, EURO S and PW 2018},
  year            = {2018},
  pages           = {1--10},
  abstract        = {Although the importance of mobile applications grows every day, recent vulnerability reports argue the application's deficiency to meet modern security standards. Testing strategies alleviate the problem by identifying security violations in software implementations. This paper proposes a novel testing methodology that applies state machine learning of mobile Android applications in combination with algorithms that discover attack paths in the learned state machine. The presence of an attack path evidences the existence of a vulnerability in the mobile application. We apply our methods to real-life apps and show that the novel methodology is capable of identifying vulnerabilities. {\textcopyright} 2018 IEEE.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1109/EuroSPW.2018.00008},
  doi             = {10.1109/EuroSPW.2018.00008},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050925614{\&}doi=10.1109{\%}2FEuroSPW.2018.00008{\&}partnerID=40{\&}md5=3c0fa1edb79ac21dc1b192cffe982a52},
}

@InProceedings{ISI:000380584300038,
  author          = {Zhu, Haowen and Ye, Xiaojun and Zhang, Xiaojun and Shen, Ke},
  title           = {{A Context-aware Approach for Dynamic GUI Testing of Android Applications}},
  booktitle       = {39TH ANNUAL IEEE COMPUTERS, SOFTWARE AND APPLICATIONS CONFERENCE (COMPSAC 2015), VOL 2},
  year            = {2015},
  editor          = {{Ahamed, SI and Chang, CK and Chu, W and Crnkovic, I and Hsiung, PA and Huang, G and Yang, JW}},
  series          = {Proceedings International Computer Software and Applications Conference},
  pages           = {248--253},
  organization    = {IEEE; IEEE Comp Soc; IEEE Big Data; IEEE Cloud Comp; IPS; Korean Inst Informat Scientists {\&} Engineers; CCF; Natl Cent Univ; Natl Chung Cheng Univ; Natl Chung Hsing Univ; Feng Chia Univ; Natl Ilan Univ; Iowa State Univ Sci {\&} Technol; Marquette Univ; Natl Tsing Hua univ; Natl Taichung Univ Sci {\&} Technol; Tunghai Univ; Minist Ssci {\&} Technol; Minist Econ Affairs, R O C; Minist Educ; Unison Healthcare Grp; Inventec; Academia Sinica; Natl Appl Res Labs},
  abstract        = {In this paper, we propose an automatic GUI testing approach for Android
applications. With the goal of exploring unexecuted event handlers of
the application under test as quickly possible, our approach constructs
and maintains a dynamic GUI model of the application at run time, which
is based on extended non-deterministic labelled transition system that
records the weight of transitions between GUI states. Extracting only
part of the GUI features of the application under test, the model keeps
itself simple enough to avoid state explosion and improves the test
efficiency, but provides targeted guidance for testing event generation
at the same time. A practical probabilistic search-based event selection
algorithm is used to leverage information provided by the model,
transform weight of transitions to priority of candidate events, and
select the testing event to execute. The algorithm solves the
non-deterministic problem introduced by the approximation of the model.
Empirical evaluation on several real world applications shows that our
approach can achieve high code coverage quickly and detect bugs
efficiently.},
  annote          = {39th IEEE Annual International Computer Software and Applications Conference Workshops (COMPSAC), Taichung, TAIWAN, JUL 01-05, 2015},
  bdsk-url-1      = {http://dx.doi.org/10.1109/COMPSAC.2015.77},
  doi             = {10.1109/COMPSAC.2015.77},
  isbn            = {978-1-4673-6563-5},
  issn            = {0730-3157},
}

@InProceedings{ISI:000366592100215,
  author          = {Wang, Dong and Zhou, Ming},
  title           = {{A Framework to Test Reliability and Security of Wi-Fi Device}},
  booktitle       = {2014 15TH INTERNATIONAL CONFERENCE ON ELECTRONIC PACKAGING TECHNOLOGY (ICEPT)},
  year            = {2014},
  editor          = {{Bi, K and Tian, Z and Xu, Z}},
  pages           = {953--958},
  organization    = {IEEE Component Packaging {\&} Mfg Technol Soc; Chinese Inst Elect, Elect Mfg {\&} Packaging Technol Soc; Univ Elect Sc {\&} Technol China},
  abstract        = {Wireless LAN is increasingly common, but it has created a new security
threats because hackers do not have to connect the device via a physical
network, but just in the same wireless LAN, they can launch an attack on
the target device. Driver security is critical for mobile devices, in
order to test whether the drivers have security vulnerabilities in
design or implementation, we proposed a Fuzzing testing framework, and
for the Android mobile device's Wi-Fi driver, Perform multiple scene
tests, results show that this framework is quite effective in
confirmation of known vulnerabilities and discovery of unknown threats.},
  annote          = {15th International Conference on Electronic Packaging Technology (ICEPT), Chinese Inst Elect, Chengdu, PEOPLES R CHINA, AUG 12-15, 2014},
  isbn            = {978-1-4799-4707-2},
}

@Article{Verma2016618,
  author          = {Verma, S and Muttoo, S K},
  title           = {{An android malware detection framework-based on permissions and intents}},
  journal         = {Defence Science Journal},
  year            = {2016},
  volume          = {66},
  number          = {6},
  pages           = {618--623},
  abstract        = {With an exponential growth in smartphone applications targeting useful services such as banks, healthcare, m-commerce, security has become a primary concern. The applications downloaded from unofficial sources pose a security threat as they lack mechanisms for validation of the applications. The malware infected applications may lead to several threats such as leaking user's private information, enforcing malicious deductions for sending premium SMS, getting root privilege of the android system and so on. Existing anti-viruses depend on signature databases that need to be updated from time to time and are unable to detect zero-day malware. The Android Operating system allows inter-application communication through the use of component reuse by using intents. Unfortunately, message passing is also an application attack surface. A hybrid method for android malware detection by analysing the permissions and intent-filters of the manifest files of the applications is presented. A malware detection framework is developed based on machine learning algorithms and on the basis of the decision tree obtained from ID3 and J48 classifiers available in WEKA. Both algorithms gave same results with an error percentage of 6 per cent. The system improves detection of zero day malware. {\textcopyright} 2016, DESIDOC.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.14429/dsj.66.10803},
  doi             = {10.14429/dsj.66.10803},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84994376728{\&}doi=10.14429{\%}2Fdsj.66.10803{\&}partnerID=40{\&}md5=d84c9889fe06d5fad323a3f5972d75f4},
}

@Conference{Guo20148,
  author          = {Guo, C and Xu, J and Yang, H and Zeng, Y and Xing, S},
  title           = {{An automated testing approach for inter-application security in android}},
  booktitle       = {9th International Workshop on Automation of Software Test, AST 2014 - Proceedings},
  year            = {2014},
  pages           = {8--14},
  abstract        = {Recently, Google Android has occupied a major market share of mobile phone systems as a result of its openness for developers and richness for users. By the distribution channels of the Android market, both development and use of Android applications soar. However, the low development threshold of applications leads to weak security awareness of developers. Moreover, Android applications lack strict security standards, resulting that security crisis has become increasingly prominent. For now, an application's biggest security threat falls on its messaging mechanism between components. Once permission's verification is neglected, it is easy to be exploited by attackers, causing immeasurable loss. We analyze the security mechanism of Android inter-application components, and accordingly construct the security rules. Specifically, a compositional approach including static and dynamic automated testing techniques is proposed to detect the security vulnerabilities caused by messaging between components. In our approach, the static part obtains rough results and some parameter information. After that, the dynamic part automatically generates attack cases for verifying these results. This approach can be used not only to discover potential weaknesses within inter-application components but also to automatically simulate attack behaviors. Thereby, the detection results' effectiveness can be verified. Copyright 2014 ACM.},
  annote          = {cited By 6},
  bdsk-url-1      = {http://dx.doi.org/10.1145/2593501.2593503},
  doi             = {10.1145/2593501.2593503},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84939507071{\&}doi=10.1145{\%}2F2593501.2593503{\&}partnerID=40{\&}md5=4937d4ecd2424334e119d504d419dcb8},
}

@InProceedings{Huang:2016:AGR:2940353.2940356,
  author          = {Huang, Tian and Zhang, Zhenyu and Zhu, Xue-Yang},
  title           = {{Analyzing GUI Running Fluency for Android Apps}},
  booktitle       = {Proceedings of the 3rd ACM Workshop on Mobile Sensing, Computing and Communication},
  year            = {2016},
  series          = {MSCC '16},
  pages           = {16--22},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {Android as a free open platform has become increasingly popular and been widespread adopted in mobile, tablet, and other devices. However, a great number of issues, such as inadequate quality and the fragmentation phenomenon, have emerged, enhancing the difficulty of developing. Among them, the running fluency of Android apps directly affects user experience directly. As a result, it is of great significance to detect and analyze it.

The frame rate and 16-ms-per-frame benchmark are the most popular metrics to evaluate and measure the smooth performance of Android application GUIs and to test the quality of apps by developers. However, very few studies have analyzed the performance and consider the adequate usage of frame rate before extensively applying it. Further, current tools provided by Google or third-party cannot obtain the frame rate and rendering time for the system with multiple applications.

In this work, we focus on the performance issue, revisit and analyze various factors that Android apps do not run smoothly, along with Android graphic system. After that, we present ARFluency --- a tool to measure and automatically analyze the system and applications without modifying the source code of the Android apps. We also conduct an experiment to validate our tool using realistic Android apps. Experimental results show that although even the apps running fluently do have problematic frames. However, the metrics of frame rate cannot accurately reflect the performance of Android applications.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/2940353.2940356},
  bdsk-url-2      = {http://dx.doi.org/10.1145/2940353.2940356},
  doi             = {10.1145/2940353.2940356},
  isbn            = {978-1-4503-4343-5},
  keywords        = {FPS, performance analysis, running fluency,Android},
  url             = {http://doi.acm.org/10.1145/2940353.2940356},
}

@Conference{Hu201177,
  author          = {Hu, C and Neamtiu, I},
  title           = {{Automating GUI testing for android applications}},
  booktitle       = {Proceedings - International Conference on Software Engineering},
  year            = {2011},
  pages           = {77--83},
  abstract        = {Users increasingly rely on mobile applications for computational needs. Google Android is a popular mobile platform, hence the reliability of Android applications is becoming increasingly important. Many Android correctness issues, however, fall outside the scope of traditional verification techniques, as they are due to the novelty of the platform and its GUI-oriented application construction paradigm. In this paper we present an approach for automating the testing process for Android applications, with a focus on GUI bugs. We first conduct a bug mining study to understand the nature and frequency of bugs affecting Android applications; our study finds that GUI bugs are quite numerous. Next, we present techniques for detecting GUI bugs by automatic generation of test cases, feeding the application random events, instrumenting the VM, producing log/trace files and analyzing them post-run. We show how these techniques helped to re-discover existing bugs and find new bugs, and how they could be used to prevent certain bug categories. We believe our study and techniques have the potential to help developers increase the quality of Android applications. {\textcopyright} 2011 ACM.},
  annote          = {cited By 142},
  bdsk-url-1      = {http://dx.doi.org/10.1145/1982595.1982612},
  doi             = {10.1145/1982595.1982612},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-79959449597{\&}doi=10.1145{\%}2F1982595.1982612{\&}partnerID=40{\&}md5=b45f9883459a5bca5af610a195c57e2e},
}

@Conference{Amin2016,
  author          = {Amin, M R and Zaman, M and Hossain, M S and Atiquzzaman, M},
  title           = {{Behavioral malware detection approaches for Android}},
  booktitle       = {2016 IEEE International Conference on Communications, ICC 2016},
  year            = {2016},
  abstract        = {Android, the fastest growing mobile operating system released in November 2007, boasts of a staggering 1.4 billion active users. Android users are susceptible to malicious applications that can hack into their personal data due to the lack of careful monitoring of their in-device security. There have been numerous works on devising malware detection methods. However, none of earlier works are conclusive enough for direct application and lack experimental validation. In this paper, we have investigated the natures and identities of malicious applications and devised two novel detection approaches for detection: network-based detection and system call based detection approaches. To evaluate our proposed approaches, we performed experiments on a subset of 1260 malwares, acquired from Android Malware Genome Project, a malware database created by Y. Zhou et al. [1] and 227 non-malware (benign) applications. Results show that our system call based approach is able to detect malwares with an accuracy of 87{\%} which is quite significant in general malware detection context. Our proposed detection approaches along with the experimental results will provide security professionals with more precise and quantitative approaches in their investigations of mobile malwares on Android systems. {\textcopyright} 2016 IEEE.},
  annote          = {cited By 3},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICC.2016.7511573},
  doi             = {10.1109/ICC.2016.7511573},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84981313545{\&}doi=10.1109{\%}2FICC.2016.7511573{\&}partnerID=40{\&}md5=20c2c90790655e17ea9da96d0192796f},
}

@InProceedings{8328366,
  author          = {Sun, Y and Xie, Y and Qiu, Z and Pan, Y and Weng, J and Guo, S},
  title           = {{Detecting Android Malware Based on Extreme Learning Machine}},
  booktitle       = {Proceedings - 2017 IEEE 15th International Conference on Dependable, Autonomic and Secure Computing, 2017 IEEE 15th International Conference on Pervasive Intelligence and Computing, 2017 IEEE 3rd International Conference on Big Data Intelligence and Computing and 2017 IEEE Cyber Science and Technology Congress, DASC-PICom-DataCom-CyberSciTec 2017},
  year            = {2017},
  volume          = {2018-January},
  pages           = {47--53},
  month           = {nov},
  abstract        = {To relieve increasingly prominent security issues of Android applications, static malware-detection techniques have become essential, due to their rapid and convenient detection processes which do not require running the detected applications. Most of current commercial anti-malware tools utilize signatures of known malicious Android codes for static detection, but are unable to find out unknown, especially newly created, malware. Many existing malware-detection researches rely on traditional machine learning techniques to analyze some static features of Android applications such as permissions and API calls, but the detection approaches still have room for improvement with respect to simplicity, effectiveness or efficiency. To overcome the limitations of the above detection techniques, we propose a novel static approach to detect malicious Android applications by proposing a set of Android program features, consisting of sensitive permissions and sensitive API calls, and by utilizing Extreme Learning Machine. We implemented our approach with an automated testing tool called WaffleDetector. Controlled experiments have been conducted to compare our approach and the existing ones on detecting malicious Android applications, and the results show that our approach excels the existing ones with minimal human intervention, better detection effectiveness and less detection time.},
  annote          = {From Duplicate 1 (Detecting Android Malware Based on Extreme Learning Machine - Sun, Y; Xie, Y; Qiu, Z; Pan, Y; Weng, J; Guo, S) cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1109/DASC-PICom-DataCom-CyberSciTec.2017.24},
  doi             = {10.1109/DASC-PICom-DataCom-CyberSciTec.2017.24},
  keywords        = {,Android,Android (operating system),Android Malware,Android program features,Androids,Extreme Learning Mchine,Feature extraction,Humanoid robots,Malware,Malware Detection,Sensitive API,Sensitive Permission,Smart phones,Tools,application program interfaces,commercial anti-malware tools,convenient detection processes,existing malware-detection researches,extreme learning machine,invasive software,known malicious Android codes,learning (artificial intelligence),malicious Android applications,prominent security issues,rapid detection processes,sensitive API calls,static detection,static features,static malware-detection techniques,traditional machine},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85038013132{\&}doi=10.1109{\%}2FDASC-PICom-DataCom-CyberSciTec.2017.24{\&}partnerID=40{\&}md5=0feea7b2eeeb357a048c2c63310bb867},
}

@Conference{Chen20141,
  author          = {Chen, C.-M. and Lin, J.-M. and Lai, G.-H.},
  title           = {{Detecting mobile application malicious behaviors based on data flow of source code}},
  booktitle       = {Proceedings - 1st International Conference on Trustworthy Systems and Their Applications, TSA 2014},
  year            = {2014},
  pages           = {1--6},
  abstract        = {Mobile devices have become powerful and popular. Most internet applications are ported to mobile platform. Confidential personal information such as credit card and passwords are stored in mobile device for convenience. Therefore, mobile devices become the attack targets due to financial gain. Mobile applications are published in many market platforms without verification, hence malicious mobile applications can be deployed in such marketplaces. Two approaches for detecting malware, dynamic and static analysis, are commonly used in the literature. Dynamic analysis requires is that analyst run suspicious apps in a controlled environment to observe the behavior of apps to determine if the app is malicious or not. However, Dynamic analysis is time consuming, as some mobile application might be triggered after certain amount of time or special input sequence. In this paper static analysis is adopted to detect mobile malware and sensitive information is tracked to check if it is been released or used by malicious malware. In this paper, we present a mobile malware detection approach which is based on data flow of the reversed source code of the application. The proposed system tracks the data flow to detect and identify malicious behavior of malware in Android system. To validate the performance of proposed system, 252 malware form 19 families and 50 free apps from Google Play are used. The results proved that our method can successfully detecting malicious behaviours of Android APPs with the TPR 91.6{\%}. {\textcopyright} 2014 IEEE.},
  annote          = {cited By 6},
  bdsk-url-1      = {http://dx.doi.org/10.1109/TSA.2014.10},
  doi             = {10.1109/TSA.2014.10},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84915781592{\&}doi=10.1109{\%}2FTSA.2014.10{\&}partnerID=40{\&}md5=b57c653c75b50c14dd705893a89432cc},
}

@InProceedings{7272677,
  author          = {Nakajima, S},
  title           = {{Formal Analysis of Android Application Behavior with Real-Time Maude}},
  booktitle       = {2015 IEEE 3rd International Conference on Cyber-Physical Systems, Networks, and Applications},
  year            = {2015},
  pages           = {7--12},
  abstract        = {Model-based analysis is a method to study energy consumption issues at early stages of development. While hardware components are direct consumers of a battery, application programs to request these components are responsible for the total consumption. Since the behavior of these multi-thread programs is concurrent and asynchronous, the analysis on the energy consumption behavior is complicated. This paper uses Real-Time Maude for analyzing energy consumption of a whole system behavior consisting of hardware components and application programs as well as the framework. Example scenarios on detecting energy bugs demonstrate that the time-bounded analysis method using Real-Time Maude is effective.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/CPSNA.2015.11},
  doi             = {10.1109/CPSNA.2015.11},
  keywords        = {formal specification;formal verification;mobile computing;multi-threading;program debugging;rewriting systems;smart phones;formal analysis;Android application behavior;real-time Maude;model-based analysis;multithread program;energy consumption;energy bug detection;time-bounded analysis;mobile computing;IEEE 802.11 Standard;Principal component analysis;Real-time systems;Androids;Humanoid robots;Energy consumption;Automata;Activity Lifecycle;Energy Consumption;Hybrid Automaton;Reachability Analysis},
}

@Conference{Schnepf20181,
  author          = {Schnepf, N and Badonnel, R and Lahmadi, A and Merz, S},
  title           = {{Generation of SDN policies for protecting android environments based on automata learning}},
  booktitle       = {IEEE/IFIP Network Operations and Management Symposium: Cognitive Management in a Cyber World, NOMS 2018},
  year            = {2018},
  pages           = {1--7},
  abstract        = {Software-defined networking offers new opportu-nities for protecting end users and their applications. In that context, dedicated chains can be built to combine different security functions, such as firewalls, intrusion detection systems and services for preventing data leakage. To configure these security chains, it is important to have an adequate model of the patterns that end user applications exhibit when accessing the network. We propose an automated strategy for learning the networking behavior of end applications using algorithms for generating finite state models. These models can be exploited for inferring SDN policies ensuring that applications respect the observed behavior: such policies can be formally verified and deployed on SDN infrastructures in a dynamic and flexible manner. Our solution is prototypically implemented as a collection of Python scripts that extend our Synaptic verification package. The performance of our strategy is evaluated through extensive experimentations and is compared to the Synoptic and Invarimint automata learning algorithms. {\textcopyright} 2018 IEEE.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1109/NOMS.2018.8406153},
  doi             = {10.1109/NOMS.2018.8406153},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85050679510{\&}doi=10.1109{\%}2FNOMS.2018.8406153{\&}partnerID=40{\&}md5=aec1daafb997ecb6f49e1d51f5264ce4},
}

@InProceedings{7395565,
  author          = {Niazi, R H and Shamsi, J A and Waseem, T and Khan, M M},
  title           = {{Signature-based detection of privilege-escalation attacks on Android}},
  booktitle       = {Proceedings - 2015 Conference on Information Assurance and Cyber Security, CIACS 2015},
  year            = {2016},
  pages           = {44--49},
  abstract        = {Android has become a major player in smartphone software arena, thanks to the massively positive reception of Google Play by the developers and users alike. In general, Android applications follow a set of permissions, which are used for access control. However, through the privilege-escalation vulnerability, a malicious application can escalate itself and access an un-permitted resource. Consequently, serious security and safety exploits such as privacy violation, reverse-shell access to the device, and drive-by downloads may occur. We propose a flexible and efficient defense mechanism against such exploits. Our solution - SAndroid, is an extensible and a lightweight application. It provides enhanced safety and security against privilege escalation attacks through rapid detection. SAndroid is based on active monitoring and detection of malicious applications through tracking of system logs and malicious process signatures. The assurance of safety provided by SAndroid is confirmed through design, testing, and verification. SAndroid follows modular approach permitting high flexibility and efficiency. Through real experiments, we confirmed that SAndroid is an efficient and low cost solution having negligible false-positives. This paper describes the architecture and design of the SAndroid framework and provides details of our experiments. {\textcopyright} 2015 IEEE.},
  annote          = {From Duplicate 1 (Signature-based detection of privilege-escalation attacks on Android - Niazi, R H; Shamsi, J A; Waseem, T; Khan, M M) cited By 4},
  bdsk-url-1      = {http://dx.doi.org/10.1109/CIACS.2015.7395565},
  doi             = {10.1109/CIACS.2015.7395565},
  keywords        = {,Android,Android (operating system),Androids,Browsers,Google Play,Humanoid robots,Internet,Malware,Monitoring,Operating System Security,Privilege Escalation,SAndroid framework,Safety,Security,Security and Safety,Social Networks and Web Security,System Assurance,access control,authorisation,digital signatures,modular approach,privilege-escalation attacks detection,privilege-escalation vulnerability,signature-based attack detection,smart phone software arena,smart phones},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84964829174{\&}doi=10.1109{\%}2FCIACS.2015.7395565{\&}partnerID=40{\&}md5=926234550889c8202dffe995ad45bc8d},
}

@Conference{Titze20151136,
  author          = {Titze, D and Sch{\"{u}}tte, J},
  title           = {{Preventing library spoofing on android}},
  booktitle       = {Proceedings - 14th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, TrustCom 2015},
  year            = {2015},
  volume          = {1},
  pages           = {1136--1141},
  abstract        = {Dynamic loading of libraries is a widely used technique in Android applications. But including and executing external library code does not only have benefits, it can have severe detrimental security implications for the application and the user. In this paper we explain the mechanisms of loading external library code into an Android application and discuss resulting security implications. Since an attacker can easily impersonate libraries if the application does not perform the necessary verification, loading such code can introduce severe security problems. As a remedy, we present how external code can be verified and since currently available application often do not perform such verification, we introduce a novel way to enforce this verification. {\textcopyright} 2015 IEEE.},
  annote          = {cited By 2},
  bdsk-url-1      = {http://dx.doi.org/10.1109/Trustcom.2015.494},
  doi             = {10.1109/Trustcom.2015.494},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84967153594{\&}doi=10.1109{\%}2FTrustcom.2015.494{\&}partnerID=40{\&}md5=8eb7e783a2e93c5552529e769786624f},
}

@Conference{Yang2016563,
  author          = {Yang, Y and Cai, L and Zhang, Y},
  title           = {{Research on non-authorized privilege escalation detection of android applications}},
  booktitle       = {2016 IEEE/ACIS 17th International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing, SNPD 2016},
  year            = {2016},
  pages           = {563--568},
  abstract        = {This paper briefly analyzes the security mechanism of android platform and describes permission statement and request of android application. According to android permission mechanism and its shortcoming, the android privilege escalation detection technology and attacking principle is mainly analyzed, and privilege escalation attacking model and architecture of application is put forward. Penetration testing tool Drozer is used to detect application permission. Application package and Manifest file is analyzed to obtain privilege elevation vulnerability. At the same time, sensitive combination permission is distinguished to avoid and exclude the use of malicious code. {\textcopyright} 2016 IEEE.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1109/SNPD.2016.7515959},
  doi             = {10.1109/SNPD.2016.7515959},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84983273937{\&}doi=10.1109{\%}2FSNPD.2016.7515959{\&}partnerID=40{\&}md5=90359558ad9ef1b912e2feb10f8f3f02},
}

@Conference{Tao2016480,
  author          = {Tao, C and Gao, J},
  title           = {{On building test automation system for mobile applications using GUI ripping}},
  booktitle       = {Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE},
  year            = {2016},
  volume          = {2016-January},
  pages           = {480--485},
  abstract        = {With the rapid advance of mobile computing technology and wireless networking, there is a significant increase of mobile subscriptions. This brings new business requirements and demands in mobile software testing, and causes new issues and challenges in mobile testing and automation. Current existing mobile application testing tools mostly concentrate on GUI, load and performance testing which seldom consider large-scale concurrent automation, coverage analysis, fault tolerance and usage of well-defined models. This paper introduces an implemented system that provides an automation solution across platforms on diverse devices using GUI ripping test scripting technique. Through incorporating open source technologies such as Appium and Selenium Grid, this paper addresses the scalable test automation control with the capability of fault tolerant. Additionally, maximum test coverage can also be obtained by executing parallel test scripts within the model. Finally, the paper reports case studies to indicate the feasibility and effectiveness of the proposed approach.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.18293/SEKE2016-168},
  doi             = {10.18293/SEKE2016-168},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84988358022{\&}doi=10.18293{\%}2FSEKE2016-168{\&}partnerID=40{\&}md5=00aed5e24fdf96cee6de18b3ede0dc8f},
}

@InProceedings{8306005,
  author          = {Sun, H and North, A and Binder, W},
  title           = {{Multi-Process Runtime Verification for Android}},
  booktitle       = {Proceedings - Asia-Pacific Software Engineering Conference, APSEC},
  year            = {2017},
  volume          = {2017-December},
  pages           = {701--706},
  abstract        = {With the popularity of Android, a huge number of Android apps appear in different markets. As some apps pose significant security risks, it is important to support runtime monitoring and verification on Android. Existing runtime verification frameworks only focus on verifying the events within a single process, ignoring that Android is a multi-process system where different components communicate frequently, and thus lack the ability to analyze and monitor behaviors across app processes. In this paper, we introduce our new runtime verification framework for Android, capable of performing runtime verification across multiple Android components in different processes. Our approach features an extended regular expression formalism, allowing one to specify complete analyses covering the whole Android system. We illustrate the use of our framework with an Android service characterization study and a monitor for permission (mis) use in apps.},
  annote          = {From Duplicate 1 (Multi-Process Runtime Verification for Android - Sun, H; North, A; Binder, W) cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1109/APSEC.2017.89},
  doi             = {10.1109/APSEC.2017.89},
  keywords        = {,Android,Android (operating system),Android apps,Android service characterization study,Androids,Humanoid robots,Instrumentation,Instruments,Libraries,Monitoring,Runtime Verification,Smart phones,Tools,mobile computing,multiple Android components,multiprocess runtime verification,multiprocess system,program verification,runtime monitoring,runtime verification framework,security of data,significant security risks,system monitoring},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045894130{\&}doi=10.1109{\%}2FAPSEC.2017.89{\&}partnerID=40{\&}md5=c49dc231a62d8a92446b2e00df60c7da},
}

@Conference{Wu201827,
  author          = {Wu, H and Wang, Y and Rountev, A},
  title           = {{SENTINEL: GENERATING GUI TESTS for ANDROID SENSOR LEAKS}},
  booktitle       = {Proceedings - International Conference on Software Engineering},
  year            = {2018},
  pages           = {27--33},
  abstract        = {Due to the widespread use of Android devices and apps, it is important to develop tools and techniques to improve app quality and performance. Our work focuses on a problem related to hardware sensors on Android devices: the failure to disable unneeded sensors, which leads to sensor leaks and thus battery drain. We propose the Sentinel testing tool to uncover such leaks. The tool performs static analysis of app code and produces a model which maps GUI events to callback methods that affect sensor behavior. The model is traversed to identify paths that are likely to exhibit sensor leaks during run-time execution. The reported paths are then used to generate test cases. The execution of each test case tracks the run-time behavior of sensors and reports observed leaks. Our experimental results indicate that Sentinel effectively detects sensor leaks, while focusing the testing efforts on a very small subset of possible GUI event sequences. {\textcopyright} 2018 ACM.},
  annote          = {cited By 1},
  bdsk-url-1      = {http://dx.doi.org/10.1145/3194733.3194734},
  doi             = {10.1145/3194733.3194734},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85051212985{\&}doi=10.1145{\%}2F3194733.3194734{\&}partnerID=40{\&}md5=08bea26b3b5c35a0268910d53bf11e39},
}

@Conference{Borys2018362,
  author          = {Borys, M and Milosz, M},
  title           = {{Mobile application usability testing in quasi-real conditions-the synergy of using different methods}},
  booktitle       = {Proceedings - 2018 11th International Conference on Human System Interaction, HSI 2018},
  year            = {2018},
  pages           = {362--368},
  abstract        = {The article presents the methodology applied and the results of the usability tests of a mobile application for controlling access to rooms using a smartphone. In the studies with the involvement of potential users, the user testing method was used to evaluate the most frequently used functionalities of the application in quasi-real conditions. The quasi-real conditions were reproduced in a controlled manner in the laboratory. The results of the research were obtained through the recording of user activities using the concurrent think-aloud protocol and mobile eye tracker followed by the individual in-depth interview and paper-based questionnaire. The data obtained with concurrent think-aloud protocol and eye tracking was analysed by usability experts. The final results of the research are a derivative of the analysis of the results of all methods and use the synergy effect. The article also presents a list of diagnosed application's usability problems, classification of their severity and recommendations on how to remove them. {\textcopyright} 2018 IEEE.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1109/HSI.2018.8431342},
  doi             = {10.1109/HSI.2018.8431342},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052741234{\&}doi=10.1109{\%}2FHSI.2018.8431342{\&}partnerID=40{\&}md5=5e0e5e1073a23e13becd4783bda0772d},
}

@Conference{Sinaga2018534,
  author          = {Sinaga, A M and {Adi Wibowo}, P and Silalahi, A and Yolanda, N},
  title           = {{Performance of automation testing tools for android applications}},
  booktitle       = {Proceedings of 2018 10th International Conference on Information Technology and Electrical Engineering: Smart Technology for Better Society, ICITEE 2018},
  year            = {2018},
  pages           = {534--539},
  abstract        = {The number of mobile application is growing remarkably. Hence, the requirement of testing on mobile application is essential in order to assure that all applications on the market have good quality. Testing on mobile application can be conducted manually or automatically. The automation testing utilizes a testing tool to perform test case execution and verification automatically. The utilization of automation testing can improve the performance of testing. There are various automation testing tools for mobile application with different capabilities and characteristics such as Appium, Robotium, and UI Automator. This paper presents an empirical investigation of the performance comparison of automation testing tools when applied into four Android applications as objects under test. Android is a popular operating system for smartphone with a huge number of applications. The result shows that the tools have their advantages and disadvantages. Detail performance comparison of the three tools is presented in this paper. Based on the experiment result, this paper provides recommendation for the utilization of each of the tools. {\textcopyright} 2018 IEEE.},
  annote          = {cited By 0},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICITEED.2018.8534756},
  doi             = {10.1109/ICITEED.2018.8534756},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85058378404{\&}doi=10.1109{\%}2FICITEED.2018.8534756{\&}partnerID=40{\&}md5=c0d3f2e3e67ba71061eacdac57c1b29b},
}

@InProceedings{7967989,
  author          = {Cimitile, A and Martinelli, F and Mercaldo, F and Nardone, V and Santone, A and Vaglini, G},
  title           = {{Model Checking for Mobile Android Malware Evolution}},
  booktitle       = {2017 IEEE/ACM 5th International FME Workshop on Formal Methods in Software Engineering (FormaliSE)},
  year            = {2017},
  pages           = {24--30},
  abstract        = {Software engineering researchers have largely demonstrated that newer versions of software make use of previous versions of existing software. No exception to this rule for the so-called malicious software, that frequently evolves in order to evade the detection by antimalware. As matter of fact, mobile malicious programs, such as trojans, are frequently related to previous malware through evolutionary relationships. Discovering those relationships and constructing a phylogenetic model is expected to be helpful for analyzing new malware and for establishing a principled naming scheme. In this paper we propose a model checking based method to infer mobile malware phylogenetic trees. We demonstrate, implementing our approach in the droid-Sapiens tool, that mobile malware families come from an ancestor and they infuence own descendant, basing on the payload that they exhibit.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/FormaliSE.2017.4},
  doi             = {10.1109/FormaliSE.2017.4},
  keywords        = {Android (operating system);formal verification;invasive software;mobile computing;model checking;mobile Android malware evolution;software engineering;malicious software;antimalware;mobile malicious programs;trojans;phylogenetic model;mobile malware phylogenetic trees;droid-Sapiens tool;mobile malware families;Malware;Mobile communication;Model checking;Androids;Humanoid robots;Phylogeny;security;malware;evolution;phylogenesys;model checking},
}

@InProceedings{8337376,
  author          = {Zhou, Z and Sun, C and Lu, J and f. Lv},
  title           = {{Research and Implementation of Mobile Application Security Detection Combining Static and Dynamic}},
  booktitle       = {2018 10th International Conference on Measuring Technology and Mechatronics Automation (ICMTMA)},
  year            = {2018},
  pages           = {243--247},
  month           = {feb},
  abstract        = {With the popularity of the Internet and mobile intelligent terminals, the number of mobile applications is exploding. Mobile intelligent terminals trend to be the mainstream way of people's work and daily life online in place of PC terminals. Mobile application system brings some security problems inevitably while it provides convenience for people, and becomes a main target of hackers. Therefore, it is imminent to strengthen the security detection of mobile applications. This paper divides mobile application security detection into client security detection and server security detection. We propose a combining static and dynamic security detection method to detect client-side. We provide a method to get network information of server by capturing and analyzing mobile application traffic, and propose a fuzzy testing method based on HTTP protocol to detect server-side security vulnerabilities. Finally, on the basis of this, an automated platform for security detection of mobile application system is developed. Experiments show that the platform can detect the vulnerabilities of mobile application client and server effectively, and realize the automation of mobile application security detection. It can also reduce the cost of mobile security detection and enhance the security of mobile applications.},
  bdsk-url-1      = {http://dx.doi.org/10.1109/ICMTMA.2018.00065},
  doi             = {10.1109/ICMTMA.2018.00065},
  issn            = {2157-1481},
  keywords        = {client-server systems;Internet;mobile computing;security of data;mobile intelligent terminals trend;client security detection;server security detection;mobile application traffic;mobile application client;mobile application security detection;mobile application security detection;Security;Mobile applications;Servers;Internet;Fingerprint recognition;Packaging;Engines;security detection of mobile application;security detection combining static and dynamic;capture mobile application traffic;fuzzy testing method;automated platform for security detection of mobile application system},
}

@InProceedings{ISI:000366872700026,
  author          = {Weinlich, Petr and Semeradova, Tereza},
  title           = {{Usability Testing of Early Warning Mobile Applications with Eye Tracking}},
  booktitle       = {INNOVATION MANAGEMENT AND SUSTAINABLE ECONOMIC COMPETITIVE ADVANTAGE: FROM REGIONAL DEVELOPMENT TO GLOBAL GROWTH, VOLS I - VI, 2015},
  year            = {2015},
  editor          = {{Soliman, KS}},
  pages           = {248--254},
  organization    = {Int Business Informat Management Assoc},
  abstract        = {The fallowing paper explores the possibilities of implementing eye
tracking technology during the design of an early warning mobile
application. The authors using two available mobile applications related
to crises management apply eye tracker testing in order to identify
possible insufficiencies in the applications' design from the user
perspective. However, the main aim of the paper does not consist in
proposing optimizations for the presented applications, the authors
focus rather on designing a suitable testing method that could be used
for the assessment of a future early warning application adjusted to
fulfill user design (UX) requirements.},
  annote          = {26th International-Business-Information-Management-Association Conference, Madrid, SPAIN, NOV 11-12, 2015},
  isbn            = {978-0-9860419-5-2},
}

@InProceedings{Mathur:2018:UEF:3210459.3210480,
  author          = {Mathur, Neeraj and Karre, Sai Anirudh and Reddy, Y Raghu},
  title           = {{Usability Evaluation Framework for Mobile Apps Using Code Analysis}},
  booktitle       = {Proceedings of the 22Nd International Conference on Evaluation and Assessment in Software Engineering 2018},
  year            = {2018},
  series          = {EASE'18},
  pages           = {187--192},
  address         = {New York, NY, USA},
  publisher       = {ACM},
  abstract        = {The increasing usage of smart-phones has resulted in mobile applications replacing or supplementing traditional web-based applications. Given the limitations of the form factor in smartphones, usability can be considered as one of the important attributes that determine the success of a mobile application. The measures available for assessing the usability of mobile applications tend to focus more on human aspects and less on the functional aspects of usability. As part of this paper, we propose a usability evaluation framework to identify functional usability issues specific to mobile applications. This framework uses usability guidelines and code analysis to improve the usability of a mobile application. As a proof of concept, we have built an end-to-end system using the framework to validate and verify usability issues in Android mobile applications. We also generate code recommendations to implement failed usability guidelines.},
  bdsk-url-1      = {http://doi.acm.org/10.1145/3210459.3210480},
  bdsk-url-2      = {http://dx.doi.org/10.1145/3210459.3210480},
  doi             = {10.1145/3210459.3210480},
  isbn            = {978-1-4503-6403-4},
  keywords        = {Code Analysis, Mobile Apps, Mobile Usability, Usability Evaluation, Usability Guidelines,Automation},
  url             = {http://doi.acm.org/10.1145/3210459.3210480},
}

@Article{DONG201494,
  author          = {DONG, Hang and HE, Neng-qiang and HU, Ge and LI, Qi and ZHANG, Miao},
  title           = {{Malware detection method of android application based on simplification instructions}},
  journal         = {The Journal of China Universities of Posts and Telecommunications},
  year            = {2014},
  volume          = {21},
  pages           = {94--100},
  issn            = {1005-8885},
  abstract        = {The amount of mobile malicious code is increasing faster every year and a serious security threat is posed by this. Hence, malware detection has become a critical topic in the field of computer security. This paper proposes a method to detect variants of known malware families in Android devices using simplify Dalvik instructions. This method is based on the sequence of instructions. A method is described in this paper to give the simplified description of each instruction and group them with n-gram patterns, which are set to be the malicious features. The result of the experiment shows that features extracted by this method are easy to be recognized, thus an effective way to detect variants of known malware families is provided.},
  bdsk-url-1      = {http://www.sciencedirect.com/science/article/pii/S1005888514605069},
  bdsk-url-2      = {https://doi.org/10.1016/S1005-8885(14)60506-9},
  doi             = {https://doi.org/10.1016/S1005-8885(14)60506-9},
  keywords        = {android, malicious code, simplified description,opcode sequences},
  url             = {http://www.sciencedirect.com/science/article/pii/S1005888514605069},
}

@Conference{Lu2012322,
  author          = {Lu, Z and Mukhopadhyay, S},
  title           = {{Model-based static source code analysis of java programs with applications to android security}},
  booktitle       = {Proceedings - International Computer Software and Applications Conference},
  year            = {2012},
  pages           = {322--327},
  abstract        = {We combine static analysis techniques with modelbased deductive verification using SMT solvers to provide a framework that, given an analysis aspect of the source code, automatically generates an analyzer capable of inferring information about that aspect. The analyzer is generated by translating the collecting semantics of a program to a "marked" formula in first order logic over multiple underlying theories. The "marking" can be thought of as a set of holes or contexts corresponding to the "uninterpreted" APIs invoked in the program. Just as a program imports packages and uses methods from classes in those packages, we import the semantics of the API invocations as first order logic assertions. These assertions constitute the models used by the analyzer. Logical specification of the desired program behavior (rather its negation) is incorporated as a first order logic formula. An SMT-LIB formula solver treats the combined formula as a "constraint" and "solves" it. The "solved form" can be used to identify logical (security) errors in Java (Android) programs. Security properties of Android are represented as constraints and the analysis aims to show that these constraints are respected. {\textcopyright} 2012 IEEE.},
  annote          = {cited By 6},
  bdsk-url-1      = {http://dx.doi.org/10.1109/COMPSAC.2012.43},
  doi             = {10.1109/COMPSAC.2012.43},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84870852248{\&}doi=10.1109{\%}2FCOMPSAC.2012.43{\&}partnerID=40{\&}md5=6f07b59ba20b4f777bc8a7d8a1240873},
}

@Conference{Avancini201357,
  author          = {Avancini, A and Ceccato, M},
  title           = {{Security testing of the communication among Android applications}},
  booktitle       = {2013 8th International Workshop on Automation of Software Test, AST 2013 - Proceedings},
  year            = {2013},
  pages           = {57--63},
  abstract        = {An important reason behind the popularity of smartphones and tablets is the huge amount of available applications to download, to expand functionalities of the devices with brand new features. In fact, official stores provide a plethora of applications developed by third parties, for entertainment and business, most of which for free. However, confidential data (e.g., phone contacts, global GPS position, banking data and emails) could be disclosed by vulnerable applications. Sensitive applications should carefully validate exchanged data to avoid security problems. In this paper, we propose a novel testing approach to test communication among applications on mobile devices. We present a test case generation strategy and a testing adequacy criterion for Android applications. Our approach has been assessed on three widely used Android applications. {\textcopyright} 2013 IEEE.},
  annote          = {cited By 13},
  bdsk-url-1      = {http://dx.doi.org/10.1109/IWAST.2013.6595792},
  doi             = {10.1109/IWAST.2013.6595792},
  url             = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84885004405{\&}doi=10.1109{\%}2FIWAST.2013.6595792{\&}partnerID=40{\&}md5=360e3fd0689234618659aa92dcdbdae3},
}